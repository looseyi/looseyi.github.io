<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>WWDC21 - Discover concurrency in SwiftUI - Aha Edmond</title>

  
  
  <meta name="description" content="WWDC21 Session 10019 - Discover concurrency in SwiftUI 本文知识目录 本文属于 WWDC21 中 SwiftUI 与 Concurrency 结合应用的文章。 关于 SwiftUI 可以查看这篇介绍：Introduction to SwiftUI，而 Swift Concurrency 算是今" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/wwdc/wwdc21/wwdc21-session-10019/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="WWDC21 - Discover concurrency in SwiftUI" />
<meta property="og:description" content="WWDC21 Session 10019 - Discover concurrency in SwiftUI 本文知识目录 本文属于 WWDC21 中 SwiftUI 与 Concurrency 结合应用的文章。 关于 SwiftUI 可以查看这篇介绍：Introduction to SwiftUI，而 Swift Concurrency 算是今" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/wwdc/wwdc21/wwdc21-session-10019/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-11T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-06-11T00:00:00&#43;00:00" />


  
  <meta itemprop="name" content="WWDC21 - Discover concurrency in SwiftUI">
<meta itemprop="description" content="WWDC21 Session 10019 - Discover concurrency in SwiftUI 本文知识目录 本文属于 WWDC21 中 SwiftUI 与 Concurrency 结合应用的文章。 关于 SwiftUI 可以查看这篇介绍：Introduction to SwiftUI，而 Swift Concurrency 算是今"><meta itemprop="datePublished" content="2021-06-11T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2021-06-11T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="3241">
<meta itemprop="keywords" content="iOS&#39;,WWDC&#39;,SwiftUI," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="WWDC21 - Discover concurrency in SwiftUI"/>
<meta name="twitter:description" content="WWDC21 Session 10019 - Discover concurrency in SwiftUI 本文知识目录 本文属于 WWDC21 中 SwiftUI 与 Concurrency 结合应用的文章。 关于 SwiftUI 可以查看这篇介绍：Introduction to SwiftUI，而 Swift Concurrency 算是今"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2021-06-11</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>WWDC21 - Discover concurrency in SwiftUI</h1>
  </header>
  <section class="post-content"><p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-00-background.png" alt="10019-00-background"></p>
<blockquote>
<p>WWDC21 Session 10019 - <a href="https://developer.apple.com/videos/play/wwdc2021/10019/">Discover concurrency in SwiftUI</a></p>
</blockquote>
<h2 id="本文知识目录">本文知识目录</h2>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-Discover-concurrency-in-SwiftUI.png" alt="Build SwiftUI views for widgets"></p>
<p>本文属于 WWDC21 中 SwiftUI 与 Concurrency 结合应用的文章。</p>
<p>关于 SwiftUI 可以查看这篇介绍：<a href="https://wwdc.io/share/wwdc20/10119">Introduction to SwiftUI</a>，而 Swift Concurrency 算是今年 WWDC 的重头戏，从使用层面来看，就是引入了 <a href="https://developer.apple.com/videos/play/wwdc2021/10132/">Async / Await</a> 这一语法，但是解决的却是软件工程中最令人头疼的问题之一。</p>
<p>接下来让我们看看 Concurrency 新工具是如何与 SwiftUI 结合的。</p>
<blockquote>
<p>Tips：文末有示例代码地址。</p>
</blockquote>
<h2 id="引言">引言</h2>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-01-table.png" alt="10019-01-table">
随着Swift 5.5 及 SwiftUI 的更新，您将拥有一系列新的并发编程工具。本文将重点介绍在 SwiftUI 中的相关新特性，主要包括三个方面，分别为：<code>Concurrent Data Models</code>、<code>SwiftUI &amp; MainActor</code>、<code>New concurrency tools</code>。我们将通过一个星云图片浏览的 Demo 向您展示在 SwiftUI 中，现有的异步工具存在的问题，并运用新的并发工具来解决这些问题。最后我们会介绍 SwiftUI 中新引入的并发工具。</p>
<h2 id="concurrent-data-models">Concurrent Data Models</h2>
<p>在 Swift 中想要使用并发编程，对数据模型有哪些要求呢 ？让我们从零开始造火箭。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-02-model-spacephoto.png" alt="10019-02-model-spacephoto"></p>
<p>首先，定义了 <code>SpacePhoto</code>，它需要遵循 Codable 和 <a href="https://developer.apple.com/documentation/swift/identifiable">Identifiable</a> 这两个协议。Codeable 自不必多说，用于将原始数据解析成您定义的数据模型。而 Identifiable 协议则最早是在 SwiftUI 中出现的，在 Swift 5.1 被加入到 Swift 标准库中的。</p>
<h3 id="identifiable">Identifiable</h3>
<p>从字面看应该不难理解，它用来表示所关联的数据结构具有唯一标识。其定义如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">Identifiable</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    associatedtype ID : <span style="color:#b58900">Hashable</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">id</span>: <span style="color:#cb4b16">Self</span>.ID { <span style="color:#268bd2">get</span> }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
</code></pre></div><p>在之前版本的 SwiftUI 中，您使用 ForEach 遍历 Array 时需要提供一个 ID 来标识 Element 的唯一性：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>ForEach(photos.items, id: \.id) { item <span style="color:#719e07">in</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>  PhotoView(photo: item)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>当你的 Model 遵循了 Identifiable 协议就可以直接使用：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>ForEach(photos.items) { item <span style="color:#719e07">in</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>  PhotoView(photo: item)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>下面是苹果给出的定义，Identifiable 的唯一性是<strong>不限定持续时间和使用范围</strong>，可以是下面的任意场景：</p>
<ul>
<li>保证始终唯一（例如：UUID)。</li>
<li>每个环境永久唯一（例如：database record keys)。</li>
<li>在进程的生命周期内是唯一的（例如：global incrementing integers)。</li>
<li>在对象的生命周期内是唯一的（例如：object identifiers)。</li>
<li>在当前集合中是唯一的（例如：collection index)。</li>
</ul>
<p>另外有意思的是，Identifiable 将引用语义扩展到值类型，Swift 为 AnyObject 提供了默认实现：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">Identifiable</span> <span style="color:#719e07">where</span> <span style="color:#cb4b16">Self</span>: <span style="color:#b58900">AnyObject</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">id</span>: <span style="color:#b58900">ObjectIdentifier</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">ObjectIdentifier</span>(<span style="color:#cb4b16">self</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>}
</code></pre></div><blockquote>
<p>关于 Identifiable 更详细的讨论强烈推荐 Mattt 的这篇文章 <a href="https://nshipster.com/identifiable/">Identifiable</a>。</p>
</blockquote>
<h3 id="user-interface">User Interface</h3>
<p>展开下一个 Model 前，预览一下您要做出的星云 Demo 的效果：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-02-view-spacephoto.png" alt="10019-02-view-spacephoto"></p>
<h3 id="observableobject">ObservableObject</h3>
<p>接着使用 <code>ObservableObject</code> 来声明 Photos 用于监听数据的变更。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-03-model-photos.png" alt="10019-03-model-photos"></p>
<p>当有数据变更时，<code>ObservableObject</code> 中声明了 <strong>@Published</strong> 的属性将会收到 publisher 通过 <code>objectWillChange</code> 发来的通知。</p>
<p>我们先提供一个简单的 PhotoView 来展示每个星云的 title：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">struct</span> <span style="color:#268bd2">PhotoView</span>: View {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">photo</span>: SpacePhoto
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">body</span>: some View {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>        Text(photo.title)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>	  }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
</code></pre></div><p>接着我们在 Catalog 列表中来消费 photos。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-04-view-photo.png" alt="10019-04-view-photo"></p>
<p>逻辑也很简单，仅需在对应属性前增加 <code>@StateObject</code> 来表明 photos 数据是可变化的。</p>
<p>上面的 Preview 效果就是纯文本版本的 Catalog list。这个最终效果是使用了两个特性：</p>
<ul>
<li><strong>.listStyle(.plain)</strong></li>
<li><strong>.listRowSeparator(.hidden)</strong></li>
</ul>
<p>使用前后比对如下：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-04-new-api.png" alt="10019-04-new-api"></p>
<h2 id="swiftui--mainactor">SwiftUI &amp; MainActor</h2>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-06-run-loop.png" alt="10019-06-run-loop"></p>
<p>在 WWDC20 的 “<a href="https://developer.apple.com/videos/play/wwdc2020/10040/">Data essentials in SwiftUI</a>” 中，Raj 谈到了 SwiftUI 的生命周期，而 run loop 则是驱动该生命周期的工具。在 Swift 5.5 中 run loop 将运行在 <strong>MainActor</strong> 中。</p>
<h3 id="actor">Actor</h3>
<blockquote>
<p>关于 Actior 详细信息，可查看 “<a href="https://developer.apple.com/videos/play/wwdc2021/10133/">Protect mutable state with Swift actors</a>”。</p>
</blockquote>
<p>这里做简单了解，Actor 是定义成一个遵循 Sendable 的协议：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">Actor</span> : <span style="color:#b58900">AnyObject</span>, Sendable { }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">Sendable</span> { }
</code></pre></div><p>Swift 提供了 <code>actor</code> 关键字，同时也是一种新的具体名义类型，同 class、struct、enum 等。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>actor Photos {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>	<span style="color:#268bd2">var</span> <span style="color:#268bd2">items</span>: [SpacePhoto]
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>	...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
</code></pre></div><p>Actor 在概念上类似于在并发环境中可以安全使用的类。 因为 Swift 确保在任何给定时间只能由单个线程访问 actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。</p>
<p>而 main actor 是 actor 的一个全局单例，其声明如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>@globalActor <span style="color:#268bd2">public</span> actor MainActor {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">static</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">shared</span>: MainActor
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>我们通过添加 <code>@MainActor</code> 修饰后，Swift 会确保所修饰的代码会执行在主线程中。</p>
<h3 id="swiftui-run-loop">SwiftUI run loop</h3>
<p>run loop 过程，应用会不断接收用户事件，更新模型，最终将 SwiftUI 视图呈现到屏幕上。这里把每次循环的更新称作 “ticks of the run loop“。让我们展开这个循环，每个刻度表示一个循环，以便您可以连续查看多个刻度。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-06-run-loop-tick.png" alt="10019-06-run-loop-tick"></p>
<p>在 SwiftUI 中，ObservableObjects 可以通过一些有趣的方式与 SwiftUI run loop 交互。让我们回到 Photos ObservableObject 并查看 updateItems 方法。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-07-run-loop-code.png" alt="10019-07-run-loop-code"></p>
<p>在上图表示的是 <code>updateItems</code> 方法的执行在 SwiftUI run loop 中的状态变化，具体如下：</p>
<ul>
<li>蓝色矩形框：表示在一个 run loop 周期内执行 <code>updateItems</code> 方法的耗时。</li>
<li>橙色部分：表示获取到新数据后，会通过 publiser 的 <code>objectWillChange</code> 通知观察者有 photos 更新；</li>
<li>绿色 Snapshot：SwiftUI 在收到数据更新的通知后会对当前状态进行快照，为后续对比准备；</li>
<li>紫色部分：表示 items 数据已更新；</li>
<li>绿色 tick：在下一个 run loop tick 节点，SwiftUI 同样进行 items 快照，并与之前快照对比。</li>
</ul>
<p>从 SwiftUI 视图中调用 updateItems 时，这些逻辑均在 <code>MainActor</code> 上被顺序执行。不过上面描述的属于理想状态，很多时候您的数据更新会产生延迟。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-08-run-loop-blocking.png" alt="10019-08-run-loop-blocking"></p>
<p>上述为发生了主线程 block 的情况，错失一次 tick 的刷新机会，对于用户而言则算是一次障碍。过去解决方式就是使用 dispatch queues</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-09-poor-dispatch.png" alt="10019-09-poor-dispatch"></p>
<p>将 <code>updateItems</code> 的逻辑切换到了异步线程执行，而这将导致 run loop 的快照状态产生了变化。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-09-dispatch.png" alt="10019-09-dispatch"></p>
<p>可以看到，在异步更新的 <code>updateItems</code> 方法中，虽然触发了 <code>objectWIllChange</code> 调用，但 items 赋值还未完成，SwiftUI 却已进入下一个 run loop 周期，导致快照对比结果为未更新。而如果您能保证如下状态的顺序执行，则可以避免上述的情况。</p>
<ol>
<li><code>objectWillChange</code></li>
<li>The state changes</li>
<li>The run loop ticks</li>
</ol>
<p>解决方案就是：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-11-await.png" alt="10019-11-await"></p>
<h3 id="using-await">Using await</h3>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-12-await-code.png" alt="10019-12-await-code"></p>
<p>通过 <code>async / await</code> 的使用，使得状态变更能够在主线程被及时感知。上图中跳过的一段 tick 周期就是由于网络延迟等导致的 tick 空转。接下来就是实现 <code>fetchPhotos</code> 方法，逻辑很简单就是遍历 photos 然后获取对应 entity 和 image 即可：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>@MainActor
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#268bd2">class</span> <span style="color:#268bd2">Photos</span>: ObservableObject {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    @Published <span style="color:#268bd2">private</span>(<span style="color:#268bd2">set</span>) <span style="color:#268bd2">var</span> <span style="color:#268bd2">items</span>: [SpacePhoto] = []
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#586e75">// Updates `items` to a new, random list of photos.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">updateItems</span>() async {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#268bd2">let</span> <span style="color:#268bd2">fetched</span> = await fetchPhotos()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        items = fetched
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#586e75">// Fetches a new, random list of photos.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">fetchPhotos</span>() async -&gt; [SpacePhoto] {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#268bd2">var</span> <span style="color:#268bd2">downloaded</span>: [SpacePhoto] = []
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>        <span style="color:#719e07">for</span> query <span style="color:#719e07">in</span> Photos.keys {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            <span style="color:#268bd2">let</span> <span style="color:#268bd2">url</span> = SpacePhoto.request(key: query)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            <span style="color:#719e07">if</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">photo</span> = await fetchPhoto(from: url) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                downloaded.append(photo)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        <span style="color:#719e07">return</span> downloaded
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">fetchPhoto</span>(from url: URL) async -&gt; SpacePhoto? {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        <span style="color:#719e07">do</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            <span style="color:#268bd2">let</span> (data, <span style="color:#cb4b16">_</span>) = <span style="color:#719e07">try</span> await URLSession.shared.data(from: url)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>            <span style="color:#268bd2">let</span> <span style="color:#268bd2">decoder</span> = JSONDecoder()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>            <span style="color:#268bd2">let</span> <span style="color:#268bd2">response</span> = <span style="color:#719e07">try</span> decoder.decode(NASAResponse.<span style="color:#cb4b16">self</span>, from: data)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>            <span style="color:#719e07">return</span> response.collection.items.randomElement()?.data
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>        } <span style="color:#719e07">catch</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>            <span style="color:#268bd2">print</span>(error)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>            <span style="color:#719e07">return</span> <span style="color:#cb4b16">nil</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span>}
</code></pre></div><blockquote>
<p>这里提供的代码与官方 Demo 展示的 Photos 数据获取 API 稍有不同，本文采用了 NASA 提供的 <a href="https://images.nasa.gov/docs/images.nasa.gov_api_docs.pdf">image search API</a>。</p>
</blockquote>
<p>这里您用 <code>@MainActor</code> 来修饰了 Photos 类，之后 Swift Complier 会保证所有 Photos 的属性和方法都将通过  main actor 来访问。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>updateItems() async -&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>	fetchPhotos() async -&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>		fetchPhoto(from:) async -&gt;
</code></pre></div><p>可以看到三个方法都是使用了 async 关键字来声明其为异步执行。而对于 async 声明的方法，对应的需要配上 <strong>await</strong> 关键字。</p>
<p>最后就差 updateItems 的调用，让我们在 CatalogView 中来完成最后一步。</p>
<h2 id="new-concurrency-tools">New concurrency tools</h2>
<p>最后一节，我们来介绍几个支持异步更新的 API，为您的程序添加更友好的用户体验。</p>
<h3 id="task--refreshable">Task &amp; Refreshable</h3>
<p>SwiftUI 为 View 提供了新的入口来执行任务。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">struct</span> <span style="color:#268bd2">CatalogView</span>: View {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    @StateObject <span style="color:#268bd2">private</span> <span style="color:#268bd2">var</span> <span style="color:#268bd2">photos</span> = Photos()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">var</span> <span style="color:#268bd2">photoKey</span> = [<span style="color:#b58900">String</span> : SpacePhoto]()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">body</span>: some View {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        NavigationView {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            List {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>                ForEach(photos.items) { item <span style="color:#719e07">in</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>                    PhotoView(photo: item)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>                        .listRowSeparator(.hidden)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>                }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            .navigationTitle(<span style="color:#2aa198">&#34;Catalog&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            .listStyle(.plain)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            .refreshable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                await photos.updateItems()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        .task {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>            await photos.updateItems()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>}
</code></pre></div><p>当 View 展现屏幕上时候会触发任务的执行，在 View 消失时则会取消对应的任务。其定义如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">View</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    @inlinable <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">task</span>(<span style="color:#cb4b16">_</span> action: @escaping () async -&gt; <span style="color:#b58900">Void</span>) -&gt; some View
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>另外一个 New API 是 <code>refreshable</code>，本质上是一个 <a href="https://developer.apple.com/documentation/swiftui/viewmodifier">ViewModifier</a>，这里我们给 List 添加上 <code>refreshable</code> 后，它就能响应用户的下拉刷新动作。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-14-refreshable.gif" alt="10019-14-refreshable"></p>
<h3 id="asyncimage">AsyncImage</h3>
<p>AsyncImage 可以帮助您实现异步下载和展示图片，再结合上 ProgressView 让 Image 在下载过程中作为 placeholder 展示。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/10019-13-fetch-image.png" alt="10019-13-fetch-image"></p>
<h3 id="custom-button-action">Custom Button Action</h3>
<p>同 AsyncImage 一样的思路，您可以为 SaveButton 添加 ProgressView，当图片正在保存时以展示 ProgeessView 作为中间状态。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">struct</span> <span style="color:#268bd2">SavePhotoButton</span>: View {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">photo</span>: SpacePhoto
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    @State <span style="color:#268bd2">private</span> <span style="color:#268bd2">var</span> <span style="color:#268bd2">isSaving</span> = <span style="color:#cb4b16">false</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">body</span>: some View {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        Button {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            async {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>                isSaving = <span style="color:#cb4b16">true</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>                await photo.save()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>                isSaving = <span style="color:#cb4b16">false</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        } label: {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            Text(<span style="color:#2aa198">&#34;Saved&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                .opacity(isSaving ? <span style="color:#2aa198">0</span> : <span style="color:#2aa198">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>                .overlay {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>                    <span style="color:#719e07">if</span> isSaving {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                        ProgressView()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>                    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>                }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        .disabled(isSaving)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        .buttonStyle(.bordered)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>        .controlSize(.small) <span style="color:#586e75">// .large, .medium or .small</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>}
</code></pre></div><p>效果如下：</p>
<p><!-- raw HTML omitted --></p>
<h4 id="tips">Tips</h4>
<p>由于本文脱水过程 Apple 还未提供 Session 中的示例工程，这里作者参照视频中的代码提供了功能完备的 <a href="https://github.com/looseyi/WWDC-SampleCode.git">Demo Project</a>，有兴趣的小伙伴自取。记得用 Xcode 13 打开 😊。</p>
<h2 id="总结">总结</h2>
<p>这里您看到了 SwiftUI 与 Swift 的并发特性很好地集成在一起，默认情况下为用户提供了最佳行为。
在许多情况下，您只需要使用 <code>await</code> 来使用并发的能力。将 <code>ObservableObject</code> 标记为 <code>@MainActor</code>，以便更可靠地检查您的对象是否以适合您的视图的方式更新。</p>
<ul>
<li>使用 SwiftUI 的 API 附加功能，以最少的工作量编写安全且高性能的并发应用程序。</li>
<li>使用 <code>AsyncImage</code> 并发加载图像。</li>
<li>使用 <code>refreshable</code> 修饰符添加到视图层次结构中，以允许用户手动刷新数据。</li>
<li>就像您在 Save 按钮上看到的那样，您可以在自己的自定义视图中使用 Swift 的新并发功能。</li>
</ul>
<p>众所周知，在计算机领域并发是很棘手的一个难题，现在您拥有了管理应用程序中这种复杂性的工具。我们希望您喜欢并了解 Swift 5.5 和 SwiftUI 中出色的新并发工具，我们期待看到您使用它们解决应用程序中棘手问题。</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/ios">iOS&#39;</a>
     
    <a href="https://looseyi.github.io/tags/wwdc">WWDC&#39;</a>
     
    <a href="https://looseyi.github.io/tags/swiftui">SwiftUI</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/wwdc/wwdc21/wwdc21-session-10056/"><span>←</span><span>WWDC21 - 让您的 iPad 与 iPhon 应用程序在 M1 的 Mac 上大放异彩</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-cocoapods/08-cocoapods-xcodeproj/"><span>8. Xcode 工程文件解析</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
