<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>Cocoa 文档注释与生成工具使用 - Jazzy &#43; SourceKitten - Aha Edmond</title>

  
  
  <meta name="description" content="我们在前文 《Cocoa 代码注释与文档生成》 中详细介绍了如何为 Swift &amp; ObjC 的代码编写符合规范的注释，以及使用 Jazzy 来生成项目文档。 今天我们来尝试一下，如" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/tool/cocoa-documentation-2/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="Cocoa 文档注释与生成工具使用 - Jazzy &#43; SourceKitten" />
<meta property="og:description" content="我们在前文 《Cocoa 代码注释与文档生成》 中详细介绍了如何为 Swift &amp; ObjC 的代码编写符合规范的注释，以及使用 Jazzy 来生成项目文档。 今天我们来尝试一下，如" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/tool/cocoa-documentation-2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-06-18T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-06-18T00:00:00&#43;00:00" />


  
  <meta itemprop="name" content="Cocoa 文档注释与生成工具使用 - Jazzy &#43; SourceKitten">
<meta itemprop="description" content="我们在前文 《Cocoa 代码注释与文档生成》 中详细介绍了如何为 Swift &amp; ObjC 的代码编写符合规范的注释，以及使用 Jazzy 来生成项目文档。 今天我们来尝试一下，如"><meta itemprop="datePublished" content="2020-06-18T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-06-18T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4098">
<meta itemprop="keywords" content="iOS&#39;,Document,SourceKit,Jazzy,gitpage," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cocoa 文档注释与生成工具使用 - Jazzy &#43; SourceKitten"/>
<meta name="twitter:description" content="我们在前文 《Cocoa 代码注释与文档生成》 中详细介绍了如何为 Swift &amp; ObjC 的代码编写符合规范的注释，以及使用 Jazzy 来生成项目文档。 今天我们来尝试一下，如"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-06-18</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>Cocoa 文档注释与生成工具使用 - Jazzy &#43; SourceKitten</h1>
  </header>
  <section class="post-content"><p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gg1evv2z3wj20ow0bin5l.jpg" alt="Cocoa Documentation By Jazzy & SourceKitten.png"></p>
<p>我们在前文 <a href="https://juejin.im/post/5ee70d7ff265da76d66c3c60">《Cocoa 代码注释与文档生成》</a> 中详细介绍了如何为 Swift &amp; ObjC 的代码编写符合规范的注释，以及使用 Jazzy 来生成项目文档。
今天我们来尝试一下，如何一键生成多个私有库的文档，并将其部署到 Github page 或者 Gitlab page 上。</p>
<h1 id="本文知识目录">本文知识目录</h1>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gg1erzhbraj21me1jaguc.jpg" alt="利用 Jazzy + SourceKitten 生成多依赖库的在线文档.png"></p>
<h1 id="背景">背景</h1>
<p>随着公司项目的迭代，一般都会沉淀出多个私有库。如果这些私有库可以够提供统一的文档查询和预览服务，那将有助于团队中的新成员快速了解业务。</p>
<p>作者所在的公司就维护者 20 多个的私有库，同时这些项目的代码注释完整度不一，注释的内容也参差不齐。如果我们可以通过这个在线文档，不仅可以提供快速的 API 查阅能力，也可以更好的监督和规范项目。</p>
<h1 id="如何一键生成多依赖库的文档">如何一键生成多依赖库的文档</h1>
<p>我们先来简单分析一下要实现这个想法 💡需要做哪些事情。</p>
<ol>
<li>现有的文档生成工具都是基于单个项目，而我们想要的是多依赖库的集合文档。那么就需要有一个索引页将各个依赖库串联起来，能够通过索引来访问它。</li>
<li>由于公司的项目是包含了 Swift &amp; ObjC 混编的庞大项目，所维护的私有仓库不仅包含了纯 ObjC 和纯 Swift 实现的，还包括了 Swift &amp; ObjC 混编代码的依赖库。所以需要支持这个三种场景。</li>
<li>生成的文档都是静态页面，需要将这些页面托管在静态资源服务上，关于这点 Github Page 和 Gitlab Page 就能解决。</li>
<li>毕竟项目是不断的迭代演进的，那如何在一定时机的情况下自动触发或者手动触发更新文档，也是十分重要的一件事情。</li>
</ol>
<p>明确了我们要解决的问题，剩下的事情就简单了。</p>
<h3 id="生成工具">生成工具</h3>
<p>就直接使用  <code>shell</code> 将上面的步骤串联起来，如果大家熟悉其他语言也可以，文档生成工具就是 <code>Jazzy</code> + <code>SourceKitten</code>。Jazzy 之前介绍过了，一起看看 SourceKitten 吧：</p>
<p><strong><a href="https://github.com/jpsim/SourceKitten">SourceKitten</a></strong></p>
<blockquote>
<p>An adorable little framework and command line tool for interacting with <a href="http://jpsim.com/uncovering-sourcekit">SourceKit</a>.</p>
</blockquote>
<p>Sourcekitten 是基于 Apple 的 SourceKit 封装的命令行工具，SourceKitten 链接并与 sourcekitd.framework 通信以解析 Swift AST，提取 Swift 或 ObjC 项目的注释文档，获取 Swift 文件的语法数据等等。</p>
<p><a href="https://github.com/apple/swift/tree/master/tools/SourceKit"><strong>SourceKit</strong></a></p>
<blockquote>
<p>SourceKit is a framework for supporting IDE features like indexing, syntax-coloring, code-completion, etc. In general it provides the infrastructure that an IDE needs for excellent language support.</p>
</blockquote>
<h1 id="文档索引页的生成">文档索引页的生成</h1>
<p>为了整体的样式统一，我们的索引页采用与 <code>Jazzy</code> 所生成的文档相同的 CSS 样式。由于 <code>Jazzy</code> 支持切换生成文档的主题，这里我们使用默认主题。</p>
<p>当我们访问静态网站时，入口一般都指向一个名为 <code>index.html</code> 的页面。 <code>Jazzy</code> 生成的入口也是 <code>index.html</code> 。</p>
<p>我们要做的就是往 <code>index.html</code> 内添加含对应的标签，并将标签链接指向各个依赖库的文档地址就可以了。</p>
<h2 id="索引页">索引页</h2>
<p>下面是我们需要修改的代码，完整的 index.html 模版可访问 <a href="https://github.com/looseyi/jazzy-template/blob/master/index/index.html">Jazzy-template</a>。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>&lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;content-wrapper&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    &lt;<span style="color:#268bd2">article</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;main-content&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    &lt;<span style="color:#268bd2">section</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        &lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section-content top-matter&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>            &lt;<span style="color:#268bd2">h3</span> id<span style="color:#719e07">=</span><span style="color:#2aa198">&#39;authors&#39;</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#39;heading&#39;</span>&gt;业务库&lt;/<span style="color:#268bd2">h3</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        &lt;/<span style="color:#268bd2">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    &lt;/<span style="color:#268bd2">section</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    &lt;<span style="color:#268bd2">section</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        &lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section-content&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        &lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;task-group&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            &lt;<span style="color:#268bd2">ul</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;item-container&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>	            &lt;<span style="color:#268bd2">li</span>&gt;token-business&lt;/<span style="color:#268bd2">li</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            &lt;/<span style="color:#268bd2">ul</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>        &lt;/<span style="color:#268bd2">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        &lt;/<span style="color:#268bd2">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    &lt;/<span style="color:#268bd2">section</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    &lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section-content top-matter&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>        &lt;<span style="color:#268bd2">h3</span> id<span style="color:#719e07">=</span><span style="color:#2aa198">&#39;authors&#39;</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#39;heading&#39;</span>&gt;基础库&lt;/<span style="color:#268bd2">h3</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    &lt;/<span style="color:#268bd2">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    &lt;<span style="color:#268bd2">section</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        &lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;section-content&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        &lt;<span style="color:#268bd2">div</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;task-group&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>            &lt;<span style="color:#268bd2">ul</span> class<span style="color:#719e07">=</span><span style="color:#2aa198">&#34;item-container&#34;</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>            &lt;<span style="color:#268bd2">li</span>&gt;token-base&lt;/<span style="color:#268bd2">li</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            &lt;/<span style="color:#268bd2">ul</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>        &lt;/<span style="color:#268bd2">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>        &lt;/<span style="color:#268bd2">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>    &lt;/<span style="color:#268bd2">section</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>    &lt;/<span style="color:#268bd2">article</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>&lt;/<span style="color:#268bd2">div</span>&gt;
</code></pre></div><p>要修改的就是上面的 <code>&lt;li&gt;token-*&lt;/lib&gt;</code> 元素，这里留的默认 token 是为了方便替换。</p>
<h3 id="业务库">业务库</h3>
<p>由于业务库逻辑一般会比较多，如果和基础库文档放一起，可能会导致生成文档的太大，Github Page 无法正常解析。因此，需要单独的文档仓库来存放文档。</p>
<h3 id="基础库">基础库</h3>
<p>基础库生成的文档会统一放到项目的 <code>docs</code> 目录下，同时  <code>&lt;li&gt;token-base&lt;/li&gt;</code> 标签的地址最后会指向 <code>docs/$lib_name/index.html</code> 目录。</p>
<p>目前的结构是这样的：</p>
<p><!-- raw HTML omitted --></p>
<h2 id="文档结构">文档结构</h2>
<p>我们先来看一下以 Alamofire 项目生成的 <code>docs</code> 文档目录结构：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gfv1lw2qhuj20gv0a1abv.jpg" alt="WechatIMG13.png"></p>
<p>第一层包含了 <code>Classes</code>、<code>Enums</code>、<code>Extensions</code>、<code>Protocols</code>、<code>Structs</code> 等分类和对应的 <code>index.html</code> 索引文件。</p>
<p>第二层为具体到的每个 Class、Enum 或其他数据结构的 HTML 页面。如果该结构还存在嵌套的内部数据类型，会以递归的方式呈现。</p>
<p>整个 <code>docs</code> 的基础结构特别简单：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gfv3161khoj209l0c1t90.jpg" alt="jazzy document.png"></p>
<p>我们要做的就是复制上面的文件，以及修改的 index.html 就可以。</p>
<h1 id="多依赖库的文档生成">多依赖库的文档生成</h1>
<p>对于 iOS 项目的依赖库管理标配为 CocoaPods (后面简称 <strong>Pod</strong>) ，它将所有的依赖库源码统一存放在项目的 <code>/Pods</code> 目录下。我们要做的就是遍历 <code>/Pods</code> 目录，逐一生成文档并将其输出到一个指定目录就可以了。</p>
<p>想法是美好的，现实是残酷的。在实际操作起来发现并没有那么简单。让我们开启踩坑之旅吧！</p>
<h2 id="swift-依赖库的文档生成">Swift 依赖库的文档生成</h2>
<p>之前在 <a href="https://juejin.im/post/5ee70d7ff265da76d66c3c60">《Cocoa 代码注释与文档生成》</a> 中介绍的 Swift 的文档生成都是基于该项目的 <code>project</code> 工程或者是 SwiftPM 配置来完成。好在 Pod 也为我们生成对应的 <code>project</code>，我们仅需通过 <code>--build-tool-arguments</code> 来指定 <code>project</code> 和 <code>target</code> 就可以了。</p>
<p>从零开始，我们先新建一个 Demo.xcodeproj 并配置如下 Podfile：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>target <span style="color:#2aa198">&#39;Demo&#39;</span> <span style="color:#719e07">do</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>	pod <span style="color:#2aa198">&#39;SnapKit&#39;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>	pod <span style="color:#2aa198">&#39;AFNetworking&#39;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">end</span>
</code></pre></div><p>调用 Jazzy 生成 Swift 库 <code>SnapKit</code> 的文档：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>$ bundle <span style="color:#b58900">exec</span> jazzy -o docs/SnapKit <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#cb4b16"></span>    --build-tool-arguments -project,Pods/Pods.xcodeproj,-target,SnapKit
</code></pre></div><p>通过 <code>-o</code> 将结果输出到 <code>docs/SnapKit</code> 目录下，执行后输出结果如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>Running xcodebuild
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>Parsing Constraint.swift <span style="color:#719e07">(</span>1/34<span style="color:#719e07">)</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>Parsing UILayoutSupport+Extensions.swift <span style="color:#719e07">(</span>34/34<span style="color:#719e07">)</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75">`</span>ConstraintLayoutSupport<span style="color:#586e75">`</span> has no USR. ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>9% documentation coverage with <span style="color:#2aa198">239</span> undocumented symbols
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>included <span style="color:#2aa198">264</span> public or open symbols
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>skipped <span style="color:#2aa198">81</span> private, fileprivate, or internal symbols <span style="color:#719e07">(</span>use <span style="color:#586e75">`</span>--min-acl<span style="color:#586e75">`</span> to specify a different minimum ACL<span style="color:#719e07">)</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>building site
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>building search index
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>jam out ♪♫ to your fresh new docs in <span style="color:#586e75">`</span>docs/SnapKit<span style="color:#586e75">`</span>
</code></pre></div><p>可以看到 Jazzy 会遍历项目下的每个 swift 文件，对于项目中未引用的代码也会有提示。最后会输出代码的注释覆盖率，SnapKit 的覆盖率为 9%，有 239 个未注释的符号或变量。</p>
<h3 id="指定文档的范围">指定文档的范围</h3>
<p>需要注意的是，Jazzy 可以通过 <code>--min-acl</code> 来控制输出文档的范围。</p>
<ul>
<li>
<p>对于 Swift 项目，默认仅生成声明为  <code>public</code> 和  <code>open</code> 的类、属性和方法等，如果想要输出私有变量的注释，还可以设置为 <code>internal</code>、 <code>fileprivate</code> 或 <code>private</code>。</p>
</li>
<li>
<p>对于 ObjC 项目，Jazzy 仅会生成在 <code>--umbrella-header</code> 所指定的 header 文件中所引用的 <code>.h</code> 文件。</p>
</li>
</ul>
<h2 id="objc-依赖库的文档生成">ObjC 依赖库的文档生成</h2>
<p>相比 Swift，Objc 的依赖库需要多处理 <code>umbrella header</code> 的问题。先看 AFNetworking 的文档生成命令：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>$ <span style="color:#268bd2">lib_name</span><span style="color:#719e07">=</span>AFNetworking
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#268bd2">lib_path</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span><span style="color:#b58900">pwd</span><span style="color:#719e07">)</span>/Pods/<span style="color:#268bd2">$lib_name</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#268bd2">umbrella_header</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$lib_path</span><span style="color:#2aa198">/</span><span style="color:#268bd2">$lib_name</span><span style="color:#2aa198">/</span><span style="color:#268bd2">$lib_name</span><span style="color:#2aa198">-umbrella.h&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#268bd2">sdk_path</span><span style="color:#719e07">=</span><span style="color:#586e75">`</span>xcrun --show-sdk-path --sdk iphonesimulator<span style="color:#586e75">`</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>bundle <span style="color:#b58900">exec</span> jazzy -o docs/<span style="color:#268bd2">$lib_name</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#cb4b16"></span>--objc <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#cb4b16"></span>--sdk iphoneos <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#cb4b16"></span>--build-tool-arguments <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#cb4b16"></span>--objc,<span style="color:#268bd2">$umbrella_header</span>,--,-x,objective-c,-isysroot,<span style="color:#268bd2">$sdk_path</span>,-I,<span style="color:#268bd2">$lib_path</span>
</code></pre></div><p>第一个是需要指定 <code>--objc</code>，因为 Jazzy 默认解析 Swift 项目。</p>
<p>再来看 <code>    --build-tool-arguments</code> 后跟的几个参数：</p>
<ul>
<li>&ndash;objc &lt;umbrella-header PATH&gt;：这里的 <code>--objc</code> 是通知 SourceKitten 我要解析的是 Objc 的头文件，后面紧跟的为依赖库的 umbrella header</li>
<li>&ndash;：作为分割符，表示之后的参数会转发到  <code>xcodebuild</code> 或  <code>swift build</code></li>
<li>-x objective：通知  <code>xcodebuild</code> 或  <code>swift build</code> 我要编译 ObjC 啦</li>
<li>-isysroot：指定所编译的 sdk，这里我们使用模拟器的 sdk</li>
<li>-I $lib_path：指定 include 的搜索路径</li>
</ul>
<h3 id="获取-umbrella-header">获取 umbrella header</h3>
<p>在 ObjC 中引用代码是需要通过 <code>#import</code> 来完成的，而对于 ObjC 的 framework 而言，我们可以通过引入 <code>umbrella header</code> 来引入该 framework 暴露出来的全部 public header 文件。因此，可以理解为 <code>umbrella header</code> 是 ObjC framework 的 <strong>master</strong> header。具体可以看：<a href="https://stackoverflow.com/questions/31238761/what-is-an-umbrella-header/31238936#:~:text=umbrella%20header%20%2D%20iOS%20framework%20or,same%20name%20as%20Product%20Name">讨论</a>。</p>
<p>这一点需要感谢 Pod，它为我们的依赖库统一生成了 <code>A-umberlla.h</code> 文件，存放在 <code>Target Support Files/A/A-umberlla.h</code> 。</p>
<p>在此之前很多依赖库的 <code>umbrella header</code> 并不是很规范。经常会有一些文件是 public 状态，却未添加到 <code>umbrella header</code> 中，导致无法直接通过 <code>umbrella header</code> 来完成引用。包括很多公司维护的私有库也会经常忘记更新 <code>umbrella header</code> 的情况，好在 Pod 帮我们自动生成了。</p>
<h3 id="复制-umbrella-header">复制 umbrella header</h3>
<p>细心的同学从 AFNetworking 的文档生成命令中能发现，<code>AFNetworking-umbrella.h</code> 的位置是在源码的文件夹下。如果直接指定为 <code>Target Support Files</code> 下的 umbrella header 文件是无法生成文档的。我们需要把它复制到源代码在同层目录下。</p>
<p>那么问题来了：<strong>如何正确的获取源码所在目录</strong>。</p>
<p>首先想到的是和通过 <code>.podspec</code> 文件就能准确拿到 Source 目录。不过比较难实现，我们只能拿到的是 <code>Local Podspecs</code> 下的 <code>.podspec</code> 文件，否则需要在 <code>pod install</code> 时才能获取到。但是这么做需要修改 Podfile 也比较麻烦。</p>
<p>选择简单粗暴的方式，直接列出可能出现的 Source 路径：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75"># /A/Classes/...</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"># /A/src/a/...</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"># /A/A/Classe/... </span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"># /A/A/Classes/... </span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"># /A/A/Source/..</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"># /A/A/Sources/..</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"># /A/Source/A/...</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"># /A/Sources/A/... </span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"># /A/Source/...</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"># /A/A/..</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"># /A/...</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75"># libextobjc/extobjc</span>
</code></pre></div><p>有用 <code>Classes</code>、 <code>Source</code>、<code>Sources</code>、<code>src</code> 等等，情况五花八门，逐一匹配就可以了。</p>
<p>这么做是可以覆盖大部分的情况，但是仍然发现部分私有库生成的文档缺失甚至是空的。最终发现的问题是：<strong>clang 没有递归处理多级目录的文件</strong>，这里应该是参数没有正确设置，查看了 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">Clang 手册</a> 感觉就是 <code>-I</code> 参数，不过也没有生效，有了解的同学求指点。</p>
<p>咋办，先暴力解决：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>find <span style="color:#268bd2">$lib_path</span> -type f ! -regex <span style="color:#2aa198">&#39;*.\(h\|m\|swift\)&#39;</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#cb4b16"></span>    ! -name <span style="color:#2aa198">&#39;*.json&#39;</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#cb4b16"></span>    ! -name <span style="color:#2aa198">&#39;*.pdf&#39;</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#cb4b16"></span>    -exec mv -i <span style="color:#719e07">{}</span> <span style="color:#268bd2">$lib_path</span> <span style="color:#cb4b16">\;</span>
</code></pre></div><p>将子目录下文件全部移到 framework 源码目录下，再通过 Jazzy 来生成文档，算是暂时解决问题了。</p>
<p>然而 AFNetworking 的文档依旧不是完整的，不过属于另外一种情况。目录如下，大家可以 🤔 一下：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gfyzo504r8j212s0h0gql.jpg" alt="WechatIMG12.png"></p>
<h2 id="swift--objc-混编依赖库的文档生成">Swift &amp; ObjC 混编依赖库的文档生成</h2>
<p>对 Swift &amp; ObjC 混编的依赖库本身是不提倡的，虽然在实际开发过程中无法避免。</p>
<p>为了测试混编库的文档生成，这里新建一个 Pod 库：<a href="https://github.com/looseyi/Mixin">Mixin</a>，添加了 MixinSwift 和 MixinObjC 两个类：</p>
<h3 id="mixinswift">MixinSwift</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">/// Test Swfit Class import Objective-C&#39;s property</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">MixinSwift</span>: NSObject {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#586e75">/// say hello from Swift</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#268bd2">@objc</span> <span style="color:#268bd2">public</span> <span style="color:#268bd2">static</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">sayHi</span>: <span style="color:#b58900">String</span> = <span style="color:#2aa198">&#34;Hi, I&#39;m from Swift&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#586e75">/// call Objective-C say Hi</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#268bd2">@objc</span> <span style="color:#268bd2">public</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">func</span> callObjC() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#268bd2">print</span>(<span style="color:#2aa198">&#34;hello from MixinObjc: </span><span style="color:#2aa198">\(</span>MixinObjC.sayHi<span style="color:#2aa198">)</span><span style="color:#2aa198">&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>}
</code></pre></div><h3 id="mixinobjc">MixinObjC</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">#import &#34;MixinObjC.h&#34;
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">#import &lt;Mixin/Mixin-Swift.h&gt;
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@implementation</span> <span style="color:#268bd2">MixinObjC</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span> <span style="color:#719e07">+</span> (NSString <span style="color:#719e07">*</span>)sayHi
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">return</span> <span style="color:#2aa198">@&#34;Hi, I&#39;m from Objective-C&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07">+</span> (<span style="color:#dc322f">void</span>)callSwift
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    NSLog(<span style="color:#2aa198">@&#34;hello from MixinSwift: %@&#34;</span>, MixinSwift.sayHi);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#719e07">@end</span>
</code></pre></div><p>由于 Jazzy 无法直接生成混编项目的文档，这里需要通过 <code>SourceKitten</code> 分别将 Swift 和 ObjC 的代码注释转成 json 的中间格式，才能生存完整的文档。生成命令如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">lib_name</span><span style="color:#719e07">=</span>Mixin
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#268bd2">output</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;public/docs/</span><span style="color:#268bd2">$lib_name</span><span style="color:#2aa198">&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#268bd2">swift_doc</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$output</span><span style="color:#2aa198">/</span><span style="color:#268bd2">$lib_name</span><span style="color:#2aa198">-swift-doc.json&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#268bd2">objc_doc</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$output</span><span style="color:#2aa198">/</span><span style="color:#268bd2">$lib_name</span><span style="color:#2aa198">-objc-doc.json&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#268bd2">lib_path</span><span style="color:#719e07">=</span><span style="color:#719e07">$(</span><span style="color:#b58900">pwd</span><span style="color:#719e07">)</span>/Pods/<span style="color:#268bd2">$lib_name</span>/<span style="color:#268bd2">$lib_name</span>/Classes
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#268bd2">umbrella_header</span><span style="color:#719e07">=</span><span style="color:#2aa198">&#34;</span><span style="color:#268bd2">$lib_path</span><span style="color:#2aa198">/</span><span style="color:#268bd2">$lib_name</span><span style="color:#2aa198">-umbrella.h&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#268bd2">sdk_path</span><span style="color:#719e07">=</span><span style="color:#586e75">`</span>xcrun --show-sdk-path --sdk iphonesimulator<span style="color:#586e75">`</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>sourcekitten doc --objc <span style="color:#268bd2">$umbrella_header</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#cb4b16"></span>      -- -x objective-c -isysroot <span style="color:#268bd2">$sdk_path</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#cb4b16"></span>      -I <span style="color:#268bd2">$lib_path</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#cb4b16"></span>      -fmodules &gt; <span style="color:#268bd2">$objc_doc</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>sourcekitten doc -- -project Pods/Pods.xcodeproj -target Mixin &gt; <span style="color:#268bd2">$swift_doc</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>jazzy -o <span style="color:#268bd2">$output</span> --sourcekitten-sourcefile <span style="color:#268bd2">$swift_doc</span>,<span style="color:#268bd2">$objc_doc</span> 
</code></pre></div><p>文档如下：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gfzy7mk9nrj20km0a1js4.jpg" alt="WechatIMG13.png"></p>
<h2 id="依赖库类型判断">依赖库类型判断</h2>
<p>由于不同类型的依赖库，其生成文档的脚本有所不同，我们还需要判断每个依赖库类型，是纯 ObjC、纯 Swift 还是混编类型。解决方式就是对 Source 目录下的文件类型进行 count 以判断依赖库类型：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">swift_count</span><span style="color:#719e07">=</span><span style="color:#586e75">`</span>find <span style="color:#268bd2">$lib_path</span> -maxdepth <span style="color:#2aa198">6</span> -type f  -name <span style="color:#2aa198">&#39;*.swift&#39;</span> | wc -l<span style="color:#586e75">`</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#268bd2">objc_count</span><span style="color:#719e07">=</span><span style="color:#586e75">`</span>find <span style="color:#268bd2">$lib_path</span> -maxdepth <span style="color:#2aa198">6</span> -type f  -name <span style="color:#2aa198">&#39;*.m&#39;</span> | wc -l<span style="color:#586e75">`</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"># file state, 0: only objc, 1: only swift, 2: swift &amp; objc</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#268bd2">lib_state</span><span style="color:#719e07">=</span><span style="color:#2aa198">0</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">if</span> <span style="color:#719e07">[[</span> <span style="color:#268bd2">$swift_count</span> -ge <span style="color:#2aa198">1</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#268bd2">$objc_count</span> -ge <span style="color:#2aa198">1</span> <span style="color:#719e07">]]</span>; <span style="color:#719e07">then</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#268bd2">lib_state</span><span style="color:#719e07">=</span><span style="color:#2aa198">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">elif</span> <span style="color:#719e07">[[</span> <span style="color:#268bd2">$swift_count</span> -eq <span style="color:#2aa198">0</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#268bd2">$objc_count</span> -ge <span style="color:#2aa198">1</span> <span style="color:#719e07">]]</span>; <span style="color:#719e07">then</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#268bd2">lib_state</span><span style="color:#719e07">=</span><span style="color:#2aa198">0</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">elif</span> <span style="color:#719e07">[[</span> <span style="color:#268bd2">$swift_count</span> -ge <span style="color:#2aa198">1</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#268bd2">$objc_count</span> -eq <span style="color:#2aa198">0</span> <span style="color:#719e07">]]</span>; <span style="color:#719e07">then</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#268bd2">lib_state</span><span style="color:#719e07">=</span><span style="color:#2aa198">1</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">fi</span>
</code></pre></div><h1 id="静态文档的部署">静态文档的部署</h1>
<p>我们使用是 Github Page 来进行文档部署，特别简单仅需在 repo 的设置页指定文档类型就可以了。剩下的就是提交代码，Git 会自动触发编译。</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gg09xcwxccj20jd0cawfr.jpg" alt="WechatIMG14.png"></p>
<p>更多介绍请查看 <a href="https://help.github.com/en/github/working-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site">Github Page 说明</a>。</p>
<p>最后，完整 Demo 的托管地址为：<a href="https://github.com/looseyi/Cocoa-Documentation-Example">Cocoa-Documentation-Example</a>。</p>
<p>Git page 文档地址：https://looseyi.github.io/Cocoa-Documentation-Example，这个地址是 Github 自动生成的。效果如下：</p>
<p><img src="https://gitee.com/looseyi/blog-image/raw/master/uPic/8157560cly1gg1e0gy1slj20ib0dg3z1.jpg" alt="WechatIMG15.png"></p>
<h1 id="one-more-thing-">One More Thing &hellip;</h1>
<p>尽管我们当前的方案可以正确的生成文档，但是其实还可以更进一步。</p>
<p>当前的文档生成是基于 <code>project</code> 的方式，而我们完全可以针对每一个文件生成一份 json 数据，最后在把它们全部粘一起。命令的话 SourceKitten 都准备好了：</p>
<p><strong>Swift 文件解析</strong></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>$ sourcekitten doc --single-file <span style="color:#268bd2">$input_file</span> -- -j4 <span style="color:#268bd2">$input_file</span> &gt;&gt; <span style="color:#268bd2">$temp_outout</span>
</code></pre></div><p><strong>ObjC .h 文件解析</strong></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>$ sourcekitten doc --objc <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#cb4b16"></span>   --single-file <span style="color:#268bd2">$input_file</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#cb4b16"></span>   -- -x objective-c <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#cb4b16"></span>   -isysroot <span style="color:#268bd2">$sdk_path</span> <span style="color:#cb4b16">\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#cb4b16"></span>   -I <span style="color:#268bd2">$lib_path</span> -fmodules &gt;&gt; <span style="color:#268bd2">$temp_outout</span>
</code></pre></div><p>通过这种方式，既不不需要配置 <code>project</code> 判断依赖库类型，也省去了查找找 umbrella header 的麻烦。</p>
<p>完整脚本传送门：<a href="https://github.com/looseyi/ScriptTools/blob/master/doc_deploy.sh">docs_deploy.sh</a></p>
<h1 id="总结">总结</h1>
<ul>
<li>多依赖库的文档生成还是比较简单的，感觉最难的还是读懂 Jazzy + SourceKitten 的文档和参数的配置。</li>
<li>思路是充分利用了 CocoaPods 为我们搭好的环境，在其之上就可以轻松生成文档，主题可定制哦。</li>
<li>倒腾过个人博客的同学，对于 Github Page 和文档的部署应该很熟悉，免费的 Github 资源还是要充分利用的。</li>
</ul>
<h1 id="知识点问题梳理">知识点问题梳理</h1>
<p>这里罗列了四个问题用来考察你是否已经掌握了这篇文章，如果没有建议你加入<strong>收藏</strong>再次阅读：</p>
<ol>
<li><code>Jazzy</code> 对 API 的控制范围有几种选择？</li>
<li>对于文中所采用的判断依赖库语言类型的方法是什么，还有更好的方式吗？</li>
<li>ObjC 的 <code>umbrella header</code> 是从哪里获取的？</li>
<li>扩展： <code>SourceKitten</code> 所生成的 JSON 结构包括哪些字段？</li>
</ol>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/ios">iOS&#39;</a>
     
    <a href="https://looseyi.github.io/tags/document">Document</a>
     
    <a href="https://looseyi.github.io/tags/sourcekit">SourceKit</a>
     
    <a href="https://looseyi.github.io/tags/jazzy">Jazzy</a>
     
    <a href="https://looseyi.github.io/tags/gitpage">gitpage</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/wwdc/wwdc20/wwdc20-session-10041/"><span>←</span><span>WWDC20 - What&#39;s new in SwiftUI</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/notes/01-gcd/"><span>📒个人备忘 - 队列、GCD、线程基础</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
