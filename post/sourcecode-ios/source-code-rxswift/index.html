<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>浅析 RxSwift 5.0 - Subscription - Aha Edmond</title>

  
  
  <meta name="description" content="前言 ReactiveX 它是一个与语言无关的编程思想。作为成员框架之一 RxSwift 落地了大部分 ReactiveX 中关于流的操作。官方描述： An API for asynchronous programming with observable streams ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern," />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/sourcecode-ios/source-code-rxswift/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="浅析 RxSwift 5.0 - Subscription" />
<meta property="og:description" content="前言 ReactiveX 它是一个与语言无关的编程思想。作为成员框架之一 RxSwift 落地了大部分 ReactiveX 中关于流的操作。官方描述： An API for asynchronous programming with observable streams ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/sourcecode-ios/source-code-rxswift/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-16T23:10:58&#43;08:00" />
<meta property="article:modified_time" content="2020-03-16T23:10:58&#43;08:00" />


  
  <meta itemprop="name" content="浅析 RxSwift 5.0 - Subscription">
<meta itemprop="description" content="前言 ReactiveX 它是一个与语言无关的编程思想。作为成员框架之一 RxSwift 落地了大部分 ReactiveX 中关于流的操作。官方描述： An API for asynchronous programming with observable streams ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern,"><meta itemprop="datePublished" content="2020-03-16T23:10:58&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-16T23:10:58&#43;08:00" />
<meta itemprop="wordCount" content="4320">
<meta itemprop="keywords" content="Source Code,iOS,Reactive," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅析 RxSwift 5.0 - Subscription"/>
<meta name="twitter:description" content="前言 ReactiveX 它是一个与语言无关的编程思想。作为成员框架之一 RxSwift 落地了大部分 ReactiveX 中关于流的操作。官方描述： An API for asynchronous programming with observable streams ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern,"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-03-16</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>浅析 RxSwift 5.0 - Subscription</h1>
  </header>
  <section class="post-content"><h3 id="前言">前言</h3>
<p>ReactiveX 它是一个与语言无关的编程思想。作为成员框架之一 RxSwift 落地了大部分 ReactiveX 中关于流的操作。官方描述：</p>
<blockquote>
<p>An API for asynchronous programming with observable streams</p>
<p>ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming</p>
</blockquote>
<p>本篇主要介绍 RxSwift 的内部流是如何产生和订阅，这里默认大家是有 RxSwift 使用经验的。关于响应式编程在移动端已经是一个相对成熟的概念了，有很多好文章，比如 <a href="https://halfrost.com/tag/rac/">FRP</a> 系列。如果你在项目中犹豫使用哪个框架可以看看这两篇文章的分析：</p>
<ul>
<li><a href="https://dreampiggy.com/2016/11/17/FRP%E7%AE%80%E4%BB%8B%E2%80%94ReactiveCocoa%E3%80%81RxSwift%E3%80%81Bacon%E4%BB%A5%E5%8F%8A%E8%83%8C%E5%90%8E%E7%9A%84Functional/">FRP对比—ReactiveCocoa、RxSwift、Bacon以及背后的Functional</a></li>
<li><a href="https://www.jianshu.com/p/2f83b766a081">iOS响应式编程：ReactiveCocoa vs RxSwift 选谁好</a></li>
</ul>
<h2 id="observable">Observable</h2>
<p>Rx 中的 Observable Stream(观察流)，为了方便这里简称为 <strong>流</strong>。流中的元数据可以有多个或者单个，这里统称为节点。既然一切皆流，那就从流的创建讲起，上代码：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>Observable.of(<span style="color:#2aa198">1</span>, <span style="color:#2aa198">2</span>, <span style="color:#2aa198">3</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    .subscribe( { <span style="color:#268bd2">print</span>(<span style="color:#268bd2">$0</span>) })
</code></pre></div><p>我们看第一行，它把 <strong>Swift.Sequence&lt;Int&gt;</strong> 序列 <em>[1, 2, 3]</em> 转换为流，<a href="https://github.com/ReactiveX/RxSwift/blob/c6c0c540109678b96639c25e9c0ebe4a6d7a69a9/RxSwift/Observables/Sequence.swift">of(_:)</a> 方法的声明如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">ObservableType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">static</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">of</span>(<span style="color:#cb4b16">_</span> elements: Element ..., scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -&gt; Observable&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>        <span style="color:#719e07">return</span> ObservableSequence(elements: elements, scheduler: scheduler)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
</code></pre></div><p>利用 Swift 的 <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#">Protcol Extesion</a> 来为 ObservableType 添加默认了实现，它把 Sequence&lt;Int&gt; 存入了 ObservableSequence 中并返回。</p>
<p>大概了解一下 ObservableSequence 的类关系：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">|</span> <span style="color:#719e07">---</span> ObservableSequence
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> Producer 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> Observable (<span style="color:#268bd2">class</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>            <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> ObservableType (<span style="color:#268bd2">Protocol</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>                <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> ObservableConvertibleType (<span style="color:#268bd2">Protocol</span>)
</code></pre></div><p>根协议 ObservableConvertibleType 利用关联类型声明了返回值为关联类型的泛型方法 <code>asObservable</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">ObservableConvertibleType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#586e75">/// Type of elements in sequence.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    associatedtype Element
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">asObservable</span>() -&gt; Observable&lt;Element&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>}
</code></pre></div><p>协议 ObservableType 则声明了 <code>subscribe(_:)</code> 方法：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">ObservableType</span>: ObservableConvertibleType {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">subscribe</span>&lt;Observer: ObserverType&gt;(<span style="color:#cb4b16">_</span> observer: Observer) -&gt; Disposable <span style="color:#719e07">where</span> Observer.Element == Element
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">ObservableType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#586e75">/// Default implementation of converting `ObservableType` to `Observable`.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">asObservable</span>() -&gt; Observable&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#586e75">// temporary workaround</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        <span style="color:#586e75">//return Observable.create(subscribe: self.subscribe)</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        <span style="color:#719e07">return</span> Observable.create { o <span style="color:#719e07">in</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            <span style="color:#719e07">return</span> <span style="color:#cb4b16">self</span>.subscribe(o)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>}
</code></pre></div><p>并利用 <code>subscribe(_:)</code> 方法完成了对 <code>asObservable()</code> 默认实现的扩展。</p>
<p>关于注释  temporary workaround，翻了一下 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType.swift">git history</a> 在 Swift 3.0 添加的。这种写法在 Swift 5.0 上是可以 work 的，不知为何注释了。那为什么可以这么写呢 ？稍微扯一下，可以看 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Create.swift">creat(_:)</a> 的声明：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">ObservableType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">static</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">create</span>(<span style="color:#cb4b16">_</span> subscribe: @escaping (AnyObserver&lt;Element&gt;) -&gt; Disposable) -&gt; Observable&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>        <span style="color:#719e07">return</span> AnonymousObservable(subscribe)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
</code></pre></div><p>其参数 subscribe 是一个 closure，而 closure 本质就是匿名函数。在 Swift 中函数作为一等公民，是可以直接作为参数传递的。因此，上面可以省略 closure 直接写成：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>Observable.create(<span style="color:#cb4b16">self</span>.subscribe)
</code></pre></div><p>再来 Observable ：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">Observable</span>&lt;Element&gt; : ObservableType {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">subscribe</span>&lt;Observer: ObserverType&gt;(<span style="color:#cb4b16">_</span> observer: Observer) -&gt; Disposable <span style="color:#719e07">where</span> Observer.Element == Element {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        rxAbstractMethod()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">asObservable</span>() -&gt; Observable&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#719e07">return</span> <span style="color:#cb4b16">self</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
</code></pre></div><p>它仅做了两件事：</p>
<ol>
<li>将 <code>subscribe(_:)</code> 方法标记为抽象方法，并通过 <a href="https://swifter.tips/fatalerror/">fatalError</a> 来强制要求子类去实现；</li>
<li>在 <code>asObservable() </code> 中将 self 直接 return。</li>
</ol>
<p>上面代码中没有列出 <code>init()</code> 和 <code>deinit()</code> 的实现，RxSwift 在这两方法中引入了内部的资源统计，用于 debug，实现如下，感兴趣的可以深究:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">init</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">#if</span> <span style="color:#719e07">TRACE_RESOURCES</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#cb4b16">_</span> = Resources.incrementTotal()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">#endif</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#268bd2">deinit</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">#if</span> <span style="color:#719e07">TRACE_RESOURCES</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#cb4b16">_</span> = Resources.decrementTotal()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">#endif</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
</code></pre></div><p>序列存储已经结束，流的创建才刚刚开始。先贴一张脑图补一补，其实每个流的变换操作背后都对应一个 ObservableType 的扩展。</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cly1gcvl07flwjj224o1smqh7.jpg" alt="rxswift"></p>
<h1 id="producerhttpsgithubcomreactivexrxswiftblobc6c0c540109678b96639c25e9c0ebe4a6d7a69a9rxswiftobservablesproducerswift"><a href="https://github.com/ReactiveX/RxSwift/blob/c6c0c540109678b96639c25e9c0ebe4a6d7a69a9/RxSwift/Observables/Producer.swift">Producer</a></h1>
<p>再来看本文的重点之一 Producer：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">class</span> <span style="color:#268bd2">Producer</span>&lt;Element&gt; : Observable&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#268bd2">override</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">subscribe</span>&lt;Observer: ObserverType&gt;(<span style="color:#cb4b16">_</span> observer: Observer) -&gt; Disposable <span style="color:#719e07">where</span> Observer.Element == Element {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#586e75">/// Scheduler {</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#268bd2">let</span> <span style="color:#268bd2">disposer</span> = SinkDisposer()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#268bd2">let</span> <span style="color:#268bd2">sinkAndSubscription</span> = <span style="color:#cb4b16">self</span>.run(observer, cancel: disposer)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#586e75">/// }</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">run</span>&lt;Observer: ObserverType&gt;(<span style="color:#cb4b16">_</span> observer: Observer, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) <span style="color:#719e07">where</span> Observer.Element == Element {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        rxAbstractMethod()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>}
</code></pre></div><blockquote>
<p>注释的 Scheduler 是 RxSwift 中相关的线程调度，它会根据标识选择相应线程去处理任务，我们先忽略。</p>
</blockquote>
<p>看字面意思也能猜出它的作用吧。同样为抽象类，它的角色更像是一个管理者。它管理着 Observable 的创建、订阅、回收。每个 Producer 实例则对应一条流水线，而 RxSwift 则可以看作大型工厂，通过 Producer 持续的生产和消费 Observable。</p>
<p>###run(_:cancel:)</p>
<p>它对应流的创建，也包括对每个节点发送 Event 事件。作为抽象方法，子类通过重载来提供流的多元化创建。同时 run 方法所返回的 sink 则保存了各个节点的元数据，subscription 则保存了流的订阅操作。详细会在 Sink 类作展开。</p>
<p>###subscribe(_:)</p>
<p>它通过 sinkDisposer 来统一回收流所引用的元数据以及订阅相关的资源。</p>
<ol>
<li>判断是否需要用 <code>scheduler</code> 切换到指定的线程，来进行订阅逻辑的处理；</li>
<li>创建 sinkDisposer，同 obserer 一起作为 <code>run(_:cancel:)</code> 的入参；</li>
<li>将执行 <code>run(_:cancel:)</code> 方法后的结果保存到 sinkDisposer 中，为之后的资源销毁做准备；</li>
<li>最后返回 sinkDisposer；</li>
</ol>
<p>那就先就近先看 SinkDisposer 类。</p>
<h3 id="sinkdisposer">SinkDisposer</h3>
<blockquote>
<p>The returned disposable needs to release all references once it was disposed.</p>
</blockquote>
<p>SinkDisposer 用于保证所有引用资源的最终释放。其声明如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">private</span> <span style="color:#268bd2">final</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">SinkDisposer</span>: Cancelable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">enum</span> <span style="color:#268bd2">DisposeState</span>: <span style="color:#b58900">Int32</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">case</span> disposed = <span style="color:#2aa198">1</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">case</span> sinkAndSubscriptionSet = <span style="color:#2aa198">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">_state</span> = AtomicInt(<span style="color:#2aa198">0</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">var</span> <span style="color:#268bd2">_sink</span>: Disposable?
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">var</span> <span style="color:#268bd2">_subscription</span>: Disposable?
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">isDisposed</span>: <span style="color:#b58900">Bool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        <span style="color:#719e07">return</span> isFlagSet(<span style="color:#cb4b16">self</span>._state, DisposeState.disposed.rawValue)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">setSinkAndSubscription</span>(sink: Disposable, subscription: Disposable) { ... }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">dispose</span>() { ... }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>}
</code></pre></div><p>先分析它的继承关系：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">|</span> <span style="color:#719e07">---</span> SinkDisposer
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> Cancelable
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> Disposable
</code></pre></div><p>Disposable 则是用于释放资源:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">Disposable</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#586e75">/// Dispose resource.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">dispose</span>()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
</code></pre></div><p>Cancelable，用于标识资源是否被释放：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">Cancelable</span> : Disposable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#586e75">/// Was resource disposed.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#268bd2">var</span> <span style="color:#268bd2">isDisposed</span>: <span style="color:#b58900">Bool</span> { <span style="color:#268bd2">get</span> }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
</code></pre></div><p>那 sinkDisposer 对保存结果做了什么处理，又是如何来释放资源的呢？主要靠下面这个方法。</p>
<p>####setSinkAndSubscription</p>
<p>实现如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#cb4b16">self</span>._sink = sink
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#cb4b16">self</span>._subscription = subscription
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#268bd2">let</span> <span style="color:#268bd2">previousState</span> = fetchOr(<span style="color:#cb4b16">self</span>._state, DisposeState.sinkAndSubscriptionSet.rawValue)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">if</span> (previousState <span style="color:#719e07">&amp;</span> DisposeState.sinkAndSubscriptionSet.rawValue) <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    rxFatalError(<span style="color:#2aa198">&#34;Sink and subscription were already set&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">if</span> (previousState <span style="color:#719e07">&amp;</span> DisposeState.disposed.rawValue) <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    sink.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    subscription.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#cb4b16">self</span>._sink = <span style="color:#cb4b16">nil</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#cb4b16">self</span>._subscription = <span style="color:#cb4b16">nil</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
</code></pre></div><ol>
<li>保存 sink 和 subscription （均为 Disposable）</li>
<li>获取 previousState （当前资源的状态是否被标示为已清理或已设置) ；</li>
<li>如果 previousState 为 .sinkAndSubscriptionSet，则已设置过资源，直接抛错来防止重复调用；</li>
<li>如果 previousState 为 .disposed，则资源已不可用，会对 sink 和 subscription 执行 <code>dispose()</code> 以释放资源，同时将它们置 nil。</li>
</ol>
<p>这里，可能有小伙伴有疑问，一个 state 如何保存两个状态？来瞅一眼 <a href="https://github.com/ReactiveX/RxSwift/blob/master/Platform/AtomicInt.swift">AtomicInt</a> 简化后的部分实现：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">final</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">AtomicInt</span>: NSLock {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    fileprivate <span style="color:#268bd2">var</span> <span style="color:#268bd2">value</span>: <span style="color:#b58900">Int32</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">init</span>(<span style="color:#cb4b16">_</span> value: <span style="color:#b58900">Int32</span> = <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#cb4b16">self</span>.value = value
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#268bd2">func</span> <span style="color:#268bd2">fetchOr</span>(<span style="color:#cb4b16">_</span> this: AtomicInt, <span style="color:#cb4b16">_</span> mask: <span style="color:#b58900">Int32</span>) -&gt; <span style="color:#b58900">Int32</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    this.lock()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#268bd2">let</span> <span style="color:#268bd2">oldValue</span> = this.value
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    this.value <span style="color:#719e07">|=</span> mask
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    this.unlock()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#719e07">return</span> oldValue
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#268bd2">func</span> <span style="color:#268bd2">increment</span>(<span style="color:#cb4b16">_</span> this: AtomicInt) -&gt; <span style="color:#b58900">Int32</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#719e07">return</span> add(this, <span style="color:#2aa198">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#268bd2">func</span> <span style="color:#268bd2">decrement</span>(<span style="color:#cb4b16">_</span> this: AtomicInt) -&gt; <span style="color:#b58900">Int32</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    <span style="color:#719e07">return</span> sub(this, <span style="color:#2aa198">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>...
</code></pre></div><blockquote>
<p>说明：Atomic 中有返回值都的方法都有 <strong>@discardableResult</strong> 标记，只是这边简化了，同时所有方法都是
<strong>@inline(__always)</strong> 标记的。</p>
</blockquote>
<p>之前版本的 AtomicInt 是用 <a href="https://opensource.apple.com/source/xnu/xnu-201.5/libkern/libkern/OSAtomic.h.auto.html">OSAtomic.h</a> 的 API 来实现的，现在改成用 NSLock 了。</p>
<p>这里看到 <em>位运算符</em> 大家应该知道它是怎么实现了吧。它通过每个 bit 来保存一个 flag 从而提高了访问效率。</p>
<p>接着我们看 <code>fetchOr(_:_:)</code> 它其实做了两件事情。</p>
<ol>
<li>先取出当前 value 做为返回值；</li>
<li>将 mask 值保存到 value 中；</li>
</ol>
<p>by the way，前面提到过 RxSwift 内部的资源统计方法 <code>Resources.incrementTotal()</code>  就是用 <code>increment(_:)</code> 实现的。 <code>Resources.decrementTotal()</code> 同理。</p>
<h4 id="dispose">dispose</h4>
<p>理解了 setSinkAndSubscription 后 dispose 就不难了，实现如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">let</span> <span style="color:#268bd2">previousState</span> = fetchOr(<span style="color:#cb4b16">self</span>._state, DisposeState.disposed.rawValue)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">if</span> (previousState <span style="color:#719e07">&amp;</span> DisposeState.disposed.rawValue) <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">return</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">if</span> (previousState <span style="color:#719e07">&amp;</span> DisposeState.sinkAndSubscriptionSet.rawValue) <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">guard</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">sink</span> = <span style="color:#cb4b16">self</span>._sink <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        rxFatalError(<span style="color:#2aa198">&#34;Sink not set&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#719e07">guard</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">subscription</span> = <span style="color:#cb4b16">self</span>._subscription <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        rxFatalError(<span style="color:#2aa198">&#34;Subscription not set&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    sink.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>    subscription.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    <span style="color:#cb4b16">self</span>._sink = <span style="color:#cb4b16">nil</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#cb4b16">self</span>._subscription = <span style="color:#cb4b16">nil</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>}
</code></pre></div><ol>
<li>先取出 previousState 并将 .disposed 值写入 _state;</li>
<li>判断 previousState 为 disposed：
<ol>
<li>如果是则表明已经清理过，直接 return；</li>
<li>否则对 sink 和 subscription 执行 <code>dispose()</code> 以释放资源，同时将它们置 nil。</li>
</ol>
</li>
</ol>
<p>RxSwift 通过 AutomicInt 的位运算，巧妙的用一个变量高效完成了多个状态的存储，最重要的是它保证了只有一次有效的 <code>dispose</code> 操作。还有很重要的一点，在释放资源后，sinkDisposer 都会主动将 sink 和 subscription 置 nil，这是为了解决<strong>循环引用</strong>。因为在 Sink 内部其实也引用了 sinkDisposer。</p>
<h2 id="sink">Sink</h2>
<p>项目中的 issue 有一个简单描述 <a href="https://github.com/ReactiveX/RxSwift/issues/817">What is a Sink ?</a></p>
<blockquote>
<p>It&rsquo;s an internal class used to implement the operators, that receives events and processes them.</p>
</blockquote>
<p>Sink，接受 Event 事件并进行相应处理或者将其转发，是实现各种运算符的内部类，比如 Map、Reduce、Filter 运算符等。作为 Producer 背后的苦力一直默默付出。</p>
<p>Sink 从哪里来的呢？继续以开头的 <code>Observable.of(1, 2, 3)</code> 为例，看 ObservableSequence 的 run 方法实现：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#268bd2">final</span> <span style="color:#268bd2">private</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">ObservableSequence</span>&lt;Sequence: Swift.Sequence&gt;: Producer&lt;Sequence.Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#586e75">/// init ...</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    <span style="color:#268bd2">override</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">run</span>&lt;Observer: ObserverType&gt;(<span style="color:#cb4b16">_</span> observer: Observer, cancel: Cancelable) -&gt; (sink: Disposable, subscription: Disposable) <span style="color:#719e07">where</span> Observer.Element == Element {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>        <span style="color:#268bd2">let</span> <span style="color:#268bd2">sink</span> = ObservableSequenceSink(parent: <span style="color:#cb4b16">self</span>, observer: observer, cancel: cancel)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        <span style="color:#268bd2">let</span> <span style="color:#268bd2">subscription</span> = sink.run()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>        <span style="color:#719e07">return</span> (sink: sink, subscription: subscription)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span>}
</code></pre></div><p>在其初始化时将关键数据都保存起来：</p>
<ul>
<li>self 为 Swift.Sequence&lt;Int&gt;</li>
<li>observer</li>
<li>cancel 为 SinkDisposer</li>
</ul>
<p>Sink 创建完后会将执行 <code>run()</code> 的结果作为 subscription，同 sink 一起返回后存入 sinkDisposer 中。这也是前面提到的有循环引用的情况，不过在 sinkDispoer 的 dispose 过程中做了 break。</p>
<p>Sink 声明如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">class</span> <span style="color:#268bd2">Sink</span>&lt;Observer: ObserverType&gt; : Disposable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    fileprivate <span style="color:#268bd2">let</span> <span style="color:#268bd2">_observer</span>: Observer
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    fileprivate <span style="color:#268bd2">let</span> <span style="color:#268bd2">_cancel</span>: Cancelable <span style="color:#586e75">// sinkDisposer</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">_disposed</span> = AtomicInt(<span style="color:#2aa198">0</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#268bd2">final</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">forwardOn</span>(<span style="color:#cb4b16">_</span> event: Event&lt;Observer.Element&gt;) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">if</span> isFlagSet(<span style="color:#cb4b16">self</span>._disposed, <span style="color:#2aa198">1</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#719e07">return</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        <span style="color:#cb4b16">self</span>._observer.on(event)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#268bd2">final</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">forwarder</span>() -&gt; SinkForward&lt;Observer&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#719e07">return</span> SinkForward(forward: <span style="color:#cb4b16">self</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#268bd2">final</span> <span style="color:#268bd2">var</span> <span style="color:#268bd2">disposed</span>: <span style="color:#b58900">Bool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        <span style="color:#719e07">return</span> isFlagSet(<span style="color:#cb4b16">self</span>._disposed, <span style="color:#2aa198">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">dispose</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        fetchOr(<span style="color:#cb4b16">self</span>._disposed, <span style="color:#2aa198">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        <span style="color:#cb4b16">self</span>._cancel.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>}
</code></pre></div><p>又见到 AtomicInt，这次是修饰 _disposed 属性，各位自行理解。我们看核心方法：</p>
<ol>
<li><code>forwardOn(_:)</code> 用于转发，将 event 事件传递到 <code>Observer.on(_:)</code>；</li>
<li><code>dispose()</code> 直接调用 sinkDisposer -&gt; <code>dispose()</code>;</li>
</ol>
<p><code>forwarder()</code>  返回的 SinkForward 是 Observer 对象，它将 sink 的 observer 做了包装，该方法主要用于 <code>timeout()</code> 方法。转发逻辑如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">final</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">SinkForward</span>&lt;Observer: ObserverType&gt;: ObserverType {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#268bd2">final</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">on</span>(<span style="color:#cb4b16">_</span> event: Event&lt;Element&gt;) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">switch</span> event {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#719e07">case</span> .next:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>            <span style="color:#cb4b16">self</span>._forward._observer.on(event)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">case</span> .error, .completed:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#cb4b16">self</span>._forward._observer.on(event)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            <span style="color:#cb4b16">self</span>._forward._cancel.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>}
</code></pre></div><p>它不仅收集资源同时还加工以及转发事件。最后回到 ObservableSequenceSink 来看 <code>run()</code> 方法：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">final</span> <span style="color:#268bd2">private</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">ObservableSequenceSink</span>&lt;Sequence: Swift.Sequence, Observer: ObserverType&gt;: Sink&lt;Observer&gt; <span style="color:#719e07">where</span> Sequence.Element == Observer.Element {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#268bd2">typealias</span> Parent = ObservableSequence&lt;Sequence&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">_parent</span>: Parent
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">run</span>() -&gt; Disposable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">return</span> <span style="color:#cb4b16">self</span>._parent._scheduler.scheduleRecursive(<span style="color:#cb4b16">self</span>._parent._elements.makeIterator()) { iterator, recurse <span style="color:#719e07">in</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#268bd2">var</span> <span style="color:#268bd2">mutableIterator</span> = iterator
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            <span style="color:#719e07">if</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">next</span> = mutableIterator.next() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>                <span style="color:#cb4b16">self</span>.forwardOn(.next(next))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>                recurse(mutableIterator)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>            <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>                <span style="color:#cb4b16">self</span>.forwardOn(.completed)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                <span style="color:#cb4b16">self</span>.dispose()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>}
</code></pre></div><p><strong>_scheduler.scheduleRecursive</strong> 背后是 RxSwift 对于容器对象的线程调度，也不展开。这里的 <code>run()</code>方法 做了几个事情：</p>
<ol>
<li>Scheduler 会在指定线程中调用 Swift.Sequence 的迭代器，以遍历每个元素。</li>
<li>获取到元素后，将 next 事件不断转发给 Observer；</li>
<li>迭代结束后，发送 completed 事件至 Observer 并调用 dispose 出发 sinkDisposer 的资源清理操作；</li>
</ol>
<p>关于 Sink 再说明一下，本篇是以 Sequence 作为切入点，不同 Operator 背后的 Producer 所产生的 Sink 实现是有不少区别的，比如 Just 流只产生单个节点，则直接在重载的 subscribe 方法里发送 Event 然后就调用 dispose 结束了。因此，每个 operator 的实现会有比较大的出路，但是整体流程是由这些内部类来限制和保证的。</p>
<h2 id="subscription">Subscription</h2>
<p>我们回到文章开头接着聊一聊订阅：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>.subscribe( { <span style="color:#268bd2">print</span>(<span style="color:#268bd2">$0</span>) })
</code></pre></div><p>同 <code>of(_:)</code> 一样，订阅也是对 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/ObservableType%2BExtensions.swift">ObservableType 扩展</a>来实现的。简化后如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">ObservableType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">subscribe</span>(<span style="color:#cb4b16">_</span> on: @escaping (Event&lt;Element&gt;) -&gt; <span style="color:#b58900">Void</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        -&gt; Disposable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>            <span style="color:#268bd2">let</span> <span style="color:#268bd2">observer</span> = AnonymousObserver { e <span style="color:#719e07">in</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>                on(e)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#719e07">return</span> <span style="color:#cb4b16">self</span>.asObservable().subscribe(observer)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">subscribe</span>(onNext: ((Element) -&gt; <span style="color:#b58900">Void</span>)? = <span style="color:#cb4b16">nil</span>, onError: ((Swift.Error) -&gt; <span style="color:#b58900">Void</span>)? = <span style="color:#cb4b16">nil</span>, onCompleted: (() -&gt; <span style="color:#b58900">Void</span>)? = <span style="color:#cb4b16">nil</span>, onDisposed: (() -&gt; <span style="color:#b58900">Void</span>)? = <span style="color:#cb4b16">nil</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        -&gt; Disposable {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>}
</code></pre></div><p>两个 subscribe 方法都是将订阅的操作存入 AnonymousObserver 中，然后通过 <code>asObservable()</code> 获取 producer 并最终其 <code>subscribe(_:)</code> 以完成订阅。</p>
<p>我们看看 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observers/AnonymousObserver.swift">AnonymousObserver</a> 是什么来头：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">final</span> <span style="color:#268bd2">class</span> <span style="color:#268bd2">AnonymousObserver</span>&lt;Element&gt;: ObserverBase&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#268bd2">typealias</span> EventHandler = (Event&lt;Element&gt;) -&gt; <span style="color:#b58900">Void</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">_eventHandler</span> : EventHandler
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#586e75">/// 这里同样忽略了 `init()` 与 `deinit()` 的资源统计逻辑</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#268bd2">init</span>(<span style="color:#cb4b16">_</span> eventHandler: @escaping EventHandler) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#586e75">/// 资源统计</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#cb4b16">self</span>._eventHandler = eventHandler
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#268bd2">override</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">onCore</span>(<span style="color:#cb4b16">_</span> event: Event&lt;Element&gt;) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        <span style="color:#719e07">return</span> <span style="color:#cb4b16">self</span>._eventHandler(event)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
</code></pre></div><p>很简单，仅有一个 <code>_eventHandler</code> 属性保存订阅操作，然后在 <code>onCore(_:)</code> 中调用它。在翻它父类之前，看一眼它的继承关系：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">|</span> <span style="color:#719e07">---</span> AnonymousObserver
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> ObserverBase
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        <span style="color:#719e07">|</span> <span style="color:#719e07">---</span> Disposable、ObserverType
</code></pre></div><p>Disposable 我们已经知道了，看 ObserverType：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">protocol</span> <span style="color:#268bd2">ObserverType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    associatedtype Element
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">on</span>(<span style="color:#cb4b16">_</span> event: Event&lt;Element&gt;)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75">/// Convenience API extensions to provide alternate next, error, completed events</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#268bd2">extension</span> <span style="color:#268bd2">ObserverType</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">onNext</span>(<span style="color:#cb4b16">_</span> element: Element) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        <span style="color:#cb4b16">self</span>.on(.next(element))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">onCompleted</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>        <span style="color:#cb4b16">self</span>.on(.completed)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    <span style="color:#268bd2">public</span> <span style="color:#268bd2">func</span> <span style="color:#268bd2">onError</span>(<span style="color:#cb4b16">_</span> error: Swift.Error) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>        <span style="color:#cb4b16">self</span>.on(.error(error))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>}
</code></pre></div><p>声明了 <code>on(_:)</code> 方法，同时针对 Event 的类型提供了三个便利方法。Event 则是一个嵌套枚举类型：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">public</span> <span style="color:#268bd2">enum</span> <span style="color:#268bd2">Event</span>&lt;Element&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#586e75">/// Next element is produced.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">case</span> next(Element)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#586e75">/// Sequence terminated with an error.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">case</span> error(Swift.Error)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#586e75">/// Sequence completed successfully.</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">case</span> completed
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
</code></pre></div><h4 id="observerbase">ObserverBase</h4>
<p>我们来看 <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observers/ObserverBase.swift">ObserverBase</a>：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#268bd2">class</span> <span style="color:#268bd2">ObserverBase</span>&lt;Element&gt; : Disposable, ObserverType {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#268bd2">private</span> <span style="color:#268bd2">let</span> <span style="color:#268bd2">_isStopped</span> = AtomicInt(<span style="color:#2aa198">0</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">on</span>(<span style="color:#cb4b16">_</span> event: Event&lt;Element&gt;) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#719e07">switch</span> event {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">case</span> .next:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>            <span style="color:#719e07">if</span> load(<span style="color:#cb4b16">self</span>._isStopped) == <span style="color:#2aa198">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>                <span style="color:#cb4b16">self</span>.onCore(event)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        <span style="color:#719e07">case</span> .error, .completed:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>            <span style="color:#719e07">if</span> fetchOr(<span style="color:#cb4b16">self</span>._isStopped, <span style="color:#2aa198">1</span>) == <span style="color:#2aa198">0</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>                <span style="color:#cb4b16">self</span>.onCore(event)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">onCore</span>(<span style="color:#cb4b16">_</span> event: Event&lt;Element&gt;) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        rxAbstractMethod()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    <span style="color:#268bd2">func</span> <span style="color:#268bd2">dispose</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        fetchOr(<span style="color:#cb4b16">self</span>._isStopped, <span style="color:#2aa198">1</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>}
</code></pre></div><p>ObserverBase 利用 Atomic 声明的 _isStopped 属性作为哨兵，以保证资源被标记 _isStopped 后不会产生重复调用的。那么，如何做到的呢？</p>
<p>通过判断 _isStopped 是否为 0 来表示资源是否可用。一旦调用 <code>dispose()</code> 会将其值置为 1，则资源不可用。</p>
<p>另一种情况则在 <code>on</code> 方法内，实现逻辑如下：</p>
<ol>
<li>event 为 .next 事件：通过 <code>load(_:)</code> 取出 _isStopped 值并判断值是否为 0，是则执行 <code>onCore(event)</code> ；</li>
<li>event 为 .error、.completed 事件：
<ol>
<li>通过 <code>fetchOr(_:)</code> 取出 _isStopped 当前值后并将其置为 1，以保证不再重入；</li>
<li>判断 _isStopped 当前值是否为 0，是则执行 <code>onCore(event)</code> 。</li>
</ol>
</li>
</ol>
<p>因此 ObserverBase 核心功作用是保证暴露给子类的  <code>onCore(_:)</code>  在观察结束后不会被重复执行。也就是保证 AnonymousObserver 的 eventHandler 被正确执行。</p>
<p>最后，回顾一下订阅相关流程：</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cly1gd35tywfx7j223n0wogtr.jpg" alt="rxswift-subscription"></p>
<h2 id="总结">总结</h2>
<p>RxSwift 所展示的订阅流的处理，不仅充分利用了 Swift 语言本身的特性，如为协议添加默认实现、采用泛型来约束类的行为、天然支持链式调用等。通过经典的设计模式 <a href="https://www.wikiwand.com/en/Producer%E2%80%93consumer_problem">Producer–consumer</a>，以多元化的 Producer 来轻松支持各种 operator 的实现。还有就是巧妙的运用了位运算来简化逻辑。</p>
<p>由于篇幅有限，Schedule 的调度逻辑并未展开，还有就是 DisposeBag 通篇未提及，就当是思考作业啦。</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/source-code">Source Code</a>
     
    <a href="https://looseyi.github.io/tags/ios">iOS</a>
     
    <a href="https://looseyi.github.io/tags/reactive">Reactive</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/sourcecode-ios/cocoapods-packager/"><span>←</span><span>浅析 Cocoapods-Packager 实现</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-2/"><span>浅析 SDWebImage 5.5.2 - WebP Plugin</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
