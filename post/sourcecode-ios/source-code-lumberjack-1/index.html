<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>浅析 - CocoaLumberjack 3.6 之 DDLog - Aha Edmond</title>

  
  
  <meta name="description" content="介绍 CocoaLumberjack is a fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS. 先扯一下 lumberjack 这个单词，对应的就是它的 logo，一位伐木工。 一直不太理解为什么是用这个单词，其他语音中也有日" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-1/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="浅析 - CocoaLumberjack 3.6 之 DDLog" />
<meta property="og:description" content="介绍 CocoaLumberjack is a fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS. 先扯一下 lumberjack 这个单词，对应的就是它的 logo，一位伐木工。 一直不太理解为什么是用这个单词，其他语音中也有日" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-04T18:20:00&#43;08:00" />
<meta property="article:modified_time" content="2020-05-04T18:20:00&#43;08:00" />


  
  <meta itemprop="name" content="浅析 - CocoaLumberjack 3.6 之 DDLog">
<meta itemprop="description" content="介绍 CocoaLumberjack is a fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS. 先扯一下 lumberjack 这个单词，对应的就是它的 logo，一位伐木工。 一直不太理解为什么是用这个单词，其他语音中也有日"><meta itemprop="datePublished" content="2020-05-04T18:20:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-04T18:20:00&#43;08:00" />
<meta itemprop="wordCount" content="8097">
<meta itemprop="keywords" content="Source Code,iOS,Logger," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅析 - CocoaLumberjack 3.6 之 DDLog"/>
<meta name="twitter:description" content="介绍 CocoaLumberjack is a fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS. 先扯一下 lumberjack 这个单词，对应的就是它的 logo，一位伐木工。 一直不太理解为什么是用这个单词，其他语音中也有日"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-05-04</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>浅析 - CocoaLumberjack 3.6 之 DDLog</h1>
  </header>
  <section class="post-content"><h1 id="介绍">介绍</h1>
<blockquote>
<p><strong>CocoaLumberjack</strong> is a fast &amp; simple, yet powerful &amp; flexible logging framework for Mac and iOS.</p>
</blockquote>
<p>先扯一下 lumberjack 这个单词，对应的就是它的 logo，一位伐木工。
一直不太理解为什么是用这个单词，其他语音中也有日志库用的这个单词。最后还是感谢网友提示：log 有代表木头的意思，所以用 lumberjack 还是非常贴切的，😂。</p>
<p>写这篇文章是最近在使用过程中偶然发现，它居然有这么多隐藏功能，尽管项目里引入也有好多年了。接着又看了一下官方提供的 demos， 简直是惊呆了（PS：也太丰富了吧）。所以本文希望从源码来着重来介绍它的一些设计和 🤔 。最后会介绍一下它所支持的扩展。</p>
<h3 id="document">Document</h3>
<p>作为历史悠久的 library，它的 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack/tree/master/Documentation">document</a> 还是非常详细的，主要分三个级别：</p>
<ul>
<li>Beginner 入门级：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/GettingStarted.md">使用说明</a>、<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomFormatters.md">自定义日志格式</a>、<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/Performance.md">性能测试</a>、支持<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/XcodeColors.md">彩色输出</a>等；</li>
<li>Intermediate 进阶：lumberjack <a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/Architecture.md">内部概述</a>，如何定制 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomContext.md">custom logging context</a>、<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomLoggers.md">custrom logger</a>、<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomLogLevels.md">custom log levels</a> 等；</li>
<li>Advanced：高阶：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/DynamicLogLevels.md">动态修改 log levels</a>、<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/LogFileManagement.md">log 文件管理（压缩、上传</a>。</li>
</ul>
<h3 id="architecturehttpsgithubcomcocoalumberjackcocoalumberjackblobmasterdocumentationarchitecturemd"><a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/Architecture.md">Architecture</a></h3>
<p>照例，我们先预览一下类图，有个大概的印象。</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cly1gdzck4x5v5j213v0iv41x.jpg" alt="CocoaLumberjackClassDiagram.png"></p>
<p>在梳理完脑图才发现官方其实提供了完整的 UML 图。不过既然整理了脑图，那我把它贴在文末。</p>
<p>UML 上直观感受就是 class 并不多，但是功能确实十分完善，我们一点点来看看。</p>
<h1 id="ddlog">DDLog</h1>
<p>本文默认你是经历过新手村的，如果对 Lumberjack 的 API 完全不熟悉，请挪步：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/GettingStarted.md">getting start</a>。</p>
<p>核心文件 DDLog.h 中有声明了最重要的两个协议 <strong>DDLoger</strong> 和 <strong>DDLogFormatter</strong>，而 <strong>DDLog</strong> class 可以看作是一个 manager 的存在，它管理着所有注册在案的 loogers 和 formatters。这三个对于正常项目来说已经完全够用了。我们就从 protocol 着手，最后来说这个 DDLog。</p>
<h2 id="loggers">Loggers</h2>
<blockquote>
<p>A logger is a class that does something with a log message. The lumberjack framework comes with several different loggers. (You can also <a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomLoggers.md">create your own</a>.) Loggers such as <code>DDOSLogger</code> can be used to duplicate the functionality of <code>NSLog</code>. And <code>DDFileLogger</code> can be used to write log messages to a log file.</p>
</blockquote>
<p>loggers 相关类主要是对 log message 进行加工处理。那么一条 DDLogMessage 会存有哪些可用信息呢？</p>
<h3 id="ddlogmessage">DDLogMessage</h3>
<blockquote>
<p>Used by the logging primitives. (And the macros use the logging primitives.)</p>
</blockquote>
<p>log message 用于记录日志原语，它是通过宏来实现的。logging primitives 是什么意思呢？可以理解为 log message 保存了 log 被调用时的一系列相关环境的上下文。单词 primitive 一开始没看明白，不过计算机中倒是有一个<a href="https://baike.baidu.com/item/%E5%8E%9F%E8%AF%AD">原语</a>的概念（不一定对），可以帮助大家理解这个单词。</p>
<p>具体存了哪些东西呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">DDLogMessage</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// Direct accessors to be used only for performance
</span><span class="c1"></span>    <span class="k">@public</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_message</span><span class="p">;</span>
    <span class="n">DDLogLevel</span> <span class="n">_level</span><span class="p">;</span>
    <span class="n">DDLogFlag</span> <span class="n">_flag</span><span class="p">;</span>
    <span class="n">NSInteger</span> <span class="n">_context</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_file</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_fileName</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_function</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="n">_line</span><span class="p">;</span>
    <span class="kt">id</span> <span class="n">_tag</span><span class="p">;</span>
    <span class="n">DDLogMessageOptions</span> <span class="n">_options</span><span class="p">;</span>
    <span class="n">NSDate</span> <span class="o">*</span> <span class="n">_timestamp</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_threadID</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_threadName</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">_queueLabel</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="n">_qos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里通过前置声明实例变量，这样调用方可以避开 getter 直接访问变量，来提高访问效率。当然作者也提供了 readonly 的 @property method。</p>
<p>首先，message、file、function <strong>默认不会执行 copy 操作</strong>，如果需要可以通过 DDLogMessageOptions 来控制：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">,</span> <span class="n">DDLogMessageOptions</span><span class="p">){</span>
	 <span class="c1">/// Use this to use a copy of the file path
</span><span class="c1"></span>    <span class="n">DDLogMessageCopyFile</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
 	 <span class="c1">/// Use this to use a copy of the function name
</span><span class="c1"></span>    <span class="n">DDLogMessageCopyFunction</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	 <span class="c1">/// Use this to use avoid a copy of the message
</span><span class="c1"></span>    <span class="n">DDLogMessageDontCopyMessage</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>我们知道，对于 NSString 的操作需要使用 copy ，以保证我们对它操作时是安全及不可变的。这里针对 message、file、function 却不采用 copy，是为了避免不必要的 allocations 开销。因为 file 和 function 是通过 __FILE__ and __FUNCTION__ 这两个宏来获取的，它们本质上就是一个字符常量，所以可以这么操作。而 message 正常由 DDlog 内部生成的，Lumberjack 来保证 mesage 不可修改。So 官方提示如下：</p>
<blockquote>
<p>If you find need to manually create logMessage objects, there is one thing you should be aware of.</p>
</blockquote>
<p>说的就是，当你需要手动生成 log message 的时候需要注意，这三个参数的内存修饰操作。</p>
<p>log message 内部实现就比较简单了，以 message 字段为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="kt">BOOL</span> <span class="n">copyMessage</span> <span class="o">=</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">DDLogMessageDontCopyMessage</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">_message</span> <span class="o">=</span> <span class="n">copyMessage</span> <span class="o">?</span> <span class="p">[</span><span class="n">message</span> <span class="k">copy</span><span class="p">]</span> <span class="o">:</span> <span class="n">message</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>另外，就是每个 logMessage 会记录当前调用的 thread &amp; queue 信息，分别如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="n">__uint64_t</span> <span class="n">tid</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pthread_threadid_np</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_threadID</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&#34;%llu&#34;</span><span class="p">,</span> <span class="n">tid</span><span class="p">];</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">_threadID</span> <span class="o">=</span> <span class="s">@&#34;missing threadId&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">_threadName</span>   <span class="o">=</span> <span class="n">NSThread</span><span class="p">.</span><span class="n">currentThread</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="c1">// Try to get the current queue&#39;s label
</span><span class="c1"></span><span class="n">_queueLabel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&#34;%s&#34;</span><span class="p">,</span> <span class="n">dispatch_queue_get_label</span><span class="p">(</span><span class="n">DISPATCH_CURRENT_QUEUE_LABEL</span><span class="p">)];</span>
<span class="k">if</span> <span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">macOS</span> <span class="mf">10.10</span><span class="p">,</span> <span class="n">iOS</span> <span class="mf">8.0</span><span class="p">,</span> <span class="o">*</span><span class="p">))</span>
    <span class="n">_qos</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span> <span class="n">qos_class_self</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="ddloglevel">DDLogLevel</h3>
<blockquote>
<p>Log levels are used to filter out logs. Used together with flags.</p>
</blockquote>
<p>每一条 log mesage 都设置了对应的日志级别，用于过滤 logs 的。其定义是一个枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">DDLogLevel</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// No logs
</span><span class="c1"></span>    <span class="n">DDLogLevelOff</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
    <span class="c1">// Error logs only
</span><span class="c1"></span>    <span class="n">DDLogLevelError</span>     <span class="o">=</span> <span class="p">(</span><span class="n">DDLogFlagError</span><span class="p">),</span> 
    <span class="c1">// Error and warning logs
</span><span class="c1"></span>    <span class="n">DDLogLevelWarning</span>   <span class="o">=</span> <span class="p">(</span><span class="n">DDLogLevelError</span>   <span class="o">|</span> <span class="n">DDLogFlagWarning</span><span class="p">),</span>
    <span class="c1">// Error, warning and info logs
</span><span class="c1"></span>    <span class="n">DDLogLevelInfo</span>      <span class="o">=</span> <span class="p">(</span><span class="n">DDLogLevelWarning</span> <span class="o">|</span> <span class="n">DDLogFlagInfo</span><span class="p">),</span> 
    <span class="c1">// Error, warning, info and debug logs
</span><span class="c1"></span>    <span class="n">DDLogLevelDebug</span>     <span class="o">=</span> <span class="p">(</span><span class="n">DDLogLevelInfo</span>    <span class="o">|</span> <span class="n">DDLogFlagDebug</span><span class="p">),</span> 
    <span class="c1">// Error, warning, info, debug and verbose logs
</span><span class="c1"></span>    <span class="n">DDLogLevelVerbose</span>   <span class="o">=</span> <span class="p">(</span><span class="n">DDLogLevelDebug</span>   <span class="o">|</span> <span class="n">DDLogFlagVerbose</span><span class="p">),</span> 
    <span class="c1">// All logs (1...11111)
</span><span class="c1"></span>    <span class="n">DDLogLevelAll</span>       <span class="o">=</span> <span class="n">NSUIntegerMax</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>而 loglevel 是由 DDLogFlag 控制，其声明如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">DDLogFlag</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 0...00001 DDLogFlagError
</span><span class="c1"></span>    <span class="n">DDLogFlagError</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
    <span class="c1">// 0...00010 DDLogFlagWarning
</span><span class="c1"></span>    <span class="n">DDLogFlagWarning</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
    <span class="c1">// 0...00100 DDLogFlagInfo
</span><span class="c1"></span>    <span class="n">DDLogFlagInfo</span>       <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
    <span class="c1">// 0...01000 DDLogFlagDebug
</span><span class="c1"></span>    <span class="n">DDLogFlagDebug</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
    <span class="c1">// 0...10000 DDLogFlagVerbose
</span><span class="c1"></span>    <span class="n">DDLogFlagVerbose</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>这些就是 DDLog 所预设的 5 种 level，对于新手来说基本够用了。同时，对于有自定义 level 需求的用户来说，可以通过结构化的宏，就能轻松实现。详见 <a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/CustomLogLevels.md">CustomLogLevels.md</a>。</p>
<p>其核心是先将预设的 level 清除，然后在进行重新定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="c1">// First undefine the default stuff we don&#39;t want to use.
</span><span class="c1"></span><span class="cp">#undef DDLogError
</span><span class="cp">#undef DDLogWarn
</span><span class="cp">#undef DDLogInfo
</span><span class="cp">#undef DDLogDebug
</span><span class="cp">#undef DDLogVerbose
</span><span class="cp"></span><span class="p">...</span>
<span class="c1">// Now define everything how we want it
</span><span class="c1"></span><span class="cp">#define LOG_FLAG_FATAL   (1 &lt;&lt; 0)  </span><span class="c1">// 0...000001
</span><span class="c1"></span><span class="cp">#define LOG_LEVEL_FATAL   (LOG_FLAG_FATAL)  </span><span class="c1">// 0...000001
</span><span class="c1"></span><span class="cp">#define LOG_FATAL   (ddLogLevel &amp; LOG_FLAG_FATAL )
</span><span class="cp">#define DDLogFatal(frmt, ...)    SYNC_LOG_OBJC_MAYBE(ddLogLevel, LOG_FLAG_FATAL,  0, frmt, ##__VA_ARGS__)
</span><span class="cp"></span><span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>除了对 level 的重定义之外，我们也可以通过对 level 进行扩展来满足我们对需求。由于 lumberjack 使用的是 bitmask 且只预设了 5 个 bit，对应 5 种 log flag。</p>
<p>而 logLevel 作为 Int 类型，意味着对于 32 位的系统而言，预留给我们的 levels 还有 28 bits，因为默认的 level 仅仅占用了 4 bits。扩展空间可以说是绰绰有余的。官方提供了两个需要进行扩展的场景，详见：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/blob/master/Documentation/FineGrainedLogging.md">FineGrainedLogging.md</a>。</p>
<h3 id="ddloger">DDLoger</h3>
<blockquote>
<p>This protocol describes a basic logger behavior.</p>
<ul>
<li>Basically, it can log messages, store a logFormatter plus a bunch of optional behaviors.</li>
<li>(i.e. flush, get its loggerQueue, get its name, &hellip;</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@protocol</span> <span class="nc">DDLogger</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">logMessage</span><span class="p">:(</span><span class="n">DDLogMessage</span> <span class="o">*</span><span class="p">)</span><span class="n">logMessage</span> <span class="n">NS_SWIFT_NAME</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="nl">message</span><span class="p">:));</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogFormatter</span><span class="o">&gt;</span> <span class="n">logFormatter</span><span class="p">;</span>

<span class="k">@optional</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">didAddLogger</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didAddLoggerInQueue:</span><span class="p">(</span><span class="n">dispatch_queue_t</span><span class="p">)</span><span class="nv">queue</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">willRemoveLogger</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">flush</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_REFERENCE_TYPE</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">dispatch_queue_t</span> <span class="n">loggerQueue</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">DDLoggerName</span> <span class="n">loggerName</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>logMessage 没啥好说的，logFormatter 会在后面介绍。重点看上面的几个 optional 方法和参数。</p>
<p><strong>loggerQueue</strong></p>
<p>先看 loggerQueue，由于日志打印均为异步操作，所以会为每个 looger 分配一个 dispatch_queue_t。如果 logger 未提供 loggerQueue，那么 DDLog 为根据你所指定的 loggerName 主动为你生成。</p>
<p><strong>didAddLogger</strong></p>
<p>同样由于异步打印日志的原因，looger 被添加到 loogers 中时也是异步的过程，didAddLogger 方法就是用于通知  logger 已被成功添加，而这个操作时在 loggerQueue 中完成的。</p>
<p>同样，<code>didAddLoggerInQueue:</code> 和 <code>willRemoveLogger</code> 目的也是类似。</p>
<p><strong>flush</strong></p>
<p>用于刷新存在在队列中还未处理的 log message。比如，database logger 可能通过 I/O buffer 来减少日志存储频率，毕竟磁盘 I/O 是比较耗时的，这种情况下，logger 中可能留有未被及时处理的 log message。</p>
<p>DDLog 会通过 <code>flushLog</code> 来执行 flush 。需要⚠️的是，当应用退出的时候  <code>flushLog</code> 会被自动调用。当然，作为开发者我们可以在适当的情况下手动触发刷新，正常是不需要手动触发的。</p>
<h3 id="ddlogformatter">DDLogFormatter</h3>
<blockquote>
<p>Formatter allow you to format a log message before the logger logs it.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@protocol</span> <span class="nc">DDLogFormatter</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="k">@required</span>
<span class="o">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nl">formatLogMessage</span><span class="p">:(</span><span class="n">DDLogMessage</span> <span class="o">*</span><span class="p">)</span><span class="n">logMessage</span> <span class="n">NS_SWIFT_NAME</span><span class="p">(</span><span class="n">format</span><span class="p">(</span><span class="nl">message</span><span class="p">:));</span>

<span class="k">@optional</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">didAddToLogger</span><span class="p">:(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="n">logger</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didAddToLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span> <span class="nf">inQueue:</span><span class="p">(</span><span class="n">dispatch_queue_t</span><span class="p">)</span><span class="nv">queue</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">willRemoveFromLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>formatLogMessage:</strong></p>
<p>formatter 是可以添加到任何 logger 上的，通过 <code>formatLogMessage:</code> 极大提高了 logging 的自由度。怎么理解呢？我们可以通过 <code>formatLogMessage:</code> 给 file logger 和 console 返回不同的结果。例如 console 一般系统会自动在 log 前添加时间戳，而当我们写入 log file 时就需要自行来添加时间。我们还可以通过返回 nil 将其作为 filter 来过滤对应的 log。</p>
<p><strong>didAddToLogger</strong></p>
<p>一个 formatter 可以被添加到多个 logger 上。当 formatter 被添加时，通过这个方法来通知它。该方法是需要保证线程安全的，否则可能会出现线程安全异常。</p>
<p>同理，<code>didAddToLogger: inQueue</code> 是指在指定队列中进行 format 操作。</p>
<p><code>willRemoveFromLogger</code> 则是 formatter 被移除时的通知。</p>
<h2 id="ddlog-1">DDLog</h2>
<blockquote>
<p>The main class, exposes all logging mechanisms, loggers, &hellip;</p>
<p>For most of the users, this class is hidden behind the logging functions like <code>DDLogInfo</code></p>
</blockquote>
<p>DDLog 作为 lumberjack 的管理类，负责将用户的 log 信息收集后集中调度至不同的 logger 已达到不同的功能，比如 console log 和 file log。因此，作为单例是必须的。我们先来看看它初始化都准备了什么东西。</p>
<h3 id="initialize">Initialize</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@interface</span> <span class="nc">DDLog</span> <span class="p">()</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">_loggers</span><span class="p">;</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">DDLog</span>

<span class="k">static</span> <span class="n">dispatch_queue_t</span> <span class="n">_loggingQueue</span><span class="p">;</span>
<span class="k">static</span> <span class="n">dispatch_group_t</span> <span class="n">_loggingGroup</span><span class="p">;</span>
<span class="k">static</span> <span class="n">dispatch_semaphore_t</span> <span class="n">_queueSemaphore</span><span class="p">;</span>
<span class="k">static</span> <span class="n">NSUInteger</span> <span class="n">_numProcessors</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>上面几个均为私有变量，_loggers 自不必说，任何 logger 的添加/删除都需要在 loggingQueue/loggingThread 中进行的。</p>
<p><strong>_loggingQueue</strong></p>
<p>全局的 log queue 用于保证 FIFO 的操作顺序，所有 logger 会通过它来顺序执行各 logger 的 <code>logMessage:</code> 。</p>
<p><strong>_loggingGroup</strong></p>
<p>由于每个 logger 添加时候都配置了对应的 log queue。因此，loggers 之间的记录行为是并发执行的。而 dispatch group 可以同步所有 loggers 的操作，确保记录行为顺利完成。</p>
<p><strong>_queueSemaphore</strong></p>
<p>防止所使用的队列过爆。由于大多数记录都是异步操作，因此，可能遭到恶意线程大量的增加 log 影响正常的记录行为。最大限制数为 DDLOG_MAX_QUEUE_SIZE (1000)，也就是说当队列数超过限制，则会主动阻塞线程，以待执行队列降至安全水平。</p>
<p>例如：在大型循环中随意添加日志语句时会发生过💥。</p>
<p><strong>_numProcessors</strong></p>
<p>记录处理器内核数量，以针对单核情况时进行相应的优化。</p>
<p>作为静态变量，其初始化则放在 <code>initialize</code>，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">DDLogOnceToken</span><span class="p">;</span>

    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DDLogOnceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLogDebug</span><span class="p">(</span><span class="s">@&#34;DDLog: Using grand central dispatch&#34;</span><span class="p">);</span>

        <span class="n">_loggingQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&#34;cocoa.lumberjack&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">_loggingGroup</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>

        <span class="kt">void</span> <span class="o">*</span><span class="n">nonNullValue</span> <span class="o">=</span> <span class="n">GlobalLoggingQueueIdentityKey</span><span class="p">;</span> <span class="c1">// Whatever, just not null
</span><span class="c1"></span>        <span class="n">dispatch_queue_set_specific</span><span class="p">(</span><span class="n">_loggingQueue</span><span class="p">,</span> <span class="n">GlobalLoggingQueueIdentityKey</span><span class="p">,</span> <span class="n">nonNullValue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">_queueSemaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="n">DDLOG_MAX_QUEUE_SIZE</span><span class="p">);</span>

        <span class="c1">// Figure out how many processors are available.
</span><span class="c1"></span>        <span class="c1">// This may be used later for an optimization on uniprocessor machines.
</span><span class="c1"></span>
        <span class="n">_numProcessors</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">([</span><span class="n">NSProcessInfo</span> <span class="n">processInfo</span><span class="p">].</span><span class="n">processorCount</span><span class="p">,</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">NSLogDebug</span><span class="p">(</span><span class="s">@&#34;DDLog: numProcessors = %@&#34;</span><span class="p">,</span> <span class="l">@(</span><span class="n">_numProcessors</span><span class="l">)</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码中，通过 <code>dispatch_queue_set_specific</code> 为 _loggingQueue 添加了 key：<strong>GlobalLoggingQueueIdentityKey</strong> 作为标记。之后会在所有的内部方法执行前通过 <code>dispatch_get_specific</code> 获取 flag 来进行断言，确保内部方法都是在全局的 _loggingQueue 中调度的。</p>
<p>接着，我们来看看 DDLog 实例的初始化，仅做了两件事：</p>
<ul>
<li>_loggers 初始化；</li>
<li>尝试注册通知，确保 APP 进程结束前能够及时将 Logger 中的 message 处理完毕；</li>
</ul>
<p>由于 lumberjack 支持全平台以及命令行，这里的 notificationName 判断条件相对多一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="cp">#if TARGET_OS_IOS
</span><span class="cp"></span>    <span class="n">NSString</span> <span class="o">*</span><span class="n">notificationName</span> <span class="o">=</span> <span class="n">UIApplicationWillTerminateNotification</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="n">NSString</span> <span class="o">*</span><span class="n">notificationName</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">// On Command Line Tool apps AppKit may not be available
</span><span class="c1"></span><span class="cp">#if !defined(DD_CLI) &amp;&amp; __has_include(&lt;AppKit/NSApplication.h&gt;)
</span><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">NSApp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">notificationName</span> <span class="o">=</span> <span class="n">NSApplicationWillTerminateNotification</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">notificationName</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If there is no NSApp -&gt; we are running Command Line Tool app.
</span><span class="c1"></span>        <span class="c1">// In this case terminate notification wouldn&#39;t be fired, so we use workaround.
</span><span class="c1"></span>        <span class="k">__weak</span> <span class="n">__auto_type</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
        <span class="n">atexit_b</span> <span class="p">(</span><span class="o">^</span><span class="p">{</span>
            <span class="p">[</span><span class="n">weakSelf</span> <span class="nl">applicationWillTerminate</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* if TARGET_OS_IOS */</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div><p>稍微提一点，命令行中是如何来监听程序退出？这里用到了 <code>atexit</code></p>
<blockquote>
<p>The atexit() function registers the given function to be called at program exit, whether via exit(3) or via return from the program&rsquo;s main().  Functions so registered are called in reverse order; no arguments are passed.</p>
</blockquote>
<p>就是说，程序在退出时，系统会主动调用通过 atexit 注册的 callbacks，可以注册多个回调，按照顺序执行。</p>
<p>DDLog 在收到通知后会触发 <code>flush</code>，这个我们晚一点展开。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">if</span> <span class="p">(</span><span class="n">notificationName</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver</span><span class="p">:</span><span class="nb">self</span>
                                             <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">applicationWillTerminate</span><span class="p">:)</span>
                                                 <span class="nl">name</span><span class="p">:</span><span class="n">notificationName</span>
                                               <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">applicationWillTerminate</span><span class="p">:(</span><span class="n">NSNotification</span> <span class="o">*</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span><span class="n">notification</span> <span class="p">{</span>
    <span class="p">[</span><span class="nb">self</span> <span class="n">flushLog</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="logger-management">Logger Management</h3>
<p>对 logger 的操作主要是添加和删除。</p>
<p><strong>AddLogger</strong></p>
<p>DDLog 提供了多个添加 logger 的 convince 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span><span class="p">;</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span> <span class="nf">withLevel:</span><span class="p">(</span><span class="n">DDLogLevel</span><span class="p">)</span><span class="nv">level</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span> <span class="nf">withLevel:</span><span class="p">(</span><span class="n">DDLogLevel</span><span class="p">)</span><span class="nv">level</span><span class="err">；</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">addLogger</span><span class="p">:(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="n">logger</span> <span class="nl">withLevel</span><span class="p">:(</span><span class="n">DDLogLevel</span><span class="p">)</span><span class="n">level</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">_loggingQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="nl">lt_addLogger</span><span class="p">:</span><span class="n">logger</span> <span class="nl">level</span><span class="p">:</span><span class="n">level</span><span class="p">];</span>
    <span class="p">}</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在放入 _loggingQueue 后，最终走到了 <code>lt_addLogger: level:</code> 方法。这里的前缀 <code>lt</code> 是 lgging thread 的缩写。在 logger 添加前会检查去重：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">for</span> <span class="p">(</span><span class="n">DDLoggerNode</span> <span class="o">*</span><span class="n">node</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">_loggers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">_logger</span> <span class="o">==</span> <span class="n">logger</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">_level</span> <span class="o">==</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Exactly same logger already added, exit
</span><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>DDLoggerNode</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">DDLoggerNode</span> : <span class="nc">NSObject</span>
<span class="p">{</span>
    <span class="c1">// Direct accessors to be used only for performance
</span><span class="c1"></span>    <span class="k">@public</span>
    <span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span> <span class="n">_logger</span><span class="p">;</span>
    <span class="n">DDLogLevel</span> <span class="n">_level</span><span class="p">;</span>
    <span class="n">dispatch_queue_t</span> <span class="n">_loggerQueue</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">nodeWithLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span>
                   <span class="nf">loggerQueue:</span><span class="p">(</span><span class="n">dispatch_queue_t</span><span class="p">)</span><span class="nv">loggerQueue</span>
                         <span class="nf">level:</span><span class="p">(</span><span class="n">DDLogLevel</span><span class="p">)</span><span class="nv">level</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>私有类，用于关联 logger、level 和 loggerQueue。</p>
<p>稍微提一下，在 DDLoggerNode 的初始化方法中的，兼容了 MRC 的使用。内部使用了一个宏 <code>OS_OBJECT_USE_OBJC</code> 来区分 GCD 是否支持 ARC。在6.0 之前 GCD 中的对象是不支持 ARC，因此在 6.0 之前 <code>OS_OBJECT_USE_OBJC</code> 是没有的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">if</span> <span class="p">(</span><span class="n">loggerQueue</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_loggerQueue</span> <span class="o">=</span> <span class="n">loggerQueue</span><span class="p">;</span>
    <span class="cp">#if !OS_OBJECT_USE_OBJC
</span><span class="cp"></span>    <span class="n">dispatch_retain</span><span class="p">(</span><span class="n">loggerQueue</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接着就是前面所提到的 QueueIdentity 的断言：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">NSAssert</span><span class="p">(</span><span class="n">dispatch_get_specific</span><span class="p">(</span><span class="n">GlobalLoggingQueueIdentityKey</span><span class="p">),</span>
         <span class="s">@&#34;This method should only be run on the logging thread/queue&#34;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>准备 loggerQueue：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">dispatch_queue_t</span> <span class="n">loggerQueue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">if</span> <span class="p">([</span><span class="n">logger</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">loggerQueue</span><span class="p">)])</span> <span class="p">{</span>
    <span class="n">loggerQueue</span> <span class="o">=</span> <span class="n">logger</span><span class="p">.</span><span class="n">loggerQueue</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">loggerQueue</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">loggerQueueName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">logger</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">loggerName</span><span class="p">)])</span> <span class="p">{</span>
        <span class="n">loggerQueueName</span> <span class="o">=</span> <span class="n">logger</span><span class="p">.</span><span class="n">loggerName</span><span class="p">.</span><span class="n">UTF8String</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">loggerQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="n">loggerQueueName</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码，有没有似曾相识的干？这是在 <code>DDLogger Protocol</code> 声明时提到的逻辑。如果 logger 提供了 loggerQueue 则直接使用。否则，通过 loggerName 来创建。</p>
<p>最后就是创建 DDLoggerNode，添加 logger，发送 <code>didAddLogger</code> 通知。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">DDLoggerNode</span> <span class="o">*</span><span class="n">loggerNode</span> <span class="o">=</span> <span class="p">[</span><span class="n">DDLoggerNode</span> <span class="nl">nodeWithLogger</span><span class="p">:</span><span class="n">logger</span> <span class="nl">loggerQueue</span><span class="p">:</span><span class="n">loggerQueue</span> <span class="nl">level</span><span class="p">:</span><span class="n">level</span><span class="p">];</span>
<span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">_loggers</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">loggerNode</span><span class="p">];</span>

<span class="k">if</span> <span class="p">([</span><span class="n">logger</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">didAddLoggerInQueue</span><span class="p">:)])</span> <span class="p">{</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">logger</span> <span class="nl">didAddLoggerInQueue</span><span class="p">:</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">];</span>
    <span class="p">}</span> <span class="p">});</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="n">logger</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">didAddLogger</span><span class="p">)])</span> <span class="p">{</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">logger</span> <span class="n">didAddLogger</span><span class="p">];</span>
    <span class="p">}</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>RemoveLogger</strong></p>
<p>同 addLogger 类似，removeLogger 也提供了实例方法和类方法。类方法通过 sharedInstance 最终收口到实例方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeLogger:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">logger</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">_loggingQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="nl">lt_removeLogger</span><span class="p">:</span><span class="n">logger</span><span class="p">];</span>
    <span class="p">}</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>-[DDLog lt_removeLogger:]</strong></p>
<p>删除前，照例是 loggingQueue 检查，然后遍历获取 loggerNode：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">DDLoggerNode</span> <span class="o">*</span><span class="n">loggerNode</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">DDLoggerNode</span> <span class="o">*</span><span class="n">node</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">_loggers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">_logger</span> <span class="o">==</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">loggerNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果 loggerNode 不存在，则提前结束。存在，则会先向 loggerNode 发送 <code>willRemoveLogger</code> 通知，再移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">if</span> <span class="p">([</span><span class="n">logger</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">willRemoveLogger</span><span class="p">)])</span> <span class="p">{</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">logger</span> <span class="n">willRemoveLogger</span><span class="p">];</span>
    <span class="p">}</span> <span class="p">});</span>
<span class="p">}</span>
<span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">_loggers</span> <span class="nl">removeObject</span><span class="p">:</span><span class="n">loggerNode</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>DDLog 还提供了 removeAllLoggers 的方法，以一次性清零 loggers，实现同 <code>lt_removeLogger:</code> 类似，这里不展开了。</p>
<h3 id="logging">Logging</h3>
<p>logging 相关方法是 DDLog 的核心，提供三种类型的实例方法，以及分别对应的类方法。我们来看第一个：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">log:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">asynchronous</span>
      <span class="nf">level:</span><span class="p">(</span><span class="n">DDLogLevel</span><span class="p">)</span><span class="nv">level</span>
       <span class="nf">flag:</span><span class="p">(</span><span class="n">DDLogFlag</span><span class="p">)</span><span class="nv">flag</span>
    <span class="nf">context:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">context</span>
       <span class="nf">file:</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nv">file</span>
   <span class="nf">function:</span><span class="p">(</span><span class="n">nullable</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nv">function</span>
       <span class="nf">line:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">line</span>
        <span class="nf">tag:</span><span class="p">(</span><span class="n">nullable</span> <span class="kt">id</span><span class="p">)</span><span class="nv">tag</span>
     <span class="nf">format:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">format</span><span class="p">,</span> <span class="p">...</span> <span class="n">NS_FORMAT_FUNCTION</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>熟悉吧，这些参数前面都介绍过了，是构造 log message 所需的关参数。最后一个 C 写法的可变参数 <code>...</code> 用于生成 log message string，同样 DDLog 也提供了它的变种 <code>args:(va_list)argList</code> ，这就是第二种 log 方法。最后一种则是由用户直接提供 logMessage。</p>
<p>对于 <code>...</code> 的可变参数的获取，是通过 c 提供的宏，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">va_list</span> <span class="n">args</span><span class="p">;</span>
<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="n">format</span> <span class="nl">arguments</span><span class="p">:</span><span class="n">args</span><span class="p">];</span>
<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>-[DDLog queueLogMessage: asynchronously:]</strong></p>
<p>准备好 log message 则开始分发，进行异步调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">queueLogMessage:</span><span class="p">(</span><span class="n">DDLogMessage</span> <span class="o">*</span><span class="p">)</span><span class="nv">logMessage</span> <span class="nf">asynchronously:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">asyncFlag</span> <span class="p">{</span>
   <span class="n">dispatch_block_t</span> <span class="n">logBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">_queueSemaphore</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
        <span class="k">@autoreleasepool</span> <span class="p">{</span>
            <span class="p">[</span><span class="nb">self</span> <span class="nl">lt_log</span><span class="p">:</span><span class="n">logMessage</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">asyncFlag</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">_loggingQueue</span><span class="p">,</span> <span class="n">logBlock</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_get_specific</span><span class="p">(</span><span class="n">GlobalLoggingQueueIdentityKey</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">logBlock</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">_loggingQueue</span><span class="p">,</span> <span class="n">logBlock</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先忽略 logBlock，看 DDLog 如果处理 loggingQueue 调度，以及如何来避免线程死锁问题。这里的解决方式绝对需要<strong>划重点</strong>。大家经常遇到的主线程死锁，很常见的情况如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;1&#34;</span><span class="p">);</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;2&#34;</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&#34;3&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个也是面试会被常常问到的 case。核心点在于，上述代码在 main thread 执行了 dispatch_sync 开启了 main queue 的同步等待。解决方案就有很多种，比如 SDWebImage 中就提供了 <a href="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-1/">dispatch_main_async_safe</a> 来避免该问题。</p>
<p>回到 DDLog，现在大家可以明白在 dispatch_sync 前为何需要多一步 queue identity 的判断了吧。另外，关于这个问题，<a href="https://github.com/CocoaLumberjack/CocoaLumberjack/issues/812#issuecomment-298853313">github issuse #812</a> 中有比较详细的论述。</p>
<p>接着看 logBlock，它在执行第一行代码时，就开启了 semaphore_wait 直到可用队列数小于 maximumQueueSize。通常来说，我们会通过给 queueSize 加锁的方式来确保可用队列数的准确性和线程安全。但是这里作者希望，能够更快速的来获取添加 log mesage 入队列的时机，毕竟锁的开销比较大。</p>
<p>这种实践在很多优秀开源库中都用到了，比如 SDWebImage。</p>
<p><strong>- [DDLog lt_log:]</strong></p>
<p>该方法是将 log message 分配到所以满足的 logger 手中。开始前照例进行 QueueIdentity 的断言。接着依据 CPU 内核数是单核或者多核区别对待：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">if</span> <span class="p">(</span><span class="n">_numProcessors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="p">...</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>多核处理器，代码如下：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">for</span> <span class="p">(</span><span class="n">DDLoggerNode</span> <span class="o">*</span><span class="n">loggerNode</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">_loggers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">logMessage</span><span class="o">-&gt;</span><span class="n">_flag</span> <span class="o">&amp;</span> <span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_level</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">_loggingGroup</span><span class="p">,</span> <span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_logger</span> <span class="nl">logMessage</span><span class="p">:</span><span class="n">logMessage</span><span class="p">];</span>
    <span class="p">}</span> <span class="p">});</span>
<span class="p">}</span>
<span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">_loggingGroup</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>稍微提一下 DDLog 的设计思路，由于一条 log message 可能会提供给多个不同类型的 logger 处理。例如，一条 log 可能同时需要输出到终端、写入到 log file 中、通过 websocket 输出到浏览器方便测试等操作。</p>
<p>首先，通过 logMessage-&gt;_flag 过滤掉 level 不匹配的 loggerNode。然后从匹配到的 loggerNode 中取出 loggerQueue 和 logger 调用 <code>logMessage:</code> 。</p>
<p>重点来了，这里利用 _loggingGroup 将本次的 <code>logMessage:</code> 关联到 group 中，打包成一个 &ldquo;事务&rdquo;，以保证每次的 <code>lt_log:</code> 都是顺序执行的。而每个 logger 本身都分配了独立的 loggerQueue，通过这种组合，即保证了 logger 的并发调用，又能满足 queueSize 的限制。</p>
<p>使用 dispatch_group_wait 还有一个目的，就是确保那些执行效果慢的 logger 也能按顺序完成调用，避免队列任务过多时，这些 logger 没能及时完成导致大量的 padding log message 没有被及时处理。</p>
<ol start="2">
<li>对单核处理就比较简单了，就是第二步不同。不存在 gropu 操作：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_logger</span> <span class="nl">logMessage</span><span class="p">:</span><span class="n">logMessage</span><span class="p">];</span>
<span class="p">}</span> <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>最后，分配完 logger message 后，需要将 _queueSemaphore 加 1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">_queueSemaphore</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>lt_flush</strong></p>
<p>DDLog 的最后一个方法，会在程序结束前由通知来触发执行，其实现同 <code>lt_log:</code> 类似：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">lt_flush</span> <span class="p">{</span>
    <span class="n">NSAssert</span><span class="p">(</span><span class="n">dispatch_get_specific</span><span class="p">(</span><span class="n">GlobalLoggingQueueIdentityKey</span><span class="p">),</span>
             <span class="s">@&#34;This method should only be run on the logging thread/queue&#34;</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">DDLoggerNode</span> <span class="o">*</span><span class="n">loggerNode</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">_loggers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_logger</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">flush</span><span class="p">)])</span> <span class="p">{</span>
            <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">_loggingGroup</span><span class="p">,</span> <span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span> <span class="k">@autoreleasepool</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">loggerNode</span><span class="o">-&gt;</span><span class="n">_logger</span> <span class="n">flush</span><span class="p">];</span>
            <span class="p">}</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dispatch_group_wait</span><span class="p">(</span><span class="n">_loggingGroup</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="小结">小结</h3>
<p>DDLog 名副其实的 manager，利用了信号量和 group 高效的完成对 message 的调度，主要做了以下工作：</p>
<ol>
<li>管理 logger 的生命周期，并对其添加、删除操作进行相应通知；</li>
<li>生成 logMessage 并在线程安全的情况下，将其分配到对应的 logger 以加工 message。</li>
<li>在程序结束后，及时通知 logger 清理 pending 状态的 message。</li>
</ol>
<h1 id="loggers-1">Loggers</h1>
<p>现在我们来聊聊 logger。DDLog 给我们提供了一个 logger 基类 DDAbstractLogger 以及几个默认实现。一一来过一下；</p>
<h2 id="ddabstractlogger">DDAbstractLogger</h2>
<p>AbstractLogger 声明如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@interface</span> <span class="nc">DDAbstractLogger</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">DDLogger</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">@public</span>
    <span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogFormatter</span><span class="o">&gt;</span> <span class="n">_logFormatter</span><span class="p">;</span>
    <span class="n">dispatch_queue_t</span> <span class="n">_loggerQueue</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogFormatter</span><span class="o">&gt;</span> <span class="n">logFormatter</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_REFERENCE_TYPE</span><span class="p">)</span> <span class="n">dispatch_queue_t</span> <span class="n">loggerQueue</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="k">getter</span><span class="o">=</span><span class="n">isOnGlobalLoggingQueue</span><span class="p">)</span>  <span class="kt">BOOL</span> <span class="n">onGlobalLoggingQueue</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="k">getter</span><span class="o">=</span><span class="n">isOnInternalLoggerQueue</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">onInternalLoggerQueue</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>先看初始化方法 <code>init</code> ：</p>
<h3 id="init">Init</h3>
<p>AdstractLogger 默认提供了 loggerQueue 以及当前是否为 loggerQueue 和 全局 loggingQueue 的 convene 方法。loggerQueue 的初始化是在 <code>init</code> 中完成的，整个 <code>init</code> 也就做了这一件事。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">loggerQueueName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">loggerName</span><span class="p">)])</span> <span class="p">{</span>
    <span class="n">loggerQueueName</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">loggerName</span><span class="p">.</span><span class="n">UTF8String</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">_loggerQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="n">loggerQueueName</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">nonNullValue</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">;</span>
<span class="n">dispatch_queue_set_specific</span><span class="p">(</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">nonNullValue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>同样先获取 queueName，这里默认返回的 <code>loggerName</code> 是 <code>NSStringFromClass([self class]);</code> 。</p>
<p>同时，以 self 的地址作为 flag 关联到 loggerQueue，并用于判断 <code>onInternalLoggerQueue</code> 。</p>
<h3 id="logformatter">LogFormatter</h3>
<p>AdstractLogger 最主要的是实现了 logFormatter 的 getter/setter 方法。同时代码中赋予了十分详细的说明，先看看 getter 实现。</p>
<p><strong>Getter</strong></p>
<p>首先是线程相关的断言，确保当前不在 global queue 和 loggerQueue：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">NSAssert</span><span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="n">isOnGlobalLoggingQueue</span><span class="p">],</span> <span class="s">@&#34;Core architecture requirement failure&#34;</span><span class="p">);</span>
<span class="n">NSAssert</span><span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="n">isOnInternalLoggerQueue</span><span class="p">],</span> <span class="s">@&#34;MUST access ivar directly, NOT via self.* syntax.&#34;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>接着在 loggingQueue 和 loggerQueue 中获取 logFormatter：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="n">dispatch_queue_t</span> <span class="n">globalLoggingQueue</span> <span class="o">=</span> <span class="p">[</span><span class="n">DDLog</span> <span class="n">loggingQueue</span><span class="p">];</span>

<span class="k">__block</span> <span class="kt">id</span> <span class="o">&lt;</span><span class="n">DDLogFormatter</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="n">dispatch_sync</span><span class="p">(</span><span class="n">globalLoggingQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">dispatch_sync</span><span class="p">(</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>看去一个普通的 formatter 为何需要如此大动干戈，需要层层深入来呢？我们来看一段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">DDLogVerbose</span><span class="p">(</span><span class="s">@&#34;log msg 1&#34;</span><span class="p">);</span>
<span class="n">DDLogVerbose</span><span class="p">(</span><span class="s">@&#34;log msg 2&#34;</span><span class="p">);</span>
<span class="p">[</span><span class="n">logger</span> <span class="nl">setFormatter</span><span class="p">:</span><span class="n">myFormatter</span><span class="p">];</span>
<span class="n">DDLogVerbose</span><span class="p">(</span><span class="s">@&#34;log msg 3&#34;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>从直觉上，我们希望看到的结果是新设置的 formatter 仅应用在第 3 条 log message 上。然而 DDLog 在整个 logging 过程中却都是异步调用的。</p>
<ol>
<li>log message 最终是在单独的 loggerQueue 中执行的，是由 logger 各自持有的 queue；</li>
<li>在进入每个 loggerQueue 之前，又要经过一道全局的 loggingQueue。</li>
</ol>
<p>So，想要线程安全又要符合直觉的话，只能遵循 log message 的脚步，走一遍相关 queue。</p>
<p>需要强调一点，logger在内部<strong>最好直接访问 FORMATTER VARIABLE</strong> ，如果需要的话。一旦使用 <code>self.</code>  可能会导致线程死锁。</p>
<p><strong>Setter</strong></p>
<p>同 getter 一致，先断言，然后依次进入队列 <code>DDLog.loggingQueue -&gt; self-&gt;_loggerQueue</code> 执行 block 开始真正的赋值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="k">@autoreleasepool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="o">!=</span> <span class="n">logFormatter</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">willRemoveFromLogger</span><span class="p">:)])</span> <span class="p">{</span>
            <span class="p">[</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="nl">willRemoveFromLogger</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="o">=</span> <span class="n">logFormatter</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">([</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">didAddToLogger</span><span class="p">:</span><span class="nl">inQueue</span><span class="p">:)])</span> <span class="p">{</span>
            <span class="p">[</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="nl">didAddToLogger</span><span class="p">:</span><span class="nb">self</span> <span class="nl">inQueue</span><span class="p">:</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_loggerQueue</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">didAddToLogger</span><span class="p">:)])</span> <span class="p">{</span>
            <span class="p">[</span><span class="nb">self</span><span class="o">-&gt;</span><span class="n">_logFormatter</span> <span class="nl">didAddToLogger</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="ddasllogger">DDASLLogger</h2>
<p>ASLLogger 是对 <strong>Apple System Log</strong> API 的封装，我们经常使用的 <code>NSLog</code> 会将其输出定向到两个地方：</p>
<ul>
<li><a href="https://support.apple.com/zh-cn/guide/console/cnsl1012/mac">Apple System Log</a></li>
<li><a href="https://www.wikiwand.com/en/Standard_streams">Standard error</a> （telemetry）</li>
</ul>
<p>不过 ASLLogger 在 macosx 10.12 iOS 10.0 已经被废弃了，取而代之的是 DDOSLoger。ASLLogger 背后使用的 API 是 <a href="https://opensource.apple.com/source/Libc/Libc-583/include/asl.h.auto.html"><strong>&lt;asl.h&gt;</strong></a> ，它也提供了几种 message level</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="cm">/*! @defineblock Log Message Priority Levels Log levels of the message. */</span>
<span class="cp">#define ASL_LEVEL_EMERG   0
</span><span class="cp">#define ASL_LEVEL_ALERT   1
</span><span class="cp">#define ASL_LEVEL_CRIT    2 </span><span class="c1">// DDLogFlagError
</span><span class="c1"></span><span class="cp">#define ASL_LEVEL_ERR     3 </span><span class="c1">// DDLogFlagWarning
</span><span class="c1"></span><span class="cp">#define ASL_LEVEL_WARNING 4 </span><span class="c1">// DDLogFlagInfo, Regular NSLog&#39;s level
</span><span class="c1"></span><span class="cp">#define ASL_LEVEL_NOTICE  5 </span><span class="c1">// default
</span><span class="c1"></span><span class="cp">#define ASL_LEVEL_INFO    6
</span><span class="cp">#define ASL_LEVEL_DEBUG   7
</span></code></pre></td></tr></table>
</div>
</div><p>默认情况下 ASL 会过滤 NOTICE 之上的信息，这也是为何 DDLog 基本也就设置了 5 种日志级别。</p>
<h3 id="logmessage">logMessage</h3>
<p>logMessage 是每个 logger 处理 log message 的方法。ASLLogger 首先会过滤 filename 为 <code>DDASLLogCapture</code> (主动监听的系统 log)。然后对 message 进行 formate：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objc" data-lang="objc"><span class="n">NSString</span> <span class="o">*</span> <span class="n">message</span> <span class="o">=</span> <span class="n">_logFormatter</span> <span class="o">?</span> <span class="p">[</span><span class="n">_logFormatter</span> <span class="nl">formatLogMessage</span><span class="p">:</span><span class="n">logMessage</span><span class="p">]</span> <span class="o">:</span> <span class="n">logMessage</span><span class="o">-&gt;</span><span class="n">_message</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果 message 存在，生成 <code>aslmsg</code>  通过 <code>asl_send</code> 发送至 ASL。实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="n">message</span> <span class="n">UTF8String</span><span class="p">];</span>
<span class="n">size_t</span> <span class="n">aslLogLevel</span><span class="p">;</span> <span class="c1">// logMessage-&gt;_flag 获取 ASL_LEVEL_XXX
</span><span class="c1"></span>
<span class="k">static</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="k">const</span> <span class="n">level_strings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;0&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">,</span> <span class="s">&#34;4&#34;</span><span class="p">,</span> <span class="s">&#34;5&#34;</span><span class="p">,</span> <span class="s">&#34;6&#34;</span><span class="p">,</span> <span class="s">&#34;7&#34;</span> <span class="p">};</span>

<span class="n">uid_t</span> <span class="k">const</span> <span class="n">readUID</span> <span class="o">=</span> <span class="n">geteuid</span><span class="p">();</span> <span class="c1">/// the effective user ID of the calling process
</span><span class="c1"></span>
<span class="kt">char</span> <span class="n">readUIDString</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="c1">/// formatted output conversion
</span><span class="c1"></span><span class="cp">#ifndef NS_BLOCK_ASSERTIONS
</span><span class="cp"></span><span class="n">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">snprintf</span><span class="p">(</span><span class="n">readUIDString</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">readUIDString</span><span class="p">),</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">readUID</span><span class="p">);</span>
<span class="cp">#else
</span><span class="cp"></span><span class="n">snprintf</span><span class="p">(</span><span class="n">readUIDString</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">readUIDString</span><span class="p">),</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">readUID</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>
<span class="n">NSAssert</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">readUIDString</span><span class="p">),</span> <span class="s">@&#34;Formatted euid is too long.&#34;</span><span class="p">);</span>
<span class="n">NSAssert</span><span class="p">(</span><span class="n">aslLogLevel</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">level_strings</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">level_strings</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="s">@&#34;Unhandled ASL log level.&#34;</span><span class="p">);</span>

<span class="n">aslmsg</span> <span class="n">m</span> <span class="o">=</span> <span class="n">asl_new</span><span class="p">(</span><span class="n">ASL_TYPE_MSG</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">asl_set</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ASL_KEY_LEVEL</span><span class="p">,</span> <span class="n">level_strings</span><span class="p">[</span><span class="n">aslLogLevel</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">asl_set</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ASL_KEY_MSG</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">asl_set</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ASL_KEY_READ_UID</span><span class="p">,</span> <span class="n">readUIDString</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">asl_set</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">kDDASLKeyDDLog</span><span class="p">,</span> <span class="n">kDDASLDDLogValue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">asl_send</span><span class="p">(</span><span class="n">_client</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">asl_free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="ddoslogger">DDOSLogger</h2>
<p>苹果的新一代 logging system <a href="https://developer.apple.com/documentation/os/logging">os_log</a>，官方提供了比较完整的概述和说明。正是它取代了 ASL，manual 如下：</p>
<blockquote>
<p>The unified logging system provides a single, efficient, high performance set of APIs for capturing log messages across all levels of the system.  This unified system centralizes the storage of log data in memory and in a data store on disk.</p>
</blockquote>
<p>它提供了日志记录的中心化存储。同时 API 也十分简洁，关于 os_log 有机会在展开。</p>
<h3 id="init-1">Init</h3>
<p>首先，OSLogger 需要持有一个 log object：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">os_log_t</span> <span class="nf">os_log_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">subsystem</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">category</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>subsystem</strong></p>
<blockquote>
<p>An identifier string, in reverse DNS notation, that represents the subsystem that’s performing logging, for example, <code>com.your_company.your_subsystem_name</code>. The subsystem is used for categorization and filtering of related log messages, as well as for grouping related logging settings.</p>
</blockquote>
<p><strong>category</strong></p>
<blockquote>
<p>A category within the specified subsystem. The system uses the category to categorize and filter related log messages, as well as to group related logging settings within the subsystem’s settings. A category’s logging settings override those of the parent subsystem.</p>
</blockquote>
<p>顺便说一下，os_log 的官方文档是只提供了 Swift 说明，OSLog.Category <a href="https://developer.apple.com/documentation/os/oslog/category">详细点此</a>。</p>
<h3 id="logmessage-1">LogMessage</h3>
<p>同样是过滤 filename 为 <code>DDASLLogCapture</code> 的 log message 和对 log message 的 formatter。os_log 所提供的 API 则十分友好简洁，每种 <a href="https://developer.apple.com/documentation/kernel/os_log_type_t?language=objc">os_log_type_t</a> 都提供了对应的方法，使用如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">__auto_type</span> <span class="n">logger</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">logger</span><span class="p">];</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">logMessage</span><span class="o">-&gt;</span><span class="n">_flag</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">DDLogFlagError</span>  <span class="p">:</span>
        <span class="n">os_log_error</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;%{public}s&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">DDLogFlagWarning</span><span class="p">:</span>
    <span class="k">case</span> <span class="nl">DDLogFlagInfo</span>   <span class="p">:</span>
        <span class="n">os_log_info</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;%{public}s&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">DDLogFlagDebug</span>  <span class="p">:</span>
    <span class="k">case</span> <span class="nl">DDLogFlagVerbose</span><span class="p">:</span>
    <span class="k">default</span>              <span class="o">:</span>
        <span class="n">os_log_debug</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="s">&#34;%{public}s&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="ddttylogger">DDTTYLogger</h2>
<blockquote>
<p>This class provides a logger for Terminal output or Xcode console output, depending on where you are running your code.</p>
</blockquote>
<p>通过它将日志定向到终端和 Xcode 终端，同时支持彩色。Xcode 支持需要添加 <a href="https://github.com/robbiehanson/XcodeColors">XcodeColors 插件</a>。TTYLogger 内部的代码有上千行。不过所做的事情比较简单。根据不同终端类型所支持的颜色范围来将设置的颜色进行适配，最终输出出来。</p>
<p>关于颜色范围主要有三种类型：</p>
<ul>
<li>standard shell：仅支持 16 种颜色</li>
<li>Terminal.app：可以支持到 256 种颜色</li>
<li>xterm colors</li>
</ul>
<p>具体见 <a href="http://en.wikipedia.org/wiki/ANSI_escape_code">ANSI_escape_code</a>。</p>
<h3 id="logmessage-2">LogMessage</h3>
<p>TTYLogger 支持为每一种 logFlag 配置不同的颜色，然后将 color 与 flag 封装进 <code>DDTTYLoggerColorProfile</code> 类中，存储在 <code>_colorProfilesDict</code> 中。logMessage 主要分三步：</p>
<ol>
<li>通过 <code>logMessage-&gt;_tag</code> 取出 colorProfile；</li>
<li>将 log message 转为 c string；</li>
<li>将 color 写入 <code>iovec v[iovec_len]</code>，最终调用 <code>writev(STDERR_FILENO, v, iovec_len);</code> 输出。</li>
</ol>
<h2 id="未完待续">未完待续</h2>
<p>以上三种 logger 属于基本的终端输出，可用于替代 NSLog。限于篇幅的原因，还有 <code>DDFileLogger</code>、<code>DDAbstractDatabaseLogger</code> 以及各种扩展，如 <code>WebSocketLogger</code> 等，未在本篇出现。同时还有一整节的 <code>Formatters</code> 均放下一篇中。</p>
<p>本篇，通过 DDLog 类对 GCD 的使用，看到了 lumberjack 的作者充分利用了 GCD 的特性来达到安全高效的异步 logging。整个过程中并未使用锁来解决线程安全，算是对 GCD 的很好实践了。该作者还出品了 <a href="https://github.com/robbiehanson/CocoaAsyncSocket">CocoaAsyncSocket</a> 、<a href="https://github.com/robbiehanson/XMPPFramework">XMPPFramework</a>、<a href="https://github.com/robbiehanson/CocoaHTTPServer">CocoaHTTPServer</a> 等知名的库。之后可以慢慢细品。</p>
<p>最后，贴一张整理的脑图，比较简单，不喜勿喷。</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cly1gdzcfyok9ij21ee12agqs.jpg" alt="CocoaLumberjack.png"></p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/source-code">Source Code</a>
     
    <a href="https://looseyi.github.io/tags/ios">iOS</a>
     
    <a href="https://looseyi.github.io/tags/logger">Logger</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-2/"><span>←</span><span>浅析 - CocoaLumberjack 3.6 之 FileLogger</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/"><span>The Architecture of SDWebImage v5.6</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
