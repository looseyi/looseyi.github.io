<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>浅析 - CocoaLumberjack 3.6 之 FileLogger - Aha Edmond</title>

  
  
  <meta name="description" content="DDFileLogger 继续上一篇：CocoaLumberjack 之 DDLog，重点介绍了 lumberjack 的核心管理类 DDLog 以及两个核心协议 DDLogger 和 DDLogFormatter。还涉及" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-2/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="浅析 - CocoaLumberjack 3.6 之 FileLogger" />
<meta property="og:description" content="DDFileLogger 继续上一篇：CocoaLumberjack 之 DDLog，重点介绍了 lumberjack 的核心管理类 DDLog 以及两个核心协议 DDLogger 和 DDLogFormatter。还涉及" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-08T23:20:00&#43;08:00" />
<meta property="article:modified_time" content="2020-05-08T23:20:00&#43;08:00" />


  
  <meta itemprop="name" content="浅析 - CocoaLumberjack 3.6 之 FileLogger">
<meta itemprop="description" content="DDFileLogger 继续上一篇：CocoaLumberjack 之 DDLog，重点介绍了 lumberjack 的核心管理类 DDLog 以及两个核心协议 DDLogger 和 DDLogFormatter。还涉及"><meta itemprop="datePublished" content="2020-05-08T23:20:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-08T23:20:00&#43;08:00" />
<meta itemprop="wordCount" content="5918">
<meta itemprop="keywords" content="Source Code,iOS,Logger," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅析 - CocoaLumberjack 3.6 之 FileLogger"/>
<meta name="twitter:description" content="DDFileLogger 继续上一篇：CocoaLumberjack 之 DDLog，重点介绍了 lumberjack 的核心管理类 DDLog 以及两个核心协议 DDLogger 和 DDLogFormatter。还涉及"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-05-08</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>浅析 - CocoaLumberjack 3.6 之 FileLogger</h1>
  </header>
  <section class="post-content"><h1 id="ddfilelogger">DDFileLogger</h1>
<p>继续上一篇：<a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3#heading-20">CocoaLumberjack 之 DDLog</a>，重点介绍了 lumberjack 的核心管理类 DDLog 以及两个核心协议 <a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3#heading-7">DDLogger</a> 和 <a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3#heading-8">DDLogFormatter</a>。还涉及了基于 DDLogger 协议的抽象类 <a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3#heading-15">DDAbstractLogger</a>，以及基于 DDAbstractLogger 派生的分别针对系统日志 API <strong><a href="https://opensource.apple.com/source/Libc/Libc-583/include/asl.h.auto.html">ASL</a></strong> 和 <strong><a href="https://developer.apple.com/documentation/os/logging">os_log</a></strong> 的封装类 <a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3#heading-18">DDASLLogger</a> 与 <a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3#heading-20">DDOSLogger</a>。</p>
<p>本文将会继续介绍基于 DDLogger 的应用类 <strong>DDFileLogger</strong>。</p>
<h2 id="log-file">Log File</h2>
<p>关于日志文件，这里贴一下 wiki 描述：</p>
<blockquote>
<p>In <a href="https://www.wikiwand.com/en/Computing">computing</a>, a <strong>log file</strong> is a file that records either <a href="https://www.wikiwand.com/en/Event_(computing)">events</a> that occur in an <a href="https://www.wikiwand.com/en/Operating_system">operating system</a> or other <a href="https://www.wikiwand.com/en/Software">software</a> runs,[<a href="https://www.wikiwand.com/en/Log_file#citenote1">1]</a> or messages between different users of a <a href="https://www.wikiwand.com/en/Internet_chat">communication software</a>.</p>
</blockquote>
<p>可能部分新手同学对日志文件的重要性没有很强的认识，尤其是移动端。毕竟，我们大部分的时间 force 在 crash log、console log 和 event log 中，而这些 log 基本上是以日志文件来存储。除此之外，我们可能也会主动添加一些关键节点的日志，以方便定位和解决问题。因此，如何保证日志文件的的完整性和准确性就非常重要了。</p>
<p>对于 logging file 简单能联想到的有两点：</p>
<ol>
<li>log message 的文件写入，以及何时进行滚动地记录文件；</li>
<li>日志文件管理，当日志写入结束后需要考虑文件压缩以节约磁盘，以及日志上传。</li>
</ol>
<p>刚好分别对应了 <code>DDFileLogger</code> 主要涉及文件写入，<code>DDLogFileManager</code> 负责文件管理。</p>
<h2 id="init">Init</h2>
<p>先看初始化方式：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithLogFileManager:</span>(<span style="color:#dc322f">id</span> <span style="color:#719e07">&lt;</span>DDLogFileManager<span style="color:#719e07">&gt;</span>)<span style="color:#268bd2">logFileManager</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>                       <span style="color:#268bd2">completionQueue:</span>(nullable dispatch_queue_t)<span style="color:#268bd2">dispatchQueue</span>;
</code></pre></div><p>作为 NS_DESIGNATED_INITIALIZER，logFileManager 是必须要提供的，如果直接通过 <code>- (**instancetype**)init</code> 初始化会主动 new 出 <code>DDLogFileManagerDefault</code> 当作默认值。completionQueue 默认为 DEFAULT 优先级，完整实现如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>_completionQueue <span style="color:#719e07">=</span> dispatchQueue <span style="color:#719e07">?:</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span style="color:#2aa198">0</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>_maximumFileSize <span style="color:#719e07">=</span> kDDDefaultLogMaxFileSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>_rollingFrequency <span style="color:#719e07">=</span> kDDDefaultLogRollingFrequency;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>_automaticallyAppendNewlineForCustomFormatters <span style="color:#719e07">=</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>_logFileManager <span style="color:#719e07">=</span> aLogFileManager;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>_logFormatter <span style="color:#719e07">=</span> [DDLogFileFormatterDefault new];
</code></pre></div><h2 id="file-rollinghttpswwwwikiwandcomenlog_rotation"><a href="https://www.wikiwand.com/en/Log_rotation">File Rolling</a></h2>
<p>也称为 log rotation，wiki 解释：</p>
<blockquote>
<p>In <a href="https://www.wikiwand.com/en/Information_technology">information technology</a>, <strong>log rotation</strong> is an automated process used in <a href="https://www.wikiwand.com/en/System_administration">system administration</a> in which <a href="https://www.wikiwand.com/en/Computer_data_logging">log files</a> are compressed, moved (<a href="https://www.wikiwand.com/en/Archive">archived</a>), renamed or deleted once they are too old or too big (there can be other metrics that can apply here). New incoming log data is directed into a new fresh file (at the same location)[<a href="https://www.wikiwand.com/en/Log_rotation#citenote1">1]</a>.</p>
</blockquote>
<p>日志轮替算是系统级别的常规操作策略，在 Linux 中是有专门的命令 <a href="https://linux.die.net/man/8/logrotate">logrotate</a> 来实现，macOS 上对应的则是 <a href="https://man.freebsd.org/newsyslog.conf/5">newsyslog</a>。根据 mac manual 文档说明，log 文件的轮替归档需要满足三个条件：</p>
<ol>
<li>It is larger than the configured size (in kilobytes).</li>
<li>A configured number of hours have elapsed since the log was last archived.</li>
<li>This is the specific configured hour for rotation of the log.</li>
</ol>
<p>对应 DDFileLogger 中刚好两个属性：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">readwrite</span>, <span style="color:#719e07">assign</span>) <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> <span style="color:#dc322f">long</span> maximumFileSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">readwrite</span>, <span style="color:#719e07">assign</span>) NSTimeInterval rollingFrequency;
</code></pre></div><p>lumberjack 中轮替相关的默认值如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">/// 默认日志文件 size 上限
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span><span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> <span style="color:#dc322f">long</span> <span style="color:#719e07">const</span> kDDDefaultLogMaxFileSize      <span style="color:#719e07">=</span> <span style="color:#2aa198">1024</span> <span style="color:#719e07">*</span> <span style="color:#2aa198">1024</span>; <span style="color:#586e75">// 1 MB
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75">/// 默认日志文件分割间隔（执行轮替的间隔）
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>NSTimeInterval     <span style="color:#719e07">const</span> kDDDefaultLogRollingFrequency <span style="color:#719e07">=</span> <span style="color:#2aa198">60</span> <span style="color:#719e07">*</span> <span style="color:#2aa198">60</span> <span style="color:#719e07">*</span> <span style="color:#2aa198">24</span>; <span style="color:#586e75">// 24 Hours
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75">/// 默认最大日志文件分割数量
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"></span>NSUInteger         <span style="color:#719e07">const</span> kDDDefaultLogMaxNumLogFiles   <span style="color:#719e07">=</span> <span style="color:#2aa198">5</span>; <span style="color:#586e75">// 5 Files
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75">/// 默认日志文件整体磁盘配额
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span><span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> <span style="color:#dc322f">long</span> <span style="color:#719e07">const</span> kDDDefaultLogFilesDiskQuota   <span style="color:#719e07">=</span> <span style="color:#2aa198">20</span> <span style="color:#719e07">*</span> <span style="color:#2aa198">1024</span> <span style="color:#719e07">*</span> <span style="color:#2aa198">1024</span>; <span style="color:#586e75">// 20 MB
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75">/// 日志文件滚动计时器更新频率
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span>NSTimeInterval     <span style="color:#719e07">const</span> kDDRollingLeeway              <span style="color:#719e07">=</span> <span style="color:#2aa198">1.0</span>; <span style="color:#586e75">// 1s
</span></code></pre></div><p>对于 <code>maximumFileSize</code> 与 <code>rollingFrequency</code> ，它们两个条件只要满足一者就会触发 log rolling。需要注意的是，一旦触发 rolling 后，会重置这两个状态。例如：<code>rollingFrequency</code> 默认为 24 h，但是 log file 仅在 20 h 的时候就超过了 <code>maximumFileSize</code> 限制，那么就会触发 rolling，并重启一个 24 h 的 timer。</p>
<p>如果希望仅按照 <code>rollingFrequency</code> 作为控制条件，可以设置 <code>maximumFileSize</code> 为 zero。同理，可以设置  <code>rollingFrequency</code> 为 zero 来达到 disable 的作用。</p>
<p>另外，rolling 中还提供了 <code>doNotReuseLogFiles</code> 来控制，是否允许复用上一次运行时写入的 log file。默认为</p>
<p>NO，如果设置为 YES，则每启动都会新生成一次 log file。</p>
<h3 id="lt_mayberolllogfileduetosize">lt_maybeRollLogFileDueToSize</h3>
<p>先来看看 <code>rollLogFile by size </code> 的情况。当修改 <code>maximumFileSize</code> 时会触发 <code>lt_maybeRollLogFileDueToSize</code>，<code>setMaximumFileSize:</code> 实现如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_block_t block <span style="color:#719e07">=</span> <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#b58900">self</span><span style="color:#719e07">-&gt;</span>_maximumFileSize <span style="color:#719e07">=</span> newMaximumFileSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        [<span style="color:#b58900">self</span> lt_maybeRollLogFileDueToSize];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>NSAssert(<span style="color:#719e07">!</span>[<span style="color:#b58900">self</span> isOnGlobalLoggingQueue], <span style="color:#2aa198">@&#34;Core architecture requirement failure&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>NSAssert(<span style="color:#719e07">!</span>[<span style="color:#b58900">self</span> isOnInternalLoggerQueue], <span style="color:#2aa198">@&#34;MUST access ivar directly, NOT via self.* syntax.&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>dispatch_queue_t globalLoggingQueue <span style="color:#719e07">=</span> [DDLog loggingQueue];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>dispatch_async(globalLoggingQueue, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    dispatch_async(<span style="color:#b58900">self</span>.loggerQueue, block);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>});
</code></pre></div><p>最终会在 loggerQueue 中调用 block 以触发 <code>lt_maybeRollLogFileDueToSize</code>。上述代码为何要通过两层的 queue 的嵌套以及 loggingQueue 和 loggerQueue 的说明都在上一篇又详细的解释。来看 <code>lt_maybeRollLogFileDueToSize</code> 实现：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>NSAssert([<span style="color:#b58900">self</span> isOnInternalLoggerQueue], <span style="color:#2aa198">@&#34;lt_ methods should be on logger queue.&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">if</span> (_maximumFileSize <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> <span style="color:#dc322f">long</span> fileSize <span style="color:#719e07">=</span> [_currentLogFileHandle offsetInFile];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (fileSize <span style="color:#719e07">&gt;=</span> _maximumFileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        NSLogVerbose(<span style="color:#2aa198">@&#34;DDFileLogger: Rolling log file due to size (%qu)...&#34;</span>, fileSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        [<span style="color:#b58900">self</span> lt_rollLogFileNow];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
</code></pre></div><ol>
<li>首页是断言对 loggerQueue 的环境检查；</li>
<li>作者通过对 <code>_maximumFileSize &gt; 0</code> 来控制是否开启 log 大小检查。_currentLogFileHandle 是当前所写入 log file 的文件操作符（之后简称为 <strong>fd</strong> ：file descriptor）为 <code>NSFileHandle</code> 类；</li>
<li>当文件超限时，执行 <code>lt_rollLogFileNow</code> ；</li>
</ol>
<h3 id="lt_mayberolllogfileduetoage">lt_maybeRollLogFileDueToAge</h3>
<p>同 <code>setMaximumFileSize:</code> 类似，修改 <code>rollingFrequency</code> 会在 block 中触发 <code>lt_maybeRollLogFileDueToAge</code>：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSAssert([<span style="color:#b58900">self</span> isOnInternalLoggerQueue], <span style="color:#2aa198">@&#34;lt_ methods should be on logger queue.&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">if</span> (_rollingFrequency <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0.0</span> <span style="color:#719e07">&amp;&amp;</span> (_currentLogFileInfo.age <span style="color:#719e07">+</span> kDDRollingLeeway) <span style="color:#719e07">&gt;=</span> _rollingFrequency) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    NSLogVerbose(<span style="color:#2aa198">@&#34;DDFileLogger: Rolling log file due to age...&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    [<span style="color:#b58900">self</span> lt_rollLogFileNow];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    [<span style="color:#b58900">self</span> lt_scheduleTimerToRollLogFileDueToAge];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p>同样是检查环境，检查 <code>_rollingFrequency &gt; 0.0</code> 以及 log file 的创建时间是否超限。如果轮替时间超限则开始轮替。否则会重置 rollingTimer 下一次轮替的 delay 时间。</p>
<h3 id="lt_scheduletimertorolllogfileduetoage">lt_scheduleTimerToRollLogFileDueToAge</h3>
<p>这里的定时器使用的是 <code>  dispatch_source_t</code> 。首先将当前 timer invalid 然后检查 _currentLogFileInfo 和 _rollingFrequency：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (_rollingTimer) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    dispatch_source_cancel(_rollingTimer);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    _rollingTimer <span style="color:#719e07">=</span> <span style="color:#b58900">NULL</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">if</span> (_currentLogFileInfo <span style="color:#719e07">==</span> <span style="color:#b58900">nil</span> <span style="color:#719e07">||</span> _rollingFrequency <span style="color:#719e07">&lt;=</span> <span style="color:#2aa198">0.0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>}
</code></pre></div><p>然后是重新生成 timer 并设置 event handler：</p>
<ol>
<li>
<p>获取文件创建时间，计算下一次轮替的触发时间 logFileRollingDate；</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSDate <span style="color:#719e07">*</span>logFileCreationDate <span style="color:#719e07">=</span> [_currentLogFileInfo creationDate];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>NSTimeInterval frequency <span style="color:#719e07">=</span> MIN(_rollingFrequency, DBL_MAX <span style="color:#719e07">-</span> [logFileCreationDate timeIntervalSinceReferenceDate]);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>NSDate <span style="color:#719e07">*</span>logFileRollingDate <span style="color:#719e07">=</span> [logFileCreationDate dateByAddingTimeInterval:frequency];
</code></pre></div></li>
<li>
<p>依据 logFileRollingDate 和当前时间计算dely，初始化 _rollingTimer 并设置 evenhandler；</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>_rollingTimer <span style="color:#719e07">=</span> dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span style="color:#2aa198">0</span>, <span style="color:#2aa198">0</span>, _loggerQueue);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">__weak</span> __auto_type weakSelf <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>dispatch_source_set_event_handler(_rollingTimer, <span style="color:#719e07">^</span>{ <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    [weakSelf lt_maybeRollLogFileDueToAge];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>} });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75">//... 兼容 MRC，设置 dispatch_source_t release 回调
</span></code></pre></div></li>
<li>
<p>设置 kDDRollingLeeway 作为定时器刷新间隔，delay 为触发时间，开始计时；</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">static</span> NSTimeInterval <span style="color:#719e07">const</span> kDDMaxTimerDelay <span style="color:#719e07">=</span> LLONG_MAX <span style="color:#719e07">/</span> NSEC_PER_SEC;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>int64_t delay <span style="color:#719e07">=</span> (int64_t)(MIN([logFileRollingDate timeIntervalSinceNow], kDDMaxTimerDelay) <span style="color:#719e07">*</span> (NSTimeInterval) NSEC_PER_SEC);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>dispatch_time_t fireTime <span style="color:#719e07">=</span> dispatch_time(DISPATCH_TIME_NOW, delay);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>dispatch_source_set_timer(_rollingTimer, fireTime, DISPATCH_TIME_FOREVER, (uint64_t)kDDRollingLeeway <span style="color:#719e07">*</span> NSEC_PER_SEC);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">if</span> (@available(macOS <span style="color:#2aa198">10.12</span>, iOS <span style="color:#2aa198">10.0</span>, tvOS <span style="color:#2aa198">10.0</span>, watchOS <span style="color:#2aa198">3.0</span>, <span style="color:#719e07">*</span>))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    dispatch_activate(_rollingTimer);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">else</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#268bd2">dispatch_resume</span>(_rollingTimer);
</code></pre></div></li>
</ol>
<h3 id="lt_rolllogfilenow">lt_rollLogFileNow</h3>
<p>整个 fileLogger 的文件写入操作均基于 fd，而 fd 的获取是通过 lazy 的方式。如果 fd 为空， rollLogFile will do nothing。而日志轮替做的事情也比较清晰：</p>
<ol>
<li>同步并关闭 fd，同时将文件标记为 <strong>Archived</strong>;</li>
<li>向 fileManger 发送日志轮替通知；</li>
<li>清理 log file 文件变更状态监听，invalid rollingTime；</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">if</span> (_currentLogFileHandle <span style="color:#719e07">==</span> <span style="color:#b58900">nil</span>) { <span style="color:#719e07">return</span>; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>[_currentLogFileHandle synchronizeFile];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>[_currentLogFileHandle closeFile];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>_currentLogFileHandle <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>_currentLogFileInfo.isArchived <span style="color:#719e07">=</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#dc322f">BOOL</span> logFileManagerRespondsToSelector <span style="color:#719e07">=</span> [_logFileManager respondsToSelector:<span style="color:#719e07">@selector</span>(didRollAndArchiveLogFile:)];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>NSString <span style="color:#719e07">*</span>archivedFilePath <span style="color:#719e07">=</span> (logFileManagerRespondsToSelector) <span style="color:#719e07">?</span> [_currentLogFileInfo.filePath <span style="color:#719e07">copy</span>] <span style="color:#719e07">:</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>_currentLogFileInfo <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">if</span> (logFileManagerRespondsToSelector) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    dispatch_async(_completionQueue, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        [<span style="color:#b58900">self</span><span style="color:#719e07">-&gt;</span>_logFileManager didRollAndArchiveLogFile:archivedFilePath];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span><span style="color:#719e07">if</span> (_currentLogFileVnode) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    dispatch_source_cancel(_currentLogFileVnode);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    _currentLogFileVnode <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span><span style="color:#719e07">if</span> (_rollingTimer) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    dispatch_source_cancel(_rollingTimer);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>    _rollingTimer <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>}
</code></pre></div><p><strong>isArchived</strong> 在 fileInfo 中是如何保存这个状态的呢？</p>
<p>这里利用系统 API <a href="https://opensource.apple.com/source/xnu/xnu-1504.15.3/bsd/sys/xattr.h.auto.html">&lt;sys/xattr.h&gt;</a> 的 <strong>setxattr</strong>方法将该 flag 直接保存在文件描述中，<strong>getxattr</strong> 用来获取 flag，<strong>removexattr</strong> 用于删除 flag。这个在年初的文章 <a href="https://juejin.im/post/5e63d5a9f265da5729789ac3#heading-8">《浅析 SDWebImage 5.6》</a> 中也提到过，SD 也是用它来存储额外信息的。</p>
<h2 id="ddlogfileinfo">DDLogFileInfo</h2>
<p>前面的代码中已经接触过部分 fileInfo 的 property 了，正式介绍一下：</p>
<blockquote>
<p>A simple class that provides access to various file attributes. It provides good performance as it only fetches the information if requested, and it caches the information to prevent duplicate fetches.</p>
</blockquote>
<p>可以说 fileInfo 是保存了 log file 的首次访问时的快照，它追求的是性能而非时时性。最关键的属性是 fileAttributes</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>) NSDictionary<span style="color:#719e07">&lt;</span>NSFileAttributeKey, <span style="color:#dc322f">id</span><span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>fileAttributes;
</code></pre></div><p>像 <code>creationDate</code>、<code>modificationDate</code>、<code>fileSize</code>、<code>age</code> 均通过 <strong>NSFileAttributeKey</strong> 从它这获取的。既然是 lazy 又不更新，fileLogger 又是通过什么方式来准确获取真正的 fileSize 和增量更新 log file 呢？答案是 <strong>file descriptor</strong>：</p>
<table>
<thead>
<tr>
<th>method</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>offsetInFile</td>
<td>获取文件大小</td>
</tr>
<tr>
<td>synchronizeFile</td>
<td>内存数据写入磁盘</td>
</tr>
<tr>
<td>closeFile</td>
<td>关闭文件</td>
</tr>
<tr>
<td>seekToEndOfFile</td>
<td>将文件指针移动的末尾</td>
</tr>
</tbody>
</table>
<p>可见 fileLogger 始终通过唯一的 <strong>fd</strong> 来操作文件，从而提高读写效率。当然，还有更快的就是使用 mmap，像美团的 logan 和微信的 xlog。</p>
<p>最后，对于 <strong>setxattr</strong>、<strong>getxattr</strong>、<strong>removexattr</strong> 操作 fileInfo 提高了 convene method：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">BOOL</span>)<span style="color:#268bd2">hasExtendedAttributeWithName:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">attrName</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">addExtendedAttributeWithName:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">attrName</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">removeExtendedAttributeWithName:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">attrName</span>;
</code></pre></div><h2 id="ddlogger-protocol">DDLogger Protocol</h2>
<h3 id="logmessage">logMessage:</h3>
<p>将 log message 写入文件，经过 <code>lt_dataForMessage</code> 将 log mesage 转化为 NSData，最终调用 <code>lt_logData:</code>。</p>
<h3 id="flush">flush</h3>
<p>先经过 loggingQueue 和 loggerQueue 最终调用 block 内部的 <code>lt_flush</code>，而 <code>lt_flush</code> 就一行代码：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>[_currentLogFileHandle synchronizeFile];
</code></pre></div><h3 id="lt_logdata">lt_logData</h3>
<p>将 log message 转化过的 NSData 写入 file，代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@try</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    NSFileHandle <span style="color:#719e07">*</span>handle <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> lt_currentLogFileHandle];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    [handle seekToEndOfFile];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    [handle writeData:data];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>} <span style="color:#719e07">@catch</span> (NSException <span style="color:#719e07">*</span>exception) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    exception_count<span style="color:#719e07">++</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">if</span> (exception_count <span style="color:#719e07">&lt;=</span> <span style="color:#2aa198">10</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        NSLogError(<span style="color:#2aa198">@&#34;DDFileLogger.logMessage: %@&#34;</span>, exception);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#719e07">if</span> (exception_count <span style="color:#719e07">==</span> <span style="color:#2aa198">10</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            NSLogError(<span style="color:#2aa198">@&#34;DDFileLogger.logMessage: Too many exceptions -- will not log any more of them.&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>}
</code></pre></div><p>核心代码就三行，但是可以看到 lumberjack 的容错做的真心好，当异常数过多，就不停止输出了。</p>
<p>剩下的代码是对 deprecated 的 API 的兼容，算是目前看过对 deprecated API 十分友好的 lib 了。</p>
<p>首先对旧的 <code>willLogMessage</code> 和 <code>didLogMessage</code> 而言，新提供的 API 是增加了 fileInfo 作为返回值。然后用 <code>dispatch_once_t</code> 来避免多次响应者查询，以优化代码，毕竟 logMessage 可是一个高频调用的 API。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">static</span> <span style="color:#dc322f">BOOL</span> implementsDeprecatedWillLog <span style="color:#719e07">=</span> <span style="color:#b58900">NO</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">static</span> dispatch_once_t onceToken;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>dispatch_once(<span style="color:#719e07">&amp;</span>onceToken, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>implementsDeprecatedWillLog <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> respondsToSelector:<span style="color:#719e07">@selector</span>(willLogMessage)];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>});
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">if</span> (implementsDeprecatedWillLog) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    [<span style="color:#b58900">self</span> willLogMessage];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    [<span style="color:#b58900">self</span> willLogMessage:_currentLogFileInfo];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>}
</code></pre></div><p>同时还利用消息转发，将过期方法转移至 dummyMethod 避免 <code>unrecognized selector sent to instance</code> crash</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">dummyMethod</span> {}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>- (NSMethodSignature <span style="color:#719e07">*</span>)<span style="color:#268bd2">methodSignatureForSelector:</span>(<span style="color:#dc322f">SEL</span>)<span style="color:#268bd2">aSelector</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">if</span> (aSelector <span style="color:#719e07">==</span> <span style="color:#719e07">@selector</span>(willLogMessage) <span style="color:#719e07">||</span> aSelector <span style="color:#719e07">==</span> <span style="color:#719e07">@selector</span>(didLogMessage)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#586e75">// Ignore calls to deprecated methods.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"></span>        <span style="color:#719e07">return</span> [<span style="color:#b58900">self</span> methodSignatureForSelector:<span style="color:#719e07">@selector</span>(dummyMethod)];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">return</span> [<span style="color:#b58900">super</span> methodSignatureForSelector:aSelector];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">forwardInvocation:</span>(NSInvocation <span style="color:#719e07">*</span>)<span style="color:#268bd2">anInvocation</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">if</span> (anInvocation.selector <span style="color:#719e07">!=</span> <span style="color:#719e07">@selector</span>(dummyMethod)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        [<span style="color:#b58900">super</span> forwardInvocation:anInvocation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>}
</code></pre></div><h2 id="file-logging">File Logging</h2>
<p>整个 file logging 相关方法是对 fileHandle 和 fileInfo 的各种状态判断以及更新。</p>
<h3 id="lt_currentlogfilehandle">lt_currentLogFileHandle</h3>
<p>_currentLogFileHandle 通过 layze 方式获取。当 <code>lt_rollLogFileNow</code> 成功后会将 _currentLogFileHandle 置 nil。创建逻辑如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSString <span style="color:#719e07">*</span>logFilePath <span style="color:#719e07">=</span> [[<span style="color:#b58900">self</span> lt_currentLogFileInfo] filePath];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>_currentLogFileHandle <span style="color:#719e07">=</span> [NSFileHandle fileHandleForWritingAtPath:logFilePath];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>[_currentLogFileHandle seekToEndOfFile];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">if</span> (_currentLogFileHandle) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    [<span style="color:#b58900">self</span> lt_scheduleTimerToRollLogFileDueToAge];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    [<span style="color:#b58900">self</span> lt_monitorCurrentLogFileForExternalChanges];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><ol>
<li>通过 <code>lt_currentLogFileInfo</code> 获取 filePath 生成 _currentLogFileHandle 并将文件指针置文章末尾；</li>
<li>创建成功后重置 rolling 定时器，并开启 GCD 监听 _currentLogFileHandle；</li>
</ol>
<h3 id="lt_monitorcurrentlogfileforexternalchanges">lt_monitorCurrentLogFileForExternalChanges</h3>
<p>先是 _currentLogFileHandle 是否为空的断言，接着是设置 <code>dispatch_source_vnode_flags_t</code> 添加 event handler 回调：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_source_vnode_flags_t flags <span style="color:#719e07">=</span> DISPATCH_VNODE_DELETE <span style="color:#719e07">|</span> DISPATCH_VNODE_RENAME <span style="color:#719e07">|</span> DISPATCH_VNODE_REVOKE;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>_currentLogFileVnode <span style="color:#719e07">=</span> dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, (uintptr_t)[_currentLogFileHandle fileDescriptor], flags, _loggerQueue);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">__weak</span> __auto_type weakSelf <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>dispatch_source_set_event_handler(_currentLogFileVnode, <span style="color:#719e07">^</span>{ <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    NSLogInfo(<span style="color:#2aa198">@&#34;DDFileLogger: Current logfile was moved. Rolling it and creating a new one&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    [weakSelf lt_rollLogFileNow];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>} });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75">//... 兼容 MRC，设置 dispatch_source_t release 回调
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07">if</span> (@available(macOS <span style="color:#2aa198">10.12</span>, iOS <span style="color:#2aa198">10.0</span>, tvOS <span style="color:#2aa198">10.0</span>, watchOS <span style="color:#2aa198">3.0</span>, <span style="color:#719e07">*</span>))
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    dispatch_activate(_currentLogFileVnode);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#719e07">else</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#268bd2">dispatch_resume</span>(_currentLogFileVnode);
</code></pre></div><h3 id="lt_currentlogfileinfo">lt_currentLogFileInfo</h3>
<p>获取当前是否存在可用的 fileInfo。检查条件如下：</p>
<ol>
<li>取出 <code>logsDirectory</code> 中的 log 文件列表，并转化为 DDLogFileInfo。文件需要满足以 <code>.log</code> 结尾；</li>
<li>对转化后的 fileInfo 进行排序，取出最近时间的做为 <code>newCurrentLogFile</code>；</li>
<li>如果 <code>newCurrentLogFile</code> 存在，检查其可用性。如不可用则会通过 fileManger 创建新的 fileInfo；</li>
</ol>
<p>实现这里就不贴出了，接着来看检查条件。</p>
<h3 id="lt_shoulduselogfile-isresuming">lt_shouldUseLogFile: isResuming</h3>
<p>isResuming 是从对上一步 <code>newCurrentLogFile</code> 可用性的判断中传入的参数：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Check if we&#39;re resuming and if so, get the first of the sorted log file infos.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">BOOL</span> isResuming <span style="color:#719e07">=</span> newCurrentLogFile <span style="color:#719e07">==</span> <span style="color:#b58900">nil</span>;
</code></pre></div><ol>
<li>
<p>先判定文件是否为已归档文件，已归档则不可用；</p>
</li>
<li>
<p>如果 <code>isResuming</code> 为 YES，即 fileInfo 是从磁盘文件中复用的，需要检查两个状态：</p>
<ol>
<li><code>_doNotReuseLogFiles</code> 是否允许复用上次运行的 log file；</li>
<li>通过 <code>lt_shouldLogFileBeArchived</code> 检查检查文件归档状态；</li>
</ol>
<p>一旦，_doNotReuseLogFiles 为 YES 或 文件已满足归档条件，则设置 <code>logFileInfo.isArchived = YES</code>，并通知 fileManager。</p>
</li>
<li>
<p>满足条件返回 YES；</p>
</li>
</ol>
<h3 id="lt_shouldlogfilebearchived">lt_shouldLogFileBeArchived</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">if</span> (mostRecentLogFileInfo.isArchived) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">NO</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>} <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> ([<span style="color:#b58900">self</span> shouldArchiveRecentLogFileInfo:mostRecentLogFileInfo]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>} <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> (_maximumFileSize <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">&amp;&amp;</span> mostRecentLogFileInfo.fileSize <span style="color:#719e07">&gt;=</span> _maximumFileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>} <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> (_rollingFrequency <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0.0</span> <span style="color:#719e07">&amp;&amp;</span> mostRecentLogFileInfo.age <span style="color:#719e07">&gt;=</span> _rollingFrequency) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">#if TARGET_OS_IPHONE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07"></span>    <span style="color:#719e07">if</span> (doesAppRunInBackground()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        NSFileProtectionType key <span style="color:#719e07">=</span> mostRecentLogFileInfo.fileAttributes[NSFileProtectionKey];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        <span style="color:#dc322f">BOOL</span> isUntilFirstAuth <span style="color:#719e07">=</span> [key isEqualToString:NSFileProtectionCompleteUntilFirstUserAuthentication];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#dc322f">BOOL</span> isNone <span style="color:#719e07">=</span> [key isEqualToString:NSFileProtectionNone];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        <span style="color:#719e07">if</span> (key <span style="color:#719e07">!=</span> <span style="color:#b58900">nil</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">!</span>isUntilFirstAuth <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">!</span>isNone) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            <span style="color:#719e07">return</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#719e07"></span><span style="color:#719e07">return</span> <span style="color:#b58900">NO</span>;
</code></pre></div><p>当 mostRecentLogFileInfo 不满足前四步检查，需要判断 App 是否在后台运行，并根据 NSFileProtectionKey 确认 log file 的读写权限。<code>doesAppRunInBackground</code> 通过 mainBundle 的 <code>UIBackgroundModes</code> 来获取。</p>
<p>为何要加这个判定条件呢？这就需要关注 log file 生成时说起。创建 log file 时会设置 logFileProtection。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (NSFileProtectionType)<span style="color:#268bd2">logFileProtection</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">if</span> (_defaultFileProtectionLevel.length <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        <span style="color:#719e07">return</span> _defaultFileProtectionLevel;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    } <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> (doesAppRunInBackground()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>        <span style="color:#719e07">return</span> NSFileProtectionCompleteUntilFirstUserAuthentication;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>        <span style="color:#719e07">return</span> NSFileProtectionCompleteUnlessOpen;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span>}
</code></pre></div><p><strong>NSFileProtectionCompleteUnlessOpen</strong></p>
<p>当设备被锁定时，各文件仍然能够进行创建，而已经打开的文件则可继续接受访问。利用这一机制，我们可以在后台完成各类相关任务——例如保存新数据或者更新数据库。</p>
<p><strong>NSFileProtectionCompleteUntilFirstUserAuthentication</strong></p>
<p>当设备引导完成后，对应文件可在用户输入密码后随时接受访问——即使是在设备被锁定的情况下。利用这种方式，您可以随时读取运行在后台的文件。</p>
<p>也就是说，App 运行在前台时，通过 NSFileProtectionCompleteUnlessOpen 来获取更多权限，而在后台则需要使用 NSFileProtectionCompleteUntilFirstUserAuthentication 来修饰。因此，当我们在后台的情况下从磁盘中恢复的 log file 却是 App 在前台的时候所生成的话，由于权限不同，我们只能将其 Archive 来重新生成新的 log file。</p>
<h1 id="ddlogfilemanager">DDLogFileManager</h1>
<p>fileManger 有对应一个的 protocol</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">DDLogFileManager</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@required</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">readwrite</span>, <span style="color:#719e07">assign</span>, <span style="color:#719e07">atomic</span>) NSUInteger maximumNumberOfLogFiles;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">readwrite</span>, <span style="color:#719e07">assign</span>, <span style="color:#719e07">atomic</span>) <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> <span style="color:#dc322f">long</span> logFilesDiskQuota;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">copy</span>) NSString <span style="color:#719e07">*</span>logsDirectory;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">strong</span>) NSArray<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>unsortedLogFilePaths;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">strong</span>) NSArray<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>unsortedLogFileNames;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">strong</span>) NSArray<span style="color:#719e07">&lt;</span>DDLogFileInfo <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>unsortedLogFileInfos;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">strong</span>) NSArray<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>sortedLogFilePaths;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">strong</span>) NSArray<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>sortedLogFileNames;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, <span style="color:#719e07">strong</span>) NSArray<span style="color:#719e07">&lt;</span>DDLogFileInfo <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>sortedLogFileInfos;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>- (nullable NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">createNewLogFileWithError:</span>(NSError <span style="color:#719e07">**</span>)<span style="color:#268bd2">error</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#719e07">@optional</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span><span style="color:#719e07">-</span> (<span style="color:#dc322f">void</span>)didArchiveLogFile:(NSString <span style="color:#719e07">*</span>)logFilePath NS_SWIFT_NAME(didArchiveLogFile(atPath:));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">didRollAndArchiveLogFile:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">logFilePath</span> NS_SWIFT_NAME(didRollAndArchiveLogFile(atPath:));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07">@end</span>
</code></pre></div><p>其默认实现类为 DDLogFileManagerDefault。</p>
<h2 id="ddlogfilemanagerdefault">DDLogFileManagerDefault</h2>
<p>所有创建的 logFile 都存储在 <code>logsDirectory</code> 目录下，文件名称格式为 <strong>&lt;bundle identifier&gt; &lt;date&gt; &lt;time&gt;.log</strong> ，例如:  <code>com.organization.myapp 2020-05-09 17-14.log</code> ，目录在 Mac 上为 <code>~/Library/Logs/&lt;Application Name&gt;</code>。iPhone 上为  <code>~/Library/Caches/Logs</code>。</p>
<p>managerDefault 基本围绕着 <code>_logsDirectory</code> 目录来管理文件。对其目录下的文件的基本操作等，这里不展开了。稍微提一点 <code>maximumNumberOfLogFiles</code>  和 <code>logFilesDiskQuota</code> 的控制是通过 KVO 来实现监听的。它们最终会触发 <code>deleteOldLogFiles</code> 。</p>
<h3 id="deleteoldlogfiles">deleteOldLogFiles</h3>
<p>由于是 I/O 操作，整个代码是放在 GCD 中以 <code>PRIORITY_DEFAULT</code> 执行的。基本逻辑如下：</p>
<ol>
<li>
<p>取出 log file 文件名中的 date 字符转为 date (转换失败则尝试从 fileAttributes 中获取)，然后进行排序。</p>
</li>
<li>
<p>计算 <code>logsDirectory</code> 目录下的所有 log 文件 size，并标记首个超出限制的文件 index；</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> <span style="color:#dc322f">long</span> used <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">for</span> (NSUInteger i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> sortedLogFileInfos.count; i<span style="color:#719e07">++</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>   DDLogFileInfo <span style="color:#719e07">*</span>info <span style="color:#719e07">=</span> sortedLogFileInfos[i];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>   used <span style="color:#719e07">+=</span> info.fileSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>   <span style="color:#719e07">if</span> (used <span style="color:#719e07">&gt;</span> diskQuota) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>       firstIndexToDelete <span style="color:#719e07">=</span> i;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>       <span style="color:#719e07">break</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
</code></pre></div></li>
<li>
<p>对比 <code>maxNumLogFiles</code> 和 <code>firstIndexToDelete</code> 最终确定要删除的文件范围：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (maxNumLogFiles) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>     <span style="color:#719e07">if</span> (firstIndexToDelete <span style="color:#719e07">==</span> NSNotFound) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>         firstIndexToDelete <span style="color:#719e07">=</span> maxNumLogFiles;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>     } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>         firstIndexToDelete <span style="color:#719e07">=</span> MIN(firstIndexToDelete, maxNumLogFiles);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span> }
</code></pre></div></li>
<li>
<p>如果 firstIndexToDelete 为第一个文件，仅仅删除第一个且未标记为 <strong>isArchived</strong> 的文件。</p>
</li>
<li>
<p>最后遍历 <code>sortedLogFileInfos</code> 从 <code>firstIndexToDelete</code> 开始删除。</p>
</li>
</ol>
<h2 id="ddlogfileformatterdefault">DDLogFileFormatterDefault</h2>
<p>fileLogger 中的 fileFormatter 仅仅是在每条 log message 前添加了 _timestamp 的前缀。</p>
<h1 id="buffering">Buffering</h1>
<p>lumberjack 为 DDFileLogger 提供了 buffer 的分类，通过 NSProxy 来实现的，用法也一如既往的简单：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>[DDLog addLogger:[_logger wrapWithBuffer]];
</code></pre></div><p>通过 <code>wrapWithBuffer</code> 返回的是 <code>DDBufferedProxy</code> 类：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>(DDFileLogger <span style="color:#719e07">*</span>)[[DDBufferedProxy alloc] initWithFileLogger:<span style="color:#b58900">self</span>];
</code></pre></div><p>接着利用 <strong>Message Forwarding</strong> 将 DDBufferedProxy 未代理的方法通通转发回 fileLogger 处理：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>- (NSMethodSignature <span style="color:#719e07">*</span>)<span style="color:#268bd2">methodSignatureForSelector:</span>(<span style="color:#dc322f">SEL</span>)<span style="color:#268bd2">sel</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">return</span> [<span style="color:#b58900">self</span>.fileLogger methodSignatureForSelector:sel];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>- (<span style="color:#dc322f">BOOL</span>)<span style="color:#268bd2">respondsToSelector:</span>(<span style="color:#dc322f">SEL</span>)<span style="color:#268bd2">aSelector</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">return</span> [<span style="color:#b58900">self</span>.fileLogger respondsToSelector:aSelector];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">forwardInvocation:</span>(NSInvocation <span style="color:#719e07">*</span>)<span style="color:#268bd2">invocation</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    [invocation invokeWithTarget:<span style="color:#b58900">self</span>.fileLogger];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>}
</code></pre></div><p>作为 buffer 声明了哪些属性呢？</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">DDBufferedProxy</span> : <span style="color:#268bd2">NSProxy</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>) DDFileLogger <span style="color:#719e07">*</span>fileLogger;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>) NSOutputStream <span style="color:#719e07">*</span>buffer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>) NSUInteger maxBufferSizeBytes;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>) NSUInteger currentBufferSizeBytes;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">@end</span>
</code></pre></div><p>是的，BufferProxy 正是通过 <code>NSOutputStream</code> 将 log message 优先写入 memory 的方式作为过渡。那这 buffer  的预设值是多少呢 ？</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">static</span> <span style="color:#719e07">const</span> NSUInteger kDDDefaultBufferSize <span style="color:#719e07">=</span> <span style="color:#2aa198">4096</span>; <span style="color:#586e75">// 4 kB, block f_bsize on iphone7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#719e07">static</span> <span style="color:#719e07">const</span> NSUInteger kDDMaxBufferSize <span style="color:#719e07">=</span> <span style="color:#2aa198">1048576</span>; <span style="color:#586e75">// ~1 mB, f_iosize on iphone7
</span></code></pre></div><p>这两个默认值是基于 iPhone 7 上的 buffer size 来决定的。真实值取自 <a href="https://github.com/mstg/iOS-full-sdk/blob/master/iPhoneOS9.3.sdk/usr/include/sys/mount.h">&lt;sys/mount.h&gt;</a> API：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">static</span> <span style="color:#268bd2">inline</span> NSUInteger <span style="color:#268bd2">p_DDGetDefaultBufferSizeBytesMax</span>(<span style="color:#719e07">const</span> <span style="color:#dc322f">BOOL</span> max) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">struct</span> statfs <span style="color:#719e07">*</span>mountedFileSystems <span style="color:#719e07">=</span> <span style="color:#b58900">NULL</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#dc322f">int</span> count <span style="color:#719e07">=</span> getmntinfo(<span style="color:#719e07">&amp;</span>mountedFileSystems, <span style="color:#2aa198">0</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">for</span> (<span style="color:#dc322f">int</span> i <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; i <span style="color:#719e07">&lt;</span> count; i<span style="color:#719e07">++</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">struct</span> statfs mounted <span style="color:#719e07">=</span> mountedFileSystems[i];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">const</span> <span style="color:#dc322f">char</span> <span style="color:#719e07">*</span>name <span style="color:#719e07">=</span> mounted.f_mntonname;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#586e75">// We can use 2 as max here, since any length &gt; 1 will fail the if-statement.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span>        <span style="color:#719e07">if</span> (strnlen(name, <span style="color:#2aa198">2</span>) <span style="color:#719e07">==</span> <span style="color:#2aa198">1</span> <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">*</span>name <span style="color:#719e07">==</span> <span style="color:#2aa198">&#39;/&#39;</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>            <span style="color:#719e07">return</span> max <span style="color:#719e07">?</span> (NSUInteger)mounted.f_iosize : (NSUInteger)mounted.f_bsize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    <span style="color:#719e07">return</span> max <span style="color:#719e07">?</span> kDDMaxBufferSize : kDDDefaultBufferSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>}
</code></pre></div><p>核心是根据当前已挂载的文件系统的 <strong>f_iosize</strong> 和 <strong>f_bsize</strong>：</p>
<ul>
<li>f_iosize: 最佳传输 block 大小；</li>
<li>f_bsize: 基础文件系统 block 大小；</li>
</ul>
<p>读取不到的话就是基于 iPhone 7 提供的默认值作为 defaultBufferSize 和 maxBufferSize。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">static</span> NSUInteger <span style="color:#268bd2">DDGetMaxBufferSizeBytes</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">static</span> NSUInteger maxBufferSize <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">static</span> dispatch_once_t onceToken;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    dispatch_once(<span style="color:#719e07">&amp;</span>onceToken, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        maxBufferSize <span style="color:#719e07">=</span> p_DDGetDefaultBufferSizeBytesMax(<span style="color:#b58900">YES</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">return</span> maxBufferSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">static</span> NSUInteger <span style="color:#268bd2">DDGetDefaultBufferSizeBytes</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#719e07">static</span> NSUInteger defaultBufferSize <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">static</span> dispatch_once_t onceToken;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    dispatch_once(<span style="color:#719e07">&amp;</span>onceToken, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        defaultBufferSize <span style="color:#719e07">=</span> p_DDGetDefaultBufferSizeBytesMax(<span style="color:#b58900">NO</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>    <span style="color:#719e07">return</span> defaultBufferSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>}
</code></pre></div><h2 id="life-cycle">Life Cycle</h2>
<h3 id="初始化">初始化</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>_fileLogger <span style="color:#719e07">=</span> fileLogger;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>_maxBufferSizeBytes <span style="color:#719e07">=</span> DDGetDefaultBufferSizeBytes();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>[<span style="color:#b58900">self</span> flushBuffer];
</code></pre></div><p>初始化时，保存 fileLogger 引用，获取默认 bufferSize 以及刷新 outputStream。</p>
<h3 id="flushbuffer">flushBuffer</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>[_buffer close];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>_buffer <span style="color:#719e07">=</span> [NSOutputStream outputStreamToMemory];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>[_buffer open];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>_currentBufferSizeBytes <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
</code></pre></div><p>通过 <code>outputStreamToMemory</code> 创建一个直接将所写入的数据写到内存中。用 <code>_currentBufferSizeBytes</code> 记录当前所占用内存的大小。</p>
<h3 id="dealloc">dealloc</h3>
<p>为了保证数据完整性，在生命周期结束后会主动将数据写回 fileLogger 中，以期最终能写入 log file。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_block_t block <span style="color:#719e07">=</span> <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>     [<span style="color:#b58900">self</span> lt_sendBufferedDataToFileLogger];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>     <span style="color:#b58900">self</span>.fileLogger <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span> };
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span> <span style="color:#719e07">if</span> ([<span style="color:#b58900">self</span><span style="color:#719e07">-&gt;</span>_fileLogger isOnInternalLoggerQueue]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>     block();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span> } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>     dispatch_sync(<span style="color:#b58900">self</span><span style="color:#719e07">-&gt;</span>_fileLogger.loggerQueue, block);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span> }
</code></pre></div><h3 id="lt_sendbuffereddatatofilelogger">lt_sendBufferedDataToFileLogger</h3>
<p>写回 fileLogger 则是将 buffer 中的 data 取出，然后调用 <code>lt_logData</code> 写入 fileLogger，最后 flushBuffer。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSData <span style="color:#719e07">*</span>data <span style="color:#719e07">=</span> [_buffer propertyForKey:NSStreamDataWrittenToMemoryStreamKey];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>[_fileLogger lt_logData:data];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>[<span style="color:#b58900">self</span> flushBuffer];
</code></pre></div><h2 id="logging">Logging</h2>
<p>bufferProxy 拦截了这两个方法 <code>logMessage</code> 和 <code>flush</code>，其余的都通过 message forwarding 转回 filgLogger了。</p>
<h3 id="logmessage-1">logMessage</h3>
<p>例行检查和 fileLogger 中的一样，而 logMessage 方法主要作用是将 log message 转化为 NSData 再调用 <code>lt_logData</code>。对 buffer 而言则是将 NSData 以 byteStream 的方式写入 outputStream。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>[data enumerateByteRangesUsingBlock:<span style="color:#719e07">^</span>(<span style="color:#719e07">const</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span> __nonnull bytes, NSRange byteRange, <span style="color:#dc322f">BOOL</span> <span style="color:#719e07">*</span> __nonnull __unused stop) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    NSUInteger bytesLength <span style="color:#719e07">=</span> byteRange.length;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">#ifdef NS_BLOCK_ASSERTIONS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07"></span>    __unused
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07"></span>    NSInteger written <span style="color:#719e07">=</span> [_buffer write:bytes maxLength:bytesLength];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    NSAssert(written <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">&amp;&amp;</span> (NSUInteger)written <span style="color:#719e07">==</span> bytesLength, <span style="color:#2aa198">@&#34;Failed to write to memory buffer.&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    _currentBufferSizeBytes <span style="color:#719e07">+=</span> bytesLength;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#719e07">if</span> (_currentBufferSizeBytes <span style="color:#719e07">&gt;=</span> _maxBufferSizeBytes) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        [<span style="color:#b58900">self</span> lt_sendBufferedDataToFileLogger];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}];
</code></pre></div><p>会不断地将 data 写入 buffer，如果满了就写入 log file 并 flushBuffer。通过这种方式，有效的减小了文件写入的 I/O 操作。</p>
<h3 id="flush-1">flush</h3>
<p>flush 为了及时将 buffer 等缓存数据及时写入，防止应用被主动退出或 Crash 时数据丢失。作为 Public method 还是再强调一下，它在执行前依旧需要进行 loggingQueue 和 loggerQueue 的检查，之后才是核心代码。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>dispatch_block_t block <span style="color:#719e07">=</span> <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>adispatch_block_t block <span style="color:#719e07">=</span> <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>        [<span style="color:#b58900">self</span> lt_sendBufferedDataToFileLogger];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>        [<span style="color:#b58900">self</span>.fileLogger flush];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>};
</code></pre></div><h1 id="总结">总结</h1>
<p>通过对 DDFileLogger 源码的浅尝，能够强烈感受到作者扎实的基础能力。例如使用 NSFileHandle 来操作 file 的增量写入，使用 dispatch_source_t 来实现 timer 的 delay 功能，以及利用 dispatch_source_t 来监听 NSFileHandle 的 change 等都体现了作者对 GCD 的熟悉和掌控能力，包括上一篇中的 queue 的使用。除了这些实现细节之外，作者对 file rolling 等日志监控的相关概念的实现都有不错的理解。最后整个框架则对 deprecated API 有着较好的兼容，确实是名副其实的高性能。</p>
<p>总之，收获颇多。</p>
<h3 id="未完待续">未完待续</h3>
<p>DDLogger 中至少还会有一篇的 blog 是关于 <code>DDAbstractDatabaseLogger</code> 分析。之后可能会有相关日志组件的横向对比，但是 lumberjack 是真的超乎我想象的优先开源实现。</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/source-code">Source Code</a>
     
    <a href="https://looseyi.github.io/tags/ios">iOS</a>
     
    <a href="https://looseyi.github.io/tags/logger">Logger</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-3/"><span>←</span><span>浅析 - CocoaLumberjack 3.6 之 DatabaseLogger</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-1/"><span>浅析 - CocoaLumberjack 3.6 之 DDLog</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
