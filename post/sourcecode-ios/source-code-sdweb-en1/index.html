<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>The Architecture of SDWebImage v5.6 - </title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="土土Edmond木" /><meta name="description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&#39;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&#39;s level list below, force on the entire framework&#39;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.62.0 with theme even" />


<link rel="canonical" href="http://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/" />
  <link href="http://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/index.xml" rel="alternate" type="application/rss+xml" title="" />
  <link href="http://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/index.xml" rel="feed" type="application/rss+xml" title="" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="The Architecture of SDWebImage v5.6" />
<meta property="og:description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&#39;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&#39;s level list below, force on the entire framework&#39;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/" />
<meta property="article:published_time" content="2020-04-12T23:08:12+17:00" />
<meta property="article:modified_time" content="2020-04-12T23:08:12+17:00" />
<meta itemprop="name" content="The Architecture of SDWebImage v5.6">
<meta itemprop="description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&#39;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&#39;s level list below, force on the entire framework&#39;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which">
<meta itemprop="datePublished" content="2020-04-12T23:08:12&#43;17:00" />
<meta itemprop="dateModified" content="2020-04-12T23:08:12&#43;17:00" />
<meta itemprop="wordCount" content="5660">



<meta itemprop="keywords" content="Source Code,iOS,Cache," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Architecture of SDWebImage v5.6"/>
<meta name="twitter:description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&#39;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&#39;s level list below, force on the entire framework&#39;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Aha Moment</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Aha Moment</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">The Architecture of SDWebImage v5.6</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-12 </span>
        <div class="post-category">
            <a href="/categories/ios/"> iOS </a>
            <a href="/categories/objc/"> Objc </a>
            <a href="/categories/en/"> En </a>
            </div>
          <span class="more-meta"> 约 5660 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#50-migration-guid">5.0 Migration Guid</a></li>
    <li><a href="#view-category">View Category</a>
      <ul>
        <li><a href="#sdwebimagecontext">SDWebImageContext</a></li>
      </ul>
    </li>
    <li><a href="#imageprefetcher">ImagePrefetcher</a></li>
    <li><a href="#imageloader">ImageLoader</a></li>
    <li><a href="#imagecache">ImageCache</a>
      <ul>
        <li><a href="#sdmemorycache">SDMemoryCache</a></li>
        <li><a href="#sddiskcache">SDDiskCache</a></li>
        <li><a href="#sdimagecache">SDImageCache</a></li>
      </ul>
    </li>
    <li><a href="#sdimagemanaer">SDImageManaer</a>
      <ul>
        <li><a href="#loadimage">LoadImage</a></li>
      </ul>
    </li>
    <li><a href="#the-end">The End</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD's API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API's level list below, force on the entire framework's data flow.</p>
<p><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="highlevel"></p>
<h2 id="50-migration-guid">5.0 Migration Guid</h2>
<p>It is highly recommended to watch the official <a href="https://github.com/SDWebImage/SDWebImage/wiki/5.0-Migration-guide">migration document</a>, which mentioned the mainly features in version 5.0.</p>
<ul>
<li>Brand new Animated Image View (was <code>FLAnimatedImageView</code> in 4.0);</li>
<li>Image Transform is provided to easy way to scale, rotate, rounded corner and other operations after the image was downloaded;</li>
<li>Customization, you can customize <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-cache-50">cache</a>, <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-loader-50">loader</a>, <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-coder-420">coder</a>, which are base on the protocol;</li>
<li>Added View Indicator to identify the loading status of Image;</li>
</ul>
<p>I could say that the protocolization for the core classes is the biggest change in the 5.x SD version, which means the image request, loading, decoding, caching and other operations are pluggable and replaceable as you want.</p>
<p>So, let's see the main part first:</p>
<table>
<thead>
<tr>
<th>4.x</th>
<th>5.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>SDWebImageCacheSerializerBlock</td>
<td>id&lt;SDWebImageCacheSerializer&gt;</td>
</tr>
<tr>
<td>SDWebImageCacheKeyFilterBlock</td>
<td>id&lt;SDWebImageCacheKeyFilter&gt;</td>
</tr>
<tr>
<td>SDWebImageDownloader</td>
<td>id&lt;SDImageLoader&gt;</td>
</tr>
<tr>
<td>SDImageCache</td>
<td>id&lt;SDImageCache&gt;</td>
</tr>
<tr>
<td>SDWebImageDownloaderProgressBlock</td>
<td>id&lt;SDWebImageIndicator&gt;</td>
</tr>
<tr>
<td>FLAnimatedImageView</td>
<td>id&lt;SDAnimatedImage&gt;</td>
</tr>
</tbody>
</table>
<h2 id="view-category">View Category</h2>
<p>All the view's convenience method for image operation are base on <code>UIView + WebCache</code>, including the following:</p>
<ul>
<li>UIImageView+HighlightedWebCache</li>
<li>UIImageView+WebCache</li>
<li>UIView+WebCacheOperation</li>
<li>UIButton+WebCache</li>
<li>NSButton+WebCache</li>
</ul>
<p>Firstly, let ’s take a look at <a href="https://github.com/SDWebImage/SDWebImage/blob/09f06159a3284f6981d5495728e5c3cb3dfb82fa/SDWebImage/Core/SDWebImageCompat.h">SDWebImageCompat.h</a> ,  which defines <strong>SD_MAC, SD_UIKIT, SD_WATCH</strong> macros are used to Simplify the definition of the system, and used to unify the differences platforms API, such as using <code># define UIImage NSImage</code> to redefine NSImage to UIImage. Another thing you would like to know is:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="cp">#</span><span class="cp">ifndef dispatch_main_async_safe</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">define dispatch_main_async_safe(block)\</span><span class="cp">
</span><span class="cp"></span><span class="cp">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) {\</span><span class="cp">
</span><span class="cp"></span><span class="cp">        block();\</span><span class="cp">
</span><span class="cp"></span><span class="cp">    } else {\</span><span class="cp">
</span><span class="cp"></span><span class="cp">        dispatch_async(dispatch_get_main_queue(), block);\</span><span class="cp">
</span><span class="cp"></span><span class="cp">    }</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">endif</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div><p>different from the earler version:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="cp">#</span><span class="cp">define dispatch_main_async_safe(block)\</span><span class="cp">
</span><span class="cp"></span><span class="cp">    if ([NSThread isMainThread]) {\</span><span class="cp">
</span><span class="cp"></span><span class="cp">        block();\</span><span class="cp">
</span><span class="cp"></span><span class="cp">    } else {\</span><span class="cp">
</span><span class="cp"></span><span class="cp">        dispatch_async(dispatch_get_main_queue(), block);\</span><span class="cp">
</span><span class="cp"></span><span class="cp">    }</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">endif</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>use <code>#ifndef</code> to prevent repeated definition of <code>dispatch_main_async_safe</code>;</li>
<li>Main thread detect change from <code>isMainThread</code> to <code>dispatch_queue_t</code> label</li>
</ul>
<p>Abount the second point, here is a <a href="https://github.com/SDWebImage/SDWebImage/pull/781">Discussion of SD</a>, and another explanation <a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/">GCD's Main Queue vs. Main Thread</a>)</p>
<blockquote>
<p>Calling an API from a non-main queue that is executing on the main thread will lead to issues if the library (like VektorKit) relies on checking for execution on the main queue.</p>
</blockquote>
<p>Cause <strong>tasks in the main queue must be put into the main thread to execute</strong>.</p>
<p>Compared to the category of UIImageView, UIButton needs to store images under different <code>UIControlState</code> and backgrounImage, and SD associate has an internal dictionary <code> (NSMutableDictionary &lt;NSString *, NSURL *&gt; *) sd_imageURLStorage</code> to store the images.</p>
<p>All view category's <code>setImageUrl:</code> finally refer to the following method:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sd_internalSetImageWithURL:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
                  <span class="nf">placeholderImage:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">placeholder</span>
                           <span class="nf">options:</span><span class="p">(</span><span class="n">SDWebImageOptions</span><span class="p">)</span><span class="nv">options</span>
                           <span class="nf">context:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
                     <span class="nf">setImageBlock:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDSetImageBlock</span><span class="p">)</span><span class="nv">setImageBlock</span>
                          <span class="nf">progress:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDImageLoaderProgressBlock</span><span class="p">)</span><span class="nv">progressBlock</span>
                         <span class="nf">completed:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDInternalCompletionBlock</span><span class="p">)</span><span class="nv">completedBlock</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>This method's implementation is quite long, here is the briefly describes:</p>
<ol>
<li>Copy and convert <code>SDWebImageContext</code> to immutable, get the value of <code> validOperationKey</code> as the verification id, the default value is the class name of the current view;</li>
<li>Call <code>sd_cancelImageLoadOperationWithKey</code> to cancel the last task, which to ensure that there is no asynchronous download operation currently in progress and no conflict with the upcoming operation;</li>
<li>Set the placeholder image;</li>
<li>Initialize <code>SDWebImageManager</code> , <code> SDImageLoaderProgressBlock</code> , reset <code>NSProgress</code>, <code> SDWebImageIndicator</code>;</li>
<li>Start downloading, call <code>loadImageWithURL:</code> and save the returned <code>SDWebImageOperation</code> into <code> sd_operationDictionary</code>, which key is <code>validOperationKey</code>;</li>
<li>After getting the picture, call <code>sd_setImage:</code> and add transition animation to the new image;</li>
<li>Stop the indicator after the animation ends.</li>
</ol>
<p>A tips, the <code>SDWebImageOperation</code> is a <strong>strong-weak</strong> NSMapTable, which is also added by the associated value:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// key is strong, value is weak because operation instance is retained by SDWebImageManager&#39;s runningOperations property
</span><span class="c1"></span><span class="c1">// we should use lock to keep thread-safe because these method may not be acessed from main queue
</span><span class="c1"></span><span class="k">typedef</span> <span class="n">NSMapTable</span><span class="o">&lt;</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">SDOperationsDictionary</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Weak is used because the operation instance is stored in SDWebImageManager's runningOperations, and the reference here is saved to easy cancel the task.</p>
<h3 id="sdwebimagecontext">SDWebImageContext</h3>
<blockquote>
<p>A SDWebImageContext object which hold the original context options from top-level API.</p>
</blockquote>
<p>Image context runs through the entire workflow of image processing. It brings data into each processing task step by step. There are two types of ImageContext:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objectivec" data-lang="objectivec"><span class="k">typedef</span> <span class="n">NSString</span> <span class="o">*</span> <span class="n">SDWebImageContextOption</span> <span class="n">NS_EXTENSIBLE_STRING_ENUM</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">NSDictionary</span><span class="o">&lt;</span><span class="n">SDWebImageContextOption</span><span class="p">,</span> <span class="kt">id</span><span class="o">&gt;</span> <span class="n">SDWebImageContext</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">NSMutableDictionary</span><span class="o">&lt;</span><span class="n">SDWebImageContextOption</span><span class="p">,</span> <span class="kt">id</span><span class="o">&gt;</span><span class="n">SDWebImageMutableContext</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>SDWebImageContextOption is an extensible String enumeration, there are currently 15 types. Basically, you can guess its function just by looking at the name, here is the <a href="https://github.com/SDWebImage/SDWebImage/blob/5c3c40288f7e465ba94db9736e624f663831951a/SDWebImage/Core/SDWebImageDefine.h">document</a>, summarized as follows:</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cgy1gcbeto2gb6j20xj1whajv.jpg" alt="image context"></p>
<h2 id="imageprefetcher">ImagePrefetcher</h2>
<p>Prefetcher has nothing to do with the entire processing stream of SD. It mainly uses imageManger for batch image download. Below is the core method:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImagePrefetchToken</span> <span class="o">*</span><span class="p">)</span><span class="nf">prefetchURLs:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSArray</span><span class="o">&lt;</span><span class="n">NSURL</span> <span class="o">*</span><span class="o">&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nv">urls</span>
                                          <span class="nf">progress:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImagePrefetcherProgressBlock</span><span class="p">)</span><span class="nv">progressBlock</span>
                                         <span class="nf">completed:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImagePrefetcherCompletionBlock</span><span class="p">)</span><span class="nv">completionBlock</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>It stores the downloaded URLs as <code>transactions</code> in <code>SDWebImagePrefetchToken</code>,  which do not cancel previous request and it separate different prefetching process. When you call <code>prefetchURLs</code> for different url lists, you can get callback for different completion block.</p>
<p>Each download task is in the autoreleasesepool, and will use <code>SDAsyncBlockOperation</code> to wrap the real download task to achieve the cancelable operation of the task:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@autoreleasepool</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">weakify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="p">;</span>
    <span class="n">SDAsyncBlockOperation</span> <span class="o">*</span><span class="n">prefetchOperation</span> <span class="o">=</span> <span class="p">[</span><span class="n">SDAsyncBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">SDAsyncBlockOperation</span> <span class="o">*</span> <span class="n">_Nonnull</span> <span class="n">asyncOperation</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">self</span> <span class="o">|</span><span class="o">|</span> <span class="n">asyncOperation</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">/// load Image ...
</span><span class="c1"></span>    <span class="p">}</span><span class="p">]</span><span class="p">;</span>
    <span class="k">@synchronized</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">token</span><span class="p">.</span><span class="n">prefetchOperations</span> <span class="nl">addPointer</span><span class="p">:</span><span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">prefetchOperation</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">prefetchQueue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">prefetchOperation</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Finally, the task is stored in prefetchQueue, which limit the maximum number of downloads to 3 by default. The real task of URLs downloading is in <code>token.loadOperations</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">NSPointerArray</span> <span class="o">*</span><span class="n">operations</span> <span class="o">=</span> <span class="n">token</span><span class="p">.</span><span class="n">loadOperations</span><span class="p">;</span>
<span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span> <span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">manager</span> <span class="nl">loadImageWithURL</span><span class="p">:</span><span class="n">url</span> <span class="nl">options</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">options</span> <span class="nl">context</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">context</span> <span class="nl">progress</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">completed</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">image</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">data</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">error</span><span class="p">,</span> <span class="n">SDImageCacheType</span> <span class="n">cacheType</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">finished</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">imageURL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">/// progress handler    
</span><span class="c1"></span><span class="p">}</span><span class="p">]</span><span class="p">;</span>
<span class="n">NSAssert</span><span class="p">(</span><span class="n">operation</span> <span class="o">!</span><span class="o">=</span> <span class="nb">nil</span><span class="p">,</span> <span class="s">@&#34;</span><span class="s">Operation should not be nil, [SDWebImageManager loadImageWithURL:options:context:progress:completed:] break prefetch logic</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
<span class="k">@synchronized</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">operations</span> <span class="nl">addPointer</span><span class="p">:</span><span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">operation</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>loadOperations</code> and <code>prefetchOperations</code> All use <strong>NSPointerArray</strong>, which uses its [NSPointerFunctionsWeakMemory](apple-reference-documentation: // hcx77yk4jV) feature and can store <code> Null</code> values, although its performance is not very good, see: <a href="https://objccn.io/issue-7-1/">basic collection Class</a></p>
<p>Another important thing is that PrefetchToken use the <a href="https://zhuanlan.zhihu.com/p/45566448">c++11 memory_order_relaxed</a> to ensure the thread-safe。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">atomic_ulong</span> <span class="n">_skippedCount</span><span class="p">;</span>
<span class="n">atomic_ulong</span> <span class="n">_finishedCount</span><span class="p">;</span>
<span class="n">atomic_flag</span>  <span class="n">_isAllFinished</span><span class="p">;</span>
    
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_totalCount</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Simply, it use memory order and atomic operations to achieve lock-free concurrency and improving efficiency.</p>
<h2 id="imageloader">ImageLoader</h2>
<p>ImageLoader is the default implementation of the <code>SDImageLoader</code> protocol, which provides HTTP / HTTPS / FTP or local URL NSURLSession source image acquisition capabilities. And it also maximizes the configurability of the entire download process. Main interface as fellow:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@interface</span> <span class="nc">SDWebImageDownloader</span> : <span class="nc">NSObject</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">SDWebImageDownloaderConfig</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderRequestModifier</span><span class="o">&gt;</span> <span class="n">requestModifier</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderResponseModifier</span><span class="o">&gt;</span> <span class="n">responseModifier</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderDecryptor</span><span class="o">&gt;</span> <span class="n">decryptor</span><span class="p">;</span>
<span class="cm">/* ... */</span>

<span class="p">-</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageDownloadToken</span> <span class="o">*</span><span class="p">)</span><span class="nf">downloadImageWithURL:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
    <span class="nf">options:</span><span class="p">(</span><span class="n">SDWebImageDownloaderOptions</span><span class="p">)</span><span class="nv">options</span>
    <span class="nf">context:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
   <span class="nf">progress:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageDownloaderProgressBlock</span><span class="p">)</span><span class="nv">progressBlock</span>
  <span class="nf">completed:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageDownloaderCompletedBlock</span><span class="p">)</span><span class="nv">completedBlock</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>the <strong>downloaderConfig</strong> supports the NSCopy protocol, below is the main configurations provided:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">/// The maximum number of concurrent downloads.
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">maxConcurrentDownloads</span><span class="p">;</span>
<span class="c1">/// The timeout value (in seconds) for each download operation.
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="n">NSTimeInterval</span> <span class="n">downloadTimeout</span><span class="p">;</span>
<span class="c1">/// The session configuration, it&#39;s immutable after the downloader instance initialized. 
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">NSURLSessionConfiguration</span> <span class="o">*</span><span class="n">sessionConfiguration</span><span class="p">;</span>
<span class="c1">/// Passing `NSOperation&lt;SDWebImageDownloaderOperation&gt;` to set as default. Passing `nil` will revert to `SDWebImageDownloaderOperation`.
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">Class</span> <span class="n">operationClass</span><span class="p">;</span>
<span class="c1">/// The download operations execution order, default is FIFO
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="n">SDWebImageDownloaderExecutionOrder</span> <span class="n">executionOrder</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>the <strong>requestModifier</strong>, provide modification before download request,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">/// Modify the original URL request and return a new one instead. You can modify the HTTP header, cachePolicy, etc for this URL.
</span><span class="c1"></span><span class="k">@protocol</span> <span class="nc">SDWebImageDownloaderRequestModifier</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
   
<span class="o">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nl">modifiedRequestWithRequest</span><span class="p">:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>Similarly, the <strong>responseModifier</strong> provides modification of the return value,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">/// Modify the original URL response and return a new response. You can use this to check MIME-Type, mock server response, etc.
</span><span class="c1"></span>
<span class="k">@protocol</span> <span class="nc">SDWebImageDownloaderResponseModifier</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="o">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="p">)</span><span class="nl">modifiedResponseWithResponse</span><span class="p">:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="p">)</span><span class="n">response</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>The last <strong>decryptor</strong> is used for image decryption, which provides base64 conversion of imageData by default.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">/// Decrypt the original download data and return a new data. You can use this to decrypt the data using your perfereed algorithm.
</span><span class="c1"></span><span class="k">@protocol</span> <span class="nc">SDWebImageDownloaderDecryptor</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>

<span class="o">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nl">decryptedDataWithData</span><span class="p">:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="nl">response</span><span class="p">:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="p">)</span><span class="n">response</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>Processing data through these protocolded objects origins the <strong><a href="https://www.wikiwand.com/en/Strategy_pattern">strategy pattern</a></strong>. By obtaining the protocol object through configuration, the caller only needs to care about the method provided by the protocol object, and does not need to care about its internal implementation to achieve the purpose of decoupling.</p>
<p>###DownloadImageWithURL</p>
<p>Before downloading, check whether the URL exists.</p>
<p>If not, directly throw an error and return. After getting the URL, try to reuse the operation generated before:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">NSOperation</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderOperation</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">URLOperations</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">url</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>If operation exists, call</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@synchronized</span> <span class="p">(</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">downloadOperationCancelToken</span> <span class="o">=</span> <span class="p">[</span><span class="n">operation</span> <span class="nl">addHandlersForProgress</span><span class="p">:</span><span class="n">progressBlock</span> <span class="nl">completed</span><span class="p">:</span><span class="n">completedBlock</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And set the queuePriority. Here the <code>@synchronized (operation)</code> is used to compare the <code>@synchronized (self)</code>, which is used inside the operation to ensure the thread safety of the operation between two different classes. Because the operation may be passed to the decoding or proxy queue.</p>
<p>Then  <code>addHandlersForProgres</code> method will save progressBlock and completedBlock into <code>NSMutableDictionary &lt;NSString *, id&gt; SDCallbacksDictionary</code> and then return and save it into downloadOperationCancelToken.</p>
<p>In addition, operation in <code>addHandlersForProgress</code> method does not clear the previous stored callbacks. They are saved increamently, which means that all the callBacks will be executed in sequence after download completion.</p>
<p>If the operation is nil、isFinished or isCancelled will call <code>createDownloaderOperationWithUrl:options:context:</code> to create a new operation and store it in URLOperations and configure completionBlock. So that URLOperations can be cleared when the task is completed. Then call <code>addHandlersForProgress:completed:</code> to save progressBlock and completedBlock. At last submit operation to the downloadQueue.</p>
<p>The final operation, url, request, and downloadOperationCancelToken are packaged into <strong>SDWebImageDownloadToken</strong>, which the end of the download task.</p>
<p>###CreateDownloaderOperation</p>
<p>After downloading, let's talk about how the operation is created. The first is to generate a URLRequest:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise
</span><span class="c1"></span><span class="n">NSURLRequestCachePolicy</span> <span class="n">cachePolicy</span> <span class="o">=</span> <span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageDownloaderUseNSURLCache</span> <span class="o">?</span> <span class="nl">NSURLRequestUseProtocolCachePolicy</span> <span class="p">:</span> <span class="n">NSURLRequestReloadIgnoringLocalCacheData</span><span class="p">;</span>
<span class="n">NSMutableURLRequest</span> <span class="o">*</span><span class="n">mutableRequest</span> <span class="o">=</span> <span class="p">[</span><span class="p">[</span><span class="n">NSMutableURLRequest</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithURL</span><span class="p">:</span><span class="n">url</span> <span class="nl">cachePolicy</span><span class="p">:</span><span class="n">cachePolicy</span> <span class="nl">timeoutInterval</span><span class="p">:</span><span class="n">timeoutInterval</span><span class="p">]</span><span class="p">;</span>
<span class="n">mutableRequest</span><span class="p">.</span><span class="n">HTTPShouldHandleCookies</span> <span class="o">=</span> <span class="n">SD_OPTIONS_CONTAINS</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">SDWebImageDownloaderHandleCookies</span><span class="p">)</span><span class="p">;</span>
<span class="n">mutableRequest</span><span class="p">.</span><span class="n">HTTPShouldUsePipelining</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
<span class="n">SD_LOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">HTTPHeadersLock</span><span class="p">)</span><span class="p">;</span>
<span class="n">mutableRequest</span><span class="p">.</span><span class="n">allHTTPHeaderFields</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">HTTPHeaders</span><span class="p">;</span>
<span class="n">SD_UNLOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">HTTPHeadersLock</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>It is mainly configured by obtaining parameters through SDWebImageDownloaderOptions. The timeout is determined by downloader's <code>config.downloadTimeout</code>, the default is 15s.</p>
<p>Then remove <code>id &lt;SDWebImageDownloaderRequestModifier&gt; requestModifier</code> from imageContext to transform the request.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// Request Modifier
</span><span class="c1"></span><span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderRequestModifier</span><span class="o">&gt;</span> <span class="n">requestModifier</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="p">[</span><span class="n">context</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="n">SDWebImageContextDownloadRequestModifier</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">requestModifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">context</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="n">SDWebImageContextDownloadRequestModifier</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">requestModifier</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">requestModifier</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>What you need to pay attention to is that the access to requestModifier has <strong>priority</strong>, and the priority obtained through imageContext is higher than the downloader. This kind of method not only satisfies the controllability of the caller, but also supports the global configuration, which is suitable for all ages.</p>
<p>Similarly, <code>id &lt;SDWebImageDownloaderResponseModifier&gt; responseModifier</code> and<code> id &lt;SDWebImageDownloaderDecryptor&gt; decryptor</code> are also the same approach.</p>
<p>After that, the confirmed responseModifier and decryptor will be saved in imageContext again for later use.</p>
<p>Finally, remove operationClass from downloaderConfig to create operation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="kt">Class</span> <span class="n">operationClass</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">operationClass</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">operationClass</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">operationClass</span> <span class="nl">isSubclassOfClass</span><span class="p">:</span><span class="p">[</span><span class="n">NSOperation</span> <span class="k">class</span><span class="p">]</span><span class="p">]</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">operationClass</span> <span class="nl">conformsToProtocol</span><span class="p">:</span><span class="p">@</span><span class="n">protocol</span><span class="p">(</span><span class="n">SDWebImageDownloaderOperation</span><span class="p">)</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Custom operation class
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">operationClass</span> <span class="o">=</span> <span class="p">[</span><span class="n">SDWebImageDownloaderOperation</span> <span class="k">class</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">NSOperation</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderOperation</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="p">[</span><span class="n">operationClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nl">inSession</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">session</span> <span class="nl">options</span><span class="p">:</span><span class="n">options</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Set the <em>credential, minimumProgressInterval, queuePriority, pendingOperation</em>.</p>
<p>By default, each task is added to the downloadQueue in FIFO order. If you set it as LIFO, the task priority will be modified before adding to the queue:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">executionOrder</span> <span class="o">=</span><span class="o">=</span> <span class="n">SDWebImageDownloaderLIFOExecutionOrder</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation
</span><span class="c1"></span>    <span class="c1">// This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations
</span><span class="c1"></span>    <span class="c1">// Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">NSOperation</span> <span class="o">*</span><span class="n">pendingOperation</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">downloadQueue</span><span class="p">.</span><span class="n">operations</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">pendingOperation</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>###Data Processing</p>
<p>SDWebImageDownloaderOperation is also a protocolization class, which confirm NSURLSessionTaskDelegate, NSURLSessionDataDelegate. It handles URL request data, supports background downloading, supports responseData modification (by responseModifier), and supports download ImageData decryption (by decryptor). The main internal properties are as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">)</span> <span class="n">SDWebImageDownloaderOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">SDWebImageContext</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">NSMutableArray</span><span class="o">&lt;</span><span class="n">SDCallbacksDictionary</span> <span class="o">*</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">callbackBlocks</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">NSMutableData</span> <span class="o">*</span><span class="n">imageData</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">cachedData</span><span class="p">;</span> <span class="c1">// for `SDWebImageDownloaderIgnoreCachedResponse`
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">expectedSize</span><span class="p">;</span> <span class="c1">// may be 0
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">receivedSize</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderResponseModifier</span><span class="o">&gt;</span> <span class="n">responseModifier</span><span class="p">;</span> <span class="c1">// modifiy original URLResponse
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderDecryptor</span><span class="o">&gt;</span> <span class="n">decryptor</span><span class="p">;</span> <span class="c1">// decrypt image data
</span><span class="c1"></span><span class="c1">// This is weak because it is injected by whoever manages this session. If this gets nil-ed out, we won&#39;t be able to run
</span><span class="c1"></span><span class="c1">// the task associated with this operation
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">NSURLSession</span> <span class="o">*</span><span class="n">unownedSession</span><span class="p">;</span>
<span class="c1">// This is set if we&#39;re using not using an injected NSURLSession. We&#39;re responsible of invalidating this one
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">NSURLSession</span> <span class="o">*</span><span class="n">ownedSession</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">dispatch_queue_t</span> <span class="n">coderQueue</span><span class="p">;</span> <span class="c1">// the queue to do image decoding
</span><span class="c1"></span><span class="cp">#</span><span class="cp">if SD_UIKIT</span><span class="cp">
</span><span class="cp"></span><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">UIBackgroundTaskIdentifier</span> <span class="n">backgroundTaskId</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="n">nonnull</span> <span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithRequest:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nv">request</span>
                              <span class="nf">inSession:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span>
                                <span class="nf">options:</span><span class="p">(</span><span class="n">SDWebImageDownloaderOptions</span><span class="p">)</span><span class="nv">options</span>
                                <span class="nf">context:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>There is nothing special about initialization. You should noted that the <code>nullable session</code> passed here is saved with unownedSessin, which is different from the <strong>ownedSession</strong> generated by default internally. If the session is empty during initialization, the ownedSession will be created at <code>start</code>.</p>
<p>Then the problem is coming, because we need to observe the various states of the session, we need to set up the delegate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">[</span><span class="n">NSURLSession</span> <span class="nl">sessionWithConfiguration</span><span class="p">:</span><span class="nl">delegate</span><span class="p">:</span><span class="nl">delegateQueue</span><span class="p">:</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The delegate of the ownedSession is undoubtedly inside the operation, while the delegate of unownedSessin is the downloader. It will retrieve the operation through taskID and forwarding of the callback through the operation's delegate. Here is the code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">URLSession:</span><span class="p">(</span><span class="n">NSURLSession</span> <span class="o">*</span><span class="p">)</span><span class="nv">session</span> <span class="nf">task:</span><span class="p">(</span><span class="n">NSURLSessionTask</span> <span class="o">*</span><span class="p">)</span><span class="nv">task</span> <span class="nf">didCompleteWithError:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
    
    <span class="c1">// Identify the operation that runs this task and pass it the delegate method
</span><span class="c1"></span>    <span class="n">NSOperation</span><span class="o">&lt;</span><span class="n">SDWebImageDownloaderOperation</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">dataOperation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">operationWithTask</span><span class="p">:</span><span class="n">task</span><span class="p">]</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="p">[</span><span class="n">dataOperation</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">URLSession</span><span class="p">:</span><span class="nl">task</span><span class="p">:</span><span class="nl">didCompleteWithError</span><span class="p">:</span><span class="p">)</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">dataOperation</span> <span class="nl">URLSession</span><span class="p">:</span><span class="n">session</span> <span class="nl">task</span><span class="p">:</span><span class="n">task</span> <span class="nl">didCompleteWithError</span><span class="p">:</span><span class="n">error</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, as a real consumer operation trigger the download task. The entire download process including start, end, and cancellation will send corresponding notifications.</p>
<ol>
<li>
<p>In <strong>didReceiveResponse</strong>, <code>response.expectedContentLength</code> will be saved as expectedSize. Then call <code>modifiedResponseWithResponse:</code> to save the edited response.</p>
</li>
<li>
<p>Every time <strong>didReceiveData</strong> will append data to imageData: <code>[self.imageData appendData: data]</code>, update receivedSize<code>self.receivedSize = self.imageData.length</code>. Finally, when receivedSize bigger then expectedSize, which means the download task is completed,  and move to the next stage. If you support <code>SDWebImageDownloaderProgressiveLoad</code>, you will be able to decoding while downloading in coderQueue:</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// progressive decode the image in coder queue
</span><span class="c1"></span><span class="n">dispatch_async</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">coderQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">SDImageLoaderDecodeProgressiveImageData</span><span class="p">(</span><span class="n">imageData</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">URL</span><span class="p">,</span> <span class="n">finished</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="p">[</span><span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="nl">imageOptionsFromDownloaderOptions</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">options</span><span class="p">]</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">context</span><span class="p">)</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.
</span><span class="c1"></span>            
            <span class="p">[</span><span class="nb">self</span> <span class="nl">callCompletionBlocksWithImage</span><span class="p">:</span><span class="n">image</span> <span class="nl">imageData</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">error</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">finished</span><span class="p">:</span><span class="nb">NO</span><span class="p">]</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>​		Otherwise, the decoding operation will be completed when <strong>didCompleteWithError</strong>: <code>SDImageLoaderDecodeImageData</code>, but you need to decrypt it before decoding:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">if</span> <span class="p">(</span><span class="n">imageData</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="nb">self</span><span class="p">.</span><span class="n">decryptor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">imageData</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">decryptor</span> <span class="nl">decryptedDataWithData</span><span class="p">:</span><span class="n">imageData</span> <span class="nl">response</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">response</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​	3. Handle the complete callback;</p>
<p><em>We will talk about the logic of decode finally.</em></p>
<h2 id="imagecache">ImageCache</h2>
<p>The design of Cache classes are consistent with the ImageLoader. There will be a <strong>SDImageCacheConfig</strong> to configure the cache expiration time, capacity, read and write permissions, and dynamically MemoryCache / DiskCache class.</p>
<p>The main properties of SDImageCacheConfig are as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">shouldDisableiCloud</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">shouldCacheImagesInMemory</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">shouldUseWeakMemoryCache</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">shouldRemoveExpiredDataWhenEnterBackground</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSDataReadingOptions</span> <span class="n">diskCacheReadingOptions</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSDataWritingOptions</span> <span class="n">diskCacheWritingOptions</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSTimeInterval</span> <span class="n">maxDiskAge</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">maxDiskSize</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">maxMemoryCost</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">maxMemoryCount</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">SDImageCacheConfigExpireType</span> <span class="n">diskCacheExpireType</span><span class="p">;</span>
<span class="c1">/// Defaults to built-in `SDMemoryCache` class.
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="kt">Class</span> <span class="n">memoryCacheClass</span><span class="p">;</span>
<span class="c1">/// Defaults to built-in `SDDiskCache` class.
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span> <span class="p">,</span><span class="k">nonatomic</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="kt">Class</span> <span class="n">diskCacheClass</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>MemoryCache and DiskCache instantiation depends on SDImageCacheConfig:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">/// SDMemoryCache
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">nonnull</span> <span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithConfig:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">SDImageCacheConfig</span> <span class="o">*</span><span class="p">)</span><span class="nv">config</span><span class="p">;</span>
<span class="c1">/// SDDiskCache
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithCachePath:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">cachePath</span> <span class="nf">config:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">SDImageCacheConfig</span> <span class="o">*</span><span class="p">)</span><span class="nv">config</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>As a cache protocol, their interface declarations are basically the same, all of which are CURD for data. The difference is that MemoryCache Protocl operates on the <strong>id</strong> type (NSCache's limitation), and DiskCache is on NSData.</p>
<h3 id="sdmemorycache">SDMemoryCache</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="cm">/**
</span><span class="cm"> A memory cache which auto purge the cache on memory warning and support weak cache.
</span><span class="cm"> */</span>
<span class="k">@interface</span> <span class="nc">SDMemoryCache</span> <span class="o">&lt;</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ObjectType</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">NSCache</span> <span class="o">&lt;</span><span class="n">KeyType</span><span class="p">,</span> <span class="n">ObjectType</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">SDMemoryCache</span><span class="o">&gt;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">SDImageCacheConfig</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>Internally, <strong>NSCache</strong> is the implementation for SDMemoryCache, and add <strong>NSMapTable &lt;KeyType, ObjectType&gt; * weakCache</strong> property, which use semaphore lock to ensure thread safety. The weak-cache is a feature added only on the <em>iOS / tvOS</em> platform, because on macOS, NSCache will not clear the corresponding cache, when receiving system memory warning. WeakCache uses strong-weak references without additional memory overhead and does not affect the life cycle of the object.</p>
<p>The role of weakCache is to restore the cache. It is controlled by the <strong>shouldUseWeakMemoryCache</strong> switch of CacheConfig. For details, you can check the <a href="https://github.com/SDWebImage/SDWebImage/blob/master/SDWebImage/Core/SDImageCacheConfig.h">CacheConfig</a>.</p>
<p>First, look at how <em>objectForKey</em> is implemented:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">objectForKey:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">key</span> <span class="p">{</span>
    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">key</span><span class="p">]</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">shouldUseWeakMemoryCache</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Check weak cache
</span><span class="c1"></span>        <span class="n">SD_LOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">weakCacheLock</span><span class="p">)</span><span class="p">;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">weakCache</span> <span class="nl">objectForKey</span><span class="p">:</span><span class="n">key</span><span class="p">]</span><span class="p">;</span>
        <span class="n">SD_UNLOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">weakCacheLock</span><span class="p">)</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Sync cache
</span><span class="c1"></span>            <span class="n">NSUInteger</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="p">[</span><span class="n">obj</span> <span class="nl">isKindOfClass</span><span class="p">:</span><span class="p">[</span><span class="n">UIImage</span> <span class="k">class</span><span class="p">]</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="p">[</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span> <span class="n">sd_memoryCost</span><span class="p">]</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">[</span><span class="nb">super</span> <span class="nl">setObject</span><span class="p">:</span><span class="n">obj</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span> <span class="nl">cost</span><span class="p">:</span><span class="n">cost</span><span class="p">]</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Since NSCache follows  <a href="apple-reference-documentation://hcnVx1bA-q"><code>NSDiscardableContent</code></a> to store temporary objects. When the memory is tight, the cached objects may be cleaned up by the system. At this time, once the application accesses MemoryCache and the cache missing, which will be transferred to the diskCache query operation. And that may cause the image to flicker. And when shouldUseWeakMemoryCache is true, because weakCache holds the weak reference of the object (when the object is cleaned by NSCache but not released), we can get the cache by weakCache and stuff it into NSCache, which will reduces disk I/O.</p>
<h3 id="sddiskcache">SDDiskCache</h3>
<p>This is simpler, internally uses NSFileManager to manage the reading and writing of image data, and calls SDDiskCacheFileNameForKey to process the key MD5 as fileName and store it in the diskCachePath directory. The other is to clear the expired cache:</p>
<ol>
<li>Sort by SDImageCacheConfigExpireType to get <code>NSDirectoryEnumerator * fileEnumerator</code> and start filtering;</li>
<li>Use <code>cacheConfig.maxDiskAage</code> to determine whether it is expired, and store the expired URL in urlsToDelete;</li>
<li>Call <code>[self.fileManager removeItemAtURL: fileURL error: nil];</code></li>
<li>According to <code>cacheConfig.maxDiskSize</code> to delete the data cached on the disk, clean up to 1/2 of maxDiskSize.</li>
</ol>
<p>By the way, SDDiskCache, like <strong><a href="https://github.com/ibireme/YYCache/blob/master/YYCache/YYKVStorage.h">YYKVStorage</a></strong>, also supports adding extendData to UIImage to store additional information, for example, the zoom ratio of the picture, <a href="https://sspai.com/post/55279">URL rich link</a>, time And other data.</p>
<p>However, <strong>YYKVStorage</strong> store the extended_data field by the <em><strong>manifest</strong></em> table in the database. SDDiskCache solution is a different way, by use system API &lt;sys/xattr.h&gt; <strong>setxattr</strong>, <strong>getxattr</strong>, <strong>listxattr</strong> to save extendData, which is really amazing. One more thing, the corresponding key is <em>SDDiskCacheExtendedAttributeName</em>.</p>
<h3 id="sdimagecache">SDImageCache</h3>
<p>It is also a protocold class, which is responsible for scheduling SDMemoryCache and SDDiskCache, and its Properties are as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDMemoryCache</span><span class="o">&gt;</span> <span class="n">memoryCache</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDDiskCache</span><span class="o">&gt;</span> <span class="n">diskCache</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">SDImageCacheConfig</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readwrite</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">diskCachePath</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="n">dispatch_queue_t</span> <span class="n">ioQueue</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Note: The memoryCache and diskCache instances are generated according to the class defined in CacheConfig, and the defaults are SDMemoryCache and SDDiskCache.</p>
</blockquote>
<p>Let's take a look at its core method:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">storeImage:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span>
         <span class="nf">imageData:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">imageData</span>
            <span class="nf">forKey:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
          <span class="nf">toMemory:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">toMemory</span>
            <span class="nf">toDisk:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">toDisk</span>
        <span class="nf">completion:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageNoParamsBlock</span><span class="p">)</span><span class="nv">completionBlock</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p>Make sure that image and key exist;</p>
</li>
<li>
<p>When <strong>shouldCacheImagesInMemory</strong> is YES, it calls <code>[self.memoryCache setObject:image forKey:key cost:cost]</code> to write memoryCache;</p>
</li>
<li>
<p>Write diskCache, put the operation logic into ioQueue and autoreleasepool.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">dispatch_async</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">ioQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">.</span><span class="p">.</span><span class="p">.</span> <span class="c1">// 根据 SDImageFormat 对 image 进行编码获取
</span><span class="c1"></span>        <span class="c1">/// data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil];
</span><span class="c1"></span>        <span class="p">[</span><span class="nb">self</span> <span class="nl">_storeImageDataToDisk</span><span class="p">:</span><span class="n">data</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">]</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Check extended data
</span><span class="c1"></span>            <span class="kt">id</span> <span class="n">extendedObject</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">sd_extendedObject</span><span class="p">;</span>
            <span class="c1">// ... get extended data
</span><span class="c1"></span>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">diskCache</span> <span class="nl">setExtendedData</span><span class="p">:</span><span class="n">extendedData</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">]</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// call completionBlock in main queue
</span><span class="c1"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>Another important method is image query, which is defined in the SDImageCache protocol:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">queryImageForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span> <span class="nf">options:</span><span class="p">(</span><span class="n">SDWebImageOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">context:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span> <span class="nf">completion:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDImageCacheQueryCompletionBlock</span><span class="p">)</span><span class="nv">completionBlock</span> <span class="p">{</span>
    <span class="n">SDImageCacheOptions</span> <span class="n">cacheOptions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageQueryMemoryData</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheQueryMemoryData</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageQueryMemoryDataSync</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheQueryMemoryDataSync</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageQueryDiskDataSync</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheQueryDiskDataSync</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageScaleDownLargeImages</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheScaleDownLargeImages</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageAvoidDecodeImage</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheAvoidDecodeImage</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageDecodeFirstFrameOnly</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheDecodeFirstFrameOnly</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImagePreloadAllFrames</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCachePreloadAllFrames</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageMatchAnimatedImageClass</span><span class="p">)</span> <span class="n">cacheOptions</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDImageCacheMatchAnimatedImageClass</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">queryCacheOperationForKey</span><span class="p">:</span><span class="n">key</span> <span class="nl">options</span><span class="p">:</span><span class="n">cacheOptions</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span> <span class="nl">done</span><span class="p">:</span><span class="n">completionBlock</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>queryImageForKey</strong> converts SDWebImageOptions to SDImageCacheOptions, then call <code>queryCacheOperationForKey:</code>, which logic is as follows:</p>
<p>First, First, if the query key exists, the transformer will be obtained from the imageContext and the query key will be converted:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">key</span> <span class="o">=</span> <span class="n">SDTransformedKeyForKey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">transformerKey</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Try to get the image from the memory cache, if it exists:</p>
<ol>
<li>
<p>If SDImageCacheDecodeFirstFrameOnly is satisfied and comforts to SDAnimatedImage protocol, CGImage will be taken out for conversion</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// Ensure static image
</span><span class="c1"></span><span class="kt">Class</span> <span class="n">animatedImageClass</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="k">class</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">sd_isAnimated</span> <span class="o">|</span><span class="o">|</span> <span class="p">(</span><span class="p">[</span><span class="n">animatedImageClass</span> <span class="nl">isSubclassOfClass</span><span class="p">:</span><span class="p">[</span><span class="n">UIImage</span> <span class="k">class</span><span class="p">]</span><span class="p">]</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">animatedImageClass</span> <span class="nl">conformsToProtocol</span><span class="p">:</span><span class="p">@</span><span class="n">protocol</span><span class="p">(</span><span class="n">SDAnimatedImage</span><span class="p">)</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#</span><span class="cp">if SD_MAC</span><span class="cp">
</span><span class="cp"></span>    <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="p">[</span><span class="n">NSImage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCGImage</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span> <span class="nl">scale</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="n">scale</span> <span class="nl">orientation</span><span class="p">:</span><span class="n">kCGImagePropertyOrientationUp</span><span class="p">]</span><span class="p">;</span>
<span class="cp">#</span><span class="cp">else</span><span class="cp">
</span><span class="cp"></span>    <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="p">[</span><span class="n">UIImage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCGImage</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="n">CGImage</span> <span class="nl">scale</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="n">scale</span> <span class="nl">orientation</span><span class="p">:</span><span class="n">image</span><span class="p">.</span><span class="n">imageOrientation</span><span class="p">]</span><span class="p">;</span>
<span class="cp">#</span><span class="cp">endif</span><span class="cp">
</span><span class="cp"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>If SDImageCacheMatchAnimatedImageClass is satisfied, it will be forced to check whether the image type matches, otherwise the data will be nil:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// Check image class matching
</span><span class="c1"></span><span class="kt">Class</span> <span class="n">animatedImageClass</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="k">class</span><span class="p">;</span>
<span class="kt">Class</span> <span class="n">desiredImageClass</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="n">SDWebImageContextAnimatedImageClass</span><span class="p">]</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">desiredImageClass</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">!</span><span class="p">[</span><span class="n">animatedImageClass</span> <span class="nl">isSubclassOfClass</span><span class="p">:</span><span class="n">desiredImageClass</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">image</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>When the image can be obtained from the memory cache and is SDImageCacheQueryMemoryData, return directly, otherwise continue;</p>
<p>Start reading diskCache, and use shouldQueryDiskSync to specify query cache sync/async behavior.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// Check whether we need to synchronously query disk
</span><span class="c1"></span><span class="c1">// 1. in-memory cache hit &amp; memoryDataSync
</span><span class="c1"></span><span class="c1">// 2. in-memory cache miss &amp; diskDataSync
</span><span class="c1"></span><span class="kt">BOOL</span> <span class="n">shouldQueryDiskSync</span> <span class="o">=</span> <span class="p">(</span><span class="p">(</span><span class="n">image</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDImageCacheQueryMemoryDataSync</span><span class="p">)</span> <span class="o">|</span><span class="o">|</span>
                            <span class="p">(</span><span class="o">!</span><span class="n">image</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDImageCacheQueryDiskDataSync</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The entire diskQuery is stored in queryDiskBlock and wrapped with autorelease:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">queryDiskBlock</span><span class="p">)</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span>  <span class="o">^</span><span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// call doneBlock &amp; return
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">NSData</span> <span class="o">*</span><span class="n">diskData</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">diskImageDataBySearchingAllPathsForKey</span><span class="p">:</span><span class="n">key</span><span class="p">]</span><span class="p">;</span>
        <span class="n">UIImage</span> <span class="o">*</span><span class="n">diskImage</span><span class="p">;</span>
        <span class="n">SDImageCacheType</span> <span class="n">cacheType</span> <span class="o">=</span> <span class="n">SDImageCacheTypeNone</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// the image is from in-memory cache, but need image data
</span><span class="c1"></span>            <span class="n">diskImage</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
            <span class="n">cacheType</span> <span class="o">=</span> <span class="n">SDImageCacheTypeMemory</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">diskData</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cacheType</span> <span class="o">=</span> <span class="n">SDImageCacheTypeDisk</span><span class="p">;</span>
            <span class="c1">// decode image data only if in-memory cache missed
</span><span class="c1"></span>            <span class="n">diskImage</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">diskImageForKey</span><span class="p">:</span><span class="n">key</span> <span class="nl">data</span><span class="p">:</span><span class="n">diskData</span> <span class="nl">options</span><span class="p">:</span><span class="n">options</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span><span class="p">]</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">diskImage</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="nb">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">shouldCacheImagesInMemory</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">NSUInteger</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">diskImage</span><span class="p">.</span><span class="n">sd_memoryCost</span><span class="p">;</span>
                <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">memoryCache</span> <span class="nl">setObject</span><span class="p">:</span><span class="n">diskImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span> <span class="nl">cost</span><span class="p">:</span><span class="n">cost</span><span class="p">]</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// call doneBlock
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">doneBlock</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shouldQueryDiskSync</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">doneBlock</span><span class="p">(</span><span class="n">diskImage</span><span class="p">,</span> <span class="n">diskData</span><span class="p">,</span> <span class="n">cacheType</span><span class="p">)</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
                    <span class="n">doneBlock</span><span class="p">(</span><span class="n">diskImage</span><span class="p">,</span> <span class="n">diskData</span><span class="p">,</span> <span class="n">cacheType</span><span class="p">)</span><span class="p">;</span>
                <span class="p">}</span><span class="p">)</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For large amounts of temporary memory operations, SD will put it into autoreleasepool to ensure that the memory can be released in time.</p>
<p><strong>Special emphasis</strong>, once the code is executed here, there must be disk querying operations, so if you don't have to get imageData, you can use <strong>SDImageCacheQueryMemoryData</strong> to improve query efficiency.</p>
<p>One more thing, the conversion logic of <code>SDTransformedKeyForKey</code> is the transformerKey of <strong>SDImageTransformer</strong>, which is spliced behind the image key in order. E.g:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="err">&#39;</span><span class="n">image</span><span class="p">.</span><span class="n">png</span><span class="err">&#39;</span> <span class="o">|</span><span class="o">&gt;</span> <span class="n">flip</span><span class="p">(</span><span class="nb">YES</span><span class="p">,</span><span class="nb">NO</span><span class="p">)</span> <span class="o">|</span><span class="o">&gt;</span> <span class="n">rotate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="nb">YES</span><span class="p">)</span>  <span class="o">=</span><span class="o">&gt;</span> 
<span class="err">&#39;</span><span class="n">image</span><span class="o">-</span><span class="n">SDImageFlippingTransformer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">SDImageRotationTransformer</span><span class="p">(</span><span class="mf">0.78539816339</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="p">.</span><span class="n">png</span><span class="err">&#39;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="sdimagemanaer">SDImageManaer</h2>
<p>SDImageManger serves as the dispatch center of the entire library, who is the master of the above various logics. It connects the components in series, from View &gt; Downloading &gt; Decodering &gt; Cache. The only core method it exposes is <strong>loadImage</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDImageCache</span><span class="o">&gt;</span> <span class="n">imageCache</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="k">readonly</span><span class="p">,</span> <span class="n">nonnull</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDImageLoader</span><span class="o">&gt;</span> <span class="n">imageLoader</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDImageTransformer</span><span class="o">&gt;</span> <span class="n">transformer</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageCacheKeyFilter</span><span class="o">&gt;</span> <span class="n">cacheKeyFilter</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageCacheSerializer</span><span class="o">&gt;</span> <span class="n">cacheSerializer</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageOptionsProcessor</span><span class="o">&gt;</span> <span class="n">optionsProcessor</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">class</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDImageCache</span><span class="o">&gt;</span> <span class="n">defaultImageCache</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">class</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDImageLoader</span><span class="o">&gt;</span> <span class="n">defaultImageLoader</span><span class="p">;</span>

<span class="p">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageCombinedOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">loadImageWithURL:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
                                                   <span class="nf">options:</span><span class="p">(</span><span class="n">SDWebImageOptions</span><span class="p">)</span><span class="nv">options</span>
                                                   <span class="nf">context:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDWebImageContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
                                                  <span class="nf">progress:</span><span class="p">(</span><span class="n">nullable</span> <span class="n">SDImageLoaderProgressBlock</span><span class="p">)</span><span class="nv">progressBlock</span>
                                                 <span class="nf">completed:</span><span class="p">(</span><span class="n">nonnull</span> <span class="n">SDInternalCompletionBlock</span><span class="p">)</span><span class="nv">completedBlock</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Let's briefly talk about the three left APIs cacheKeyFilter, cacheSerializer and optionsProcessor, the rest of which have been mentioned above.</p>
<p><strong>SDWebImageCacheKeyFilter</strong></p>
<p>By default, the <code>URL.absoluteString</code> is used as cacheKey, and if fileter is set, cacheKey will be replaced by <code>cacheKeyForURL:</code>;</p>
<p><strong>SDWebImageCacheSerializer</strong></p>
<p>By default, ImageCache will directly cache downloadData, and when we use other image formats for transmission, such as WEBP format, then the data with WEBP format will be storaged to the disk directly. This will cause a problem, every time when we query the image from the disk, we have to repeat the decoding operation. The CacheSerializer can directly convert downloadData to JPEG / PNG format NSData cache, thereby improving access efficiency.</p>
<p><strong>SDWebImageOptionsProcessor</strong></p>
<p>Used to control the global parameters in SDWebImageOptions and SDWebImageContext. E.g::</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">SDWebImageManager</span><span class="p">.</span><span class="n">sharedManager</span><span class="p">.</span><span class="n">optionsProcessor</span> <span class="o">=</span> <span class="p">[</span><span class="n">SDWebImageOptionsProcessor</span> <span class="nl">optionsProcessorWithBlock</span><span class="p">:</span><span class="o">^</span><span class="n">SDWebImageOptionsResult</span> <span class="o">*</span> <span class="n">_Nullable</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">url</span><span class="p">,</span> <span class="n">SDWebImageOptions</span> <span class="n">options</span><span class="p">,</span> <span class="n">SDWebImageContext</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// Only do animation on `SDAnimatedImageView`
</span><span class="c1"></span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">[</span><span class="n">SDWebImageContextAnimatedImageClass</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">options</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDWebImageDecodeFirstFrameOnly</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="c1">// Do not force decode for png url
</span><span class="c1"></span>     <span class="k">if</span> <span class="p">(</span><span class="p">[</span><span class="n">url</span><span class="p">.</span><span class="n">lastPathComponent</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&#34;</span><span class="s">png</span><span class="s">&#34;</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">options</span> <span class="o">|</span><span class="o">=</span> <span class="n">SDWebImageAvoidDecodeImage</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="c1">// Always use screen scale factor
</span><span class="c1"></span>     <span class="n">SDWebImageMutableContext</span> <span class="o">*</span><span class="n">mutableContext</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithDictionary</span><span class="p">:</span><span class="n">context</span><span class="p">]</span><span class="p">;</span>
     <span class="n">mutableContext</span><span class="p">[</span><span class="n">SDWebImageContextImageScaleFactor</span><span class="p">]</span> <span class="o">=</span> <span class="l">@(</span><span class="n">UIScreen</span><span class="p">.</span><span class="n">mainScreen</span><span class="p">.</span><span class="n">scale</span><span class="l">)</span><span class="p">;</span>
     <span class="n">context</span> <span class="o">=</span> <span class="p">[</span><span class="n">mutableContext</span> <span class="k">copy</span><span class="p">]</span><span class="p">;</span>
 
     <span class="k">return</span> <span class="p">[</span><span class="p">[</span><span class="n">SDWebImageOptionsResult</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithOptions</span><span class="p">:</span><span class="n">options</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span><span class="p">]</span><span class="p">;</span>
 <span class="p">}</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="loadimage">LoadImage</h3>
<p>The first parameter of the method,  the <strong>url</strong>, which serves as the connection core of SD, was designed to be nullable. This design may be for the convenience of users. Internally through the nil judgment of the url and the compatibility with the NSString type (forced conversion to NSURL) to ensure the subsequent process, otherwise the call ends.</p>
<p>After the download started, it was split into the following 6 methods:</p>
<ul>
<li>callCacheProcessForOperation</li>
<li>callDownloadProcessForOperation</li>
<li>callStoreCacheProcessForOperation</li>
<li>callTransformProcessForOperation</li>
<li>callCompletionBlockForOperation</li>
<li>safelyRemoveOperationFromRunning</li>
</ul>
<p>They are cache query, download, storage, conversion, execution callback, and cleanup callback. You can find that each method is delivered through the operation, which will be ready when the loadImage is loaded, then trigger the cache query.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">SDWebImageCombinedOperation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="n">SDWebImagCombinedOperation</span> <span class="n">new</span><span class="p">]</span><span class="p">;</span>
<span class="n">operation</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>

<span class="c1">///  1
</span><span class="c1"></span><span class="kt">BOOL</span> <span class="n">isFailedUrl</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SD_LOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">failedURLsLock</span><span class="p">)</span><span class="p">;</span>
    <span class="n">isFailedUrl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">failedURLs</span> <span class="nl">containsObject</span><span class="p">:</span><span class="n">url</span><span class="p">]</span><span class="p">;</span>
    <span class="n">SD_UNLOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">failedURLsLock</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">absoluteString</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span> <span class="o">|</span><span class="o">|</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageRetryFailed</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">isFailedUrl</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="nb">self</span> <span class="nl">callCompletionBlockForOperation</span><span class="p">:</span><span class="n">operation</span> <span class="nl">completion</span><span class="p">:</span><span class="n">completedBlock</span> <span class="nl">error</span><span class="p">:</span><span class="p">[</span><span class="n">NSError</span> <span class="nl">errorWithDomain</span><span class="p">:</span><span class="n">SDWebImageErrorDomain</span> <span class="nl">code</span><span class="p">:</span><span class="n">SDWebImageErrorInvalidURL</span> <span class="nl">userInfo</span><span class="p">:</span><span class="l">@{</span><span class="nl">NSLocalizedDescriptionKey</span> <span class="p">:</span> <span class="s">@&#34;</span><span class="s">Image url is nil</span><span class="s">&#34;</span><span class="l">}</span><span class="p">]</span> <span class="nl">url</span><span class="p">:</span><span class="n">url</span><span class="p">]</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">operation</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SD_LOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">runningOperationsLock</span><span class="p">)</span><span class="p">;</span>
<span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">runningOperations</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">operation</span><span class="p">]</span><span class="p">;</span>
<span class="n">SD_UNLOCK</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">runningOperationsLock</span><span class="p">)</span><span class="p">;</span>

<span class="c1">// 2. Preprocess the options and context arg to decide the final the result for manager
</span><span class="c1"></span><span class="n">SDWebImageOptionsResult</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">processedResultForURL</span><span class="p">:</span><span class="n">url</span> <span class="nl">options</span><span class="p">:</span><span class="n">options</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The implementation of <strong>loadImage</strong> is relatively simple, and the core is to generate an operation then transfer it to a chache querey.</p>
<p>After the operation is initialized, it will checks whether failedURLs contains the current url:</p>
<ul>
<li>If yes, and options is SDWebImageRetryFailed, directly return operation and retun;</li>
<li>If pass, the operation will be stored in <code>runningOperations</code>. Enclose options and imageContext in <strong>SDWebImageOptionsResult</strong>.</li>
</ul>
<p>then will update imageContext, mainly store the transformer, cacheKeyFilter, cacheSerializer as the global default setting, and then call <strong>optionsProcessor</strong> to fulfill user's custom options to modify imageContext again.</p>
<p>If you see here from the front,  you should have an impression of this routine. The priority logic of requestModifer in the previous ImageLoader is similar to this, but the implementation is somewhat different. Finally, transfer to CacheProcess.</p>
<p>The operation of <strong>loadImage</strong> is a combineOperation, which is a combination of cache and loader operation tasks, so that it can clean up the cache query and download tasks in one step. The statement is as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="k">@interface</span> <span class="nc">SDWebImageCombinedOperation</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span>
<span class="c1">/// imageCache queryImageForKey: 的 operation
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span> <span class="n">cacheOperation</span><span class="p">;</span>
<span class="c1">/// imageLoader requestImageWithURL: 的 operation
</span><span class="c1"></span><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">,</span> <span class="n">nullable</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageOperation</span><span class="o">&gt;</span> <span class="n">loaderOperation</span><span class="p">;</span>
<span class="c1">/// Cancel the current operation, including cache and loader process
</span><span class="c1"></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">cancel</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></td></tr></table>
</div>
</div><p>The cancel method provided by it will gradually check two types of opration and then call the cancel operation one by one.</p>
<p>####CallCacheProcessForOperation</p>
<p>First check the value of  <strong>SDWebImageFromLoaderOnly</strong> to determine whether need to start the download task directly.</p>
<p>If yes, forward to downloadProcess.</p>
<p>Otherwise, create a query task through <code>imageCache</code> and save it to combineOperation's cacheOperation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">operation</span><span class="p">.</span><span class="n">cacheOperation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">imageCache</span> <span class="nl">queryImageForKey</span><span class="p">:</span><span class="n">key</span> <span class="nl">options</span><span class="p">:</span><span class="n">options</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span> <span class="nl">completion</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">cachedImage</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span> <span class="n">_Nullable</span> <span class="n">cachedData</span><span class="p">,</span> <span class="n">SDImageCacheType</span> <span class="n">cacheType</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">operation</span> <span class="o">|</span><span class="o">|</span> <span class="n">operation</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">/// 1  
</span><span class="c1"></span>   <span class="p">}</span>
  	<span class="c1">/// 2
</span><span class="c1"></span><span class="p">}</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>There are two situations that need to be handled for the results of the cache query:</p>
<ol>
<li>When the operation is executing in the queue and operaton was marked as canceled, will end the donwload task;</li>
<li>Otherwise, forward to downloadProcess.</li>
</ol>
<p>####CallDownloadProcessForOperation</p>
<p>The most complex of the 6 methods. First, We need to decide whether we need to create a new download task, which is controlled by three variables:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="kt">BOOL</span> <span class="n">shouldDownload</span> <span class="o">=</span> <span class="o">!</span><span class="n">SD_OPTIONS_CONTAINS</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">SDWebImageFromCacheOnly</span><span class="p">)</span><span class="p">;</span>
    <span class="n">shouldDownload</span> <span class="o">&amp;</span><span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">cachedImage</span> <span class="o">|</span><span class="o">|</span> <span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageRefreshCached</span><span class="p">)</span><span class="p">;</span>
    <span class="n">shouldDownload</span> <span class="o">&amp;</span><span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">imageManager</span><span class="p">:</span><span class="nl">shouldDownloadImageForURL</span><span class="p">:</span><span class="p">)</span><span class="p">]</span> <span class="o">|</span><span class="o">|</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">imageManager</span><span class="p">:</span><span class="nb">self</span> <span class="nl">shouldDownloadImageForURL</span><span class="p">:</span><span class="n">url</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="n">shouldDownload</span> <span class="o">&amp;</span><span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">imageLoader</span> <span class="nl">canRequestImageForURL</span><span class="p">:</span><span class="n">url</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>check options value is set as SDWebImageFromCacheOnly or SDWebImageRefreshCached;</li>
<li>check the delegate method <strong>shouldDownloadImageForURL</strong> value;</li>
<li>check whether the imageLoader <strong>canRequestImageForURL</strong>;</li>
</ul>
<ol>
<li>If shouldDownload is NO, close the download task. And perform <strong>callCompletionBlockForOperation</strong> and<strong>safelyRemoveOperationFromRunning</strong>. By the way, if cacheImage exists, it will be returned with completionBlock.</li>
<li>If shouldDownload is YES, create a new download task and save it in combineOperation's loaderOperation. Before creating a new task, if cacheImage exist and SDWebImageRefreshCached is set, the cacheImage will be stored in imageContext (if not will create a imageContext).</li>
<li>After downloading, return to callBack, there are several situations to deal with:
<ul>
<li>If the operation is canceled, the downloaded image and data will be discarded. And call the completion block and close the download task ;</li>
<li>Error caused by reqeust is cacneled, call the completion block and close the download task ;</li>
<li>Image refresh hit the NSURLCache cache, do not call the completion block;</li>
<li>errro, <strong>callCompletionBlockForOperation</strong> and add url to failedURLs;</li>
<li>None of the above conditions, if successful by retry, will remove the url from failedURLs first, call <strong>storeCacheProcess</strong>;</li>
</ul>
</li>
</ol>
<p>    Finally, call the <strong>safelyRemoveOperation</strong> for operation which marked as finished;</p>
<p>####CallStoreCacheProcessForOperation</p>
<p>Pour out storeCacheType、originalStoreCacheType、transformer、cacheSerializer from imageContext.</p>
<p>Check if it is necessary to store the converted image data, original data, and wait for the end of the cache storage:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="kt">BOOL</span> <span class="n">shouldTransformImage</span> <span class="o">=</span> <span class="n">downloadedImage</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">downloadedImage</span><span class="p">.</span><span class="n">sd_isAnimated</span> <span class="o">|</span><span class="o">|</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageTransformAnimatedImage</span><span class="p">)</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">transformer</span><span class="p">;</span>
<span class="kt">BOOL</span> <span class="n">shouldCacheOriginal</span> <span class="o">=</span> <span class="n">downloadedImage</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">finished</span><span class="p">;</span>
<span class="kt">BOOL</span> <span class="n">waitStoreCache</span> <span class="o">=</span> <span class="n">SD_OPTIONS_CONTAINS</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">SDWebImageWaitStoreCache</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>If shouldCacheOriginal is NO, directly transfer to <strong>transformProcess</strong>. Otherwise, first confirm whether the storage type is the original data:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="c1">// normally use the store cache type, but if target image is transformed, use original store cache type instead
</span><span class="c1"></span><span class="n">SDImageCacheType</span> <span class="n">targetStoreCacheType</span> <span class="o">=</span> <span class="n">shouldTransformImage</span> <span class="o">?</span> <span class="nl">originalStoreCacheType</span> <span class="p">:</span> <span class="n">storeCacheType</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>If cacheSerializer exists during storage, it will first convert the data format, and finally call <code>[self stroageImage: ...]</code></p>
<p>When the storage is over, go to the last step, <strong>transformProcess</strong>.</p>
<p>####CallTransformProcessForOperation</p>
<p>Before the conversion starts, it will routinely judge whether it needs to be converted.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="kt">id</span><span class="o">&lt;</span><span class="n">SDImageTransformer</span><span class="o">&gt;</span> <span class="n">transformer</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="n">SDWebImageContextImageTransformer</span><span class="p">]</span><span class="p">;</span>
<span class="kt">id</span><span class="o">&lt;</span><span class="n">SDWebImageCacheSerializer</span><span class="o">&gt;</span> <span class="n">cacheSerializer</span> <span class="o">=</span> <span class="n">context</span><span class="p">[</span><span class="n">SDWebImageContextCacheSerializer</span><span class="p">]</span><span class="p">;</span>
<span class="kt">BOOL</span> <span class="n">shouldTransformImage</span> <span class="o">=</span> <span class="n">originalImage</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">originalImage</span><span class="p">.</span><span class="n">sd_isAnimated</span> <span class="o">|</span><span class="o">|</span> <span class="p">(</span><span class="n">options</span> <span class="o">&amp;</span> <span class="n">SDWebImageTransformAnimatedImage</span><span class="p">)</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">transformer</span><span class="p">;</span>
<span class="kt">BOOL</span> <span class="n">waitStoreCache</span> <span class="o">=</span> <span class="n">SD_OPTIONS_CONTAINS</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">SDWebImageWaitStoreCache</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>If conversion is required, it will enter the global queue to start processing:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="n">UIImage</span> <span class="o">*</span><span class="n">transformedImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">transformer</span> <span class="nl">transformedImageWithImage</span><span class="p">:</span><span class="n">originalImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">]</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">transformedImage</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">/// 1
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">callCompletionBlock</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>        
</code></pre></td></tr></table>
</div>
</div><p>After the conversion is successful, the image will be stored according to</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-objective-c" data-lang="objective-c"><span class="n">cacheData</span> <span class="o">=</span> <span class="p">[</span><span class="n">cacheSerializer</span> <span class="nl">cacheDataWithImage</span><span class="p">:</span> <span class="nl">originalData</span><span class="p">:</span> <span class="nl">imageURL</span><span class="p">:</span><span class="p">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>After storing, call completion block. The end.</p>
<h2 id="the-end">The End</h2>
<p>I am honored that you can reach here. I hope you can get a general understanding of the work-flow of SD, as well as some details of processing and thinking. In SD 5.x, the most personal feeling is that the design of its architecture is worth learning.</p>
<ul>
<li>How to design a stable and extensible API that can safely support dynamic parameter addition?</li>
<li>How to design a decoupled and dynamically pluggable architecture?</li>
</ul>
<p>Finally, this article actually lacks <strong>SDImageCoder</strong>, which will be left for the next SDWebImage plugin and its extension.</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">土土Edmond木</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-04-12
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/source-code/">Source Code</a>
          <a href="/tags/ios/">iOS</a>
          <a href="/tags/cache/">Cache</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/sourcecode-ios/source-code-lumberjack-1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">浅析 - CocoaLumberjack 3.6 之 DDLog</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/sourcecode-ios/cocoapods-packager/">
            <span class="next-text nav-default">浅析 Cocoapods-Packager 实现</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:chun574271939@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://twitter.com/looseyi" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/looseyi" class="iconfont icon-github" title="github"></a>
      <a href="https://www.weibo.com/foreverclp" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/tu-tu-edmondmu" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://looseyi.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019-12-11 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">土土Edmond木</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
