<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>The Architecture of SDWebImage v5.6 - Aha Edmond</title>

  
  
  <meta name="description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&rsquo;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&rsquo;s level list below, force on the entire framework&rsquo;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="The Architecture of SDWebImage v5.6" />
<meta property="og:description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&rsquo;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&rsquo;s level list below, force on the entire framework&rsquo;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-en1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-12T23:08:12&#43;17:00" />
<meta property="article:modified_time" content="2020-04-12T23:08:12&#43;17:00" />


  
  <meta itemprop="name" content="The Architecture of SDWebImage v5.6">
<meta itemprop="description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&rsquo;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&rsquo;s level list below, force on the entire framework&rsquo;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which"><meta itemprop="datePublished" content="2020-04-12T23:08:12&#43;17:00" />
<meta itemprop="dateModified" content="2020-04-12T23:08:12&#43;17:00" />
<meta itemprop="wordCount" content="5457">
<meta itemprop="keywords" content="Source Code,iOS,Cache," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Architecture of SDWebImage v5.6"/>
<meta name="twitter:description" content="This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&rsquo;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&rsquo;s level list below, force on the entire framework&rsquo;s data flow. 5.0 Migration Guid It is highly recommended to watch the official migration document, which"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-04-12</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>The Architecture of SDWebImage v5.6</h1>
  </header>
  <section class="post-content"><p>This article is based on SDWebImage 5.6. Why i write this article, cause i found that SD&rsquo;s API is constantly iterating, and many of the structures are different from earlier versions. Here is to make a record. We will start from the top of the API&rsquo;s level list below, force on the entire framework&rsquo;s data flow.</p>
<p><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="highlevel"></p>
<h2 id="50-migration-guid">5.0 Migration Guid</h2>
<p>It is highly recommended to watch the official <a href="https://github.com/SDWebImage/SDWebImage/wiki/5.0-Migration-guide">migration document</a>, which mentioned the mainly features in version 5.0.</p>
<ul>
<li>Brand new Animated Image View (was <code>FLAnimatedImageView</code> in 4.0);</li>
<li>Image Transform is provided to easy way to scale, rotate, rounded corner and other operations after the image was downloaded;</li>
<li>Customization, you can customize <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-cache-50">cache</a>, <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-loader-50">loader</a>, <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-coder-420">coder</a>, which are base on the protocol;</li>
<li>Added View Indicator to identify the loading status of Image;</li>
</ul>
<p>I could say that the protocolization for the core classes is the biggest change in the 5.x SD version, which means the image request, loading, decoding, caching and other operations are pluggable and replaceable as you want.</p>
<p>So, let&rsquo;s see the main part first:</p>
<table>
<thead>
<tr>
<th>4.x</th>
<th>5.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>SDWebImageCacheSerializerBlock</td>
<td>id&lt;SDWebImageCacheSerializer&gt;</td>
</tr>
<tr>
<td>SDWebImageCacheKeyFilterBlock</td>
<td>id&lt;SDWebImageCacheKeyFilter&gt;</td>
</tr>
<tr>
<td>SDWebImageDownloader</td>
<td>id&lt;SDImageLoader&gt;</td>
</tr>
<tr>
<td>SDImageCache</td>
<td>id&lt;SDImageCache&gt;</td>
</tr>
<tr>
<td>SDWebImageDownloaderProgressBlock</td>
<td>id&lt;SDWebImageIndicator&gt;</td>
</tr>
<tr>
<td>FLAnimatedImageView</td>
<td>id&lt;SDAnimatedImage&gt;</td>
</tr>
</tbody>
</table>
<h2 id="view-category">View Category</h2>
<p>All the view&rsquo;s convenience method for image operation are base on <code>UIView + WebCache</code>, including the following:</p>
<ul>
<li>UIImageView+HighlightedWebCache</li>
<li>UIImageView+WebCache</li>
<li>UIView+WebCacheOperation</li>
<li>UIButton+WebCache</li>
<li>NSButton+WebCache</li>
</ul>
<p>Firstly, let ’s take a look at <a href="https://github.com/SDWebImage/SDWebImage/blob/09f06159a3284f6981d5495728e5c3cb3dfb82fa/SDWebImage/Core/SDWebImageCompat.h">SDWebImageCompat.h</a> ,  which defines <strong>SD_MAC, SD_UIKIT, SD_WATCH</strong> macros are used to Simplify the definition of the system, and used to unify the differences platforms API, such as using <code># define UIImage NSImage</code> to redefine NSImage to UIImage. Another thing you would like to know is:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#ifndef dispatch_main_async_safe
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">#define dispatch_main_async_safe(block)\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">        block();\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">    } else {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">        dispatch_async(dispatch_get_main_queue(), block);\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">    }
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">#endif
</span></code></pre></div><p>different from the earler version:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#define dispatch_main_async_safe(block)\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">    if ([NSThread isMainThread]) {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">        block();\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">    } else {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">        dispatch_async(dispatch_get_main_queue(), block);\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">    }
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">#endif
</span></code></pre></div><ul>
<li>use <code>#ifndef</code> to prevent repeated definition of <code>dispatch_main_async_safe</code>;</li>
<li>Main thread detect change from <code>isMainThread</code> to <code>dispatch_queue_t</code> label</li>
</ul>
<p>Abount the second point, here is a <a href="https://github.com/SDWebImage/SDWebImage/pull/781">Discussion of SD</a>, and another explanation <a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/">GCD&rsquo;s Main Queue vs. Main Thread</a>)</p>
<blockquote>
<p>Calling an API from a non-main queue that is executing on the main thread will lead to issues if the library (like VektorKit) relies on checking for execution on the main queue.</p>
</blockquote>
<p>Cause <strong>tasks in the main queue must be put into the main thread to execute</strong>.</p>
<p>Compared to the category of UIImageView, UIButton needs to store images under different <code>UIControlState</code> and backgrounImage, and SD associate has an internal dictionary <code> (NSMutableDictionary &lt;NSString *, NSURL *&gt; *) sd_imageURLStorage</code> to store the images.</p>
<p>All view category&rsquo;s <code>setImageUrl:</code> finally refer to the following method:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">sd_internalSetImageWithURL:</span>(nullable NSURL <span style="color:#719e07">*</span>)<span style="color:#268bd2">url</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>                  <span style="color:#268bd2">placeholderImage:</span>(nullable UIImage <span style="color:#719e07">*</span>)<span style="color:#268bd2">placeholder</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>                           <span style="color:#268bd2">options:</span>(SDWebImageOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>                           <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>                     <span style="color:#268bd2">setImageBlock:</span>(nullable SDSetImageBlock)<span style="color:#268bd2">setImageBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>                          <span style="color:#268bd2">progress:</span>(nullable SDImageLoaderProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>                         <span style="color:#268bd2">completed:</span>(nullable SDInternalCompletionBlock)<span style="color:#268bd2">completedBlock</span>;
</code></pre></div><p>This method&rsquo;s implementation is quite long, here is the briefly describes:</p>
<ol>
<li>Copy and convert <code>SDWebImageContext</code> to immutable, get the value of <code> validOperationKey</code> as the verification id, the default value is the class name of the current view;</li>
<li>Call <code>sd_cancelImageLoadOperationWithKey</code> to cancel the last task, which to ensure that there is no asynchronous download operation currently in progress and no conflict with the upcoming operation;</li>
<li>Set the placeholder image;</li>
<li>Initialize <code>SDWebImageManager</code> , <code> SDImageLoaderProgressBlock</code> , reset <code>NSProgress</code>, <code> SDWebImageIndicator</code>;</li>
<li>Start downloading, call <code>loadImageWithURL:</code> and save the returned <code>SDWebImageOperation</code> into <code> sd_operationDictionary</code>, which key is <code>validOperationKey</code>;</li>
<li>After getting the picture, call <code>sd_setImage:</code> and add transition animation to the new image;</li>
<li>Stop the indicator after the animation ends.</li>
</ol>
<p>A tips, the <code>SDWebImageOperation</code> is a <strong>strong-weak</strong> NSMapTable, which is also added by the associated value:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// key is strong, value is weak because operation instance is retained by SDWebImageManager&#39;s runningOperations property
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75">// we should use lock to keep thread-safe because these method may not be acessed from main queue
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"></span><span style="color:#719e07">typedef</span> NSMapTable<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*</span>, <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;&gt;</span> SDOperationsDictionary;
</code></pre></div><p>Weak is used because the operation instance is stored in SDWebImageManager&rsquo;s runningOperations, and the reference here is saved to easy cancel the task.</p>
<h3 id="sdwebimagecontext">SDWebImageContext</h3>
<blockquote>
<p>A SDWebImageContext object which hold the original context options from top-level API.</p>
</blockquote>
<p>Image context runs through the entire workflow of image processing. It brings data into each processing task step by step. There are two types of ImageContext:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">typedef</span> NSString <span style="color:#719e07">*</span> SDWebImageContextOption NS_EXTENSIBLE_STRING_ENUM;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">typedef</span> NSDictionary<span style="color:#719e07">&lt;</span>SDWebImageContextOption, <span style="color:#dc322f">id</span><span style="color:#719e07">&gt;</span> SDWebImageContext;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">typedef</span> NSMutableDictionary<span style="color:#719e07">&lt;</span>SDWebImageContextOption, <span style="color:#dc322f">id</span><span style="color:#719e07">&gt;</span>SDWebImageMutableContext;
</code></pre></div><p>SDWebImageContextOption is an extensible String enumeration, there are currently 15 types. Basically, you can guess its function just by looking at the name, here is the <a href="https://github.com/SDWebImage/SDWebImage/blob/5c3c40288f7e465ba94db9736e624f663831951a/SDWebImage/Core/SDWebImageDefine.h">document</a>, summarized as follows:</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cgy1gcbeto2gb6j20xj1whajv.jpg" alt="image context"></p>
<h2 id="imageprefetcher">ImagePrefetcher</h2>
<p>Prefetcher has nothing to do with the entire processing stream of SD. It mainly uses imageManger for batch image download. Below is the core method:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (nullable SDWebImagePrefetchToken <span style="color:#719e07">*</span>)<span style="color:#268bd2">prefetchURLs:</span>(nullable NSArray<span style="color:#719e07">&lt;</span>NSURL <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>)<span style="color:#268bd2">urls</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>                                          <span style="color:#268bd2">progress:</span>(nullable SDWebImagePrefetcherProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>                                         <span style="color:#268bd2">completed:</span>(nullable SDWebImagePrefetcherCompletionBlock)<span style="color:#268bd2">completionBlock</span>;
</code></pre></div><p>It stores the downloaded URLs as <code>transactions</code> in <code>SDWebImagePrefetchToken</code>,  which do not cancel previous request and it separate different prefetching process. When you call <code>prefetchURLs</code> for different url lists, you can get callback for different completion block.</p>
<p>Each download task is in the autoreleasesepool, and will use <code>SDAsyncBlockOperation</code> to wrap the real download task to achieve the cancelable operation of the task:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    @weakify(<span style="color:#b58900">self</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    SDAsyncBlockOperation <span style="color:#719e07">*</span>prefetchOperation <span style="color:#719e07">=</span> [SDAsyncBlockOperation blockOperationWithBlock:<span style="color:#719e07">^</span>(SDAsyncBlockOperation <span style="color:#719e07">*</span> _Nonnull asyncOperation) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        @strongify(<span style="color:#b58900">self</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span><span style="color:#b58900">self</span> <span style="color:#719e07">||</span> asyncOperation.isCancelled) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>            <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#586e75">/// load Image ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"></span>    }];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">@synchronized</span> (token) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        [token.prefetchOperations addPointer:(<span style="color:#719e07">__bridge</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>)prefetchOperation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    [<span style="color:#b58900">self</span>.prefetchQueue addOperation:prefetchOperation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
</code></pre></div><p>Finally, the task is stored in prefetchQueue, which limit the maximum number of downloads to 3 by default. The real task of URLs downloading is in <code>token.loadOperations</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSPointerArray <span style="color:#719e07">*</span>operations <span style="color:#719e07">=</span> token.loadOperations;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span> operation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.manager loadImageWithURL:url options:<span style="color:#b58900">self</span>.options context:<span style="color:#b58900">self</span>.context progress:<span style="color:#b58900">nil</span> completed:<span style="color:#719e07">^</span>(UIImage <span style="color:#719e07">*</span> _Nullable image, NSData <span style="color:#719e07">*</span> _Nullable data, NSError <span style="color:#719e07">*</span> _Nullable error, SDImageCacheType cacheType, <span style="color:#dc322f">BOOL</span> finished, NSURL <span style="color:#719e07">*</span> _Nullable imageURL) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">/// progress handler    
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>}];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>NSAssert(operation <span style="color:#719e07">!=</span> <span style="color:#b58900">nil</span>, <span style="color:#2aa198">@&#34;Operation should not be nil, [SDWebImageManager loadImageWithURL:options:context:progress:completed:] break prefetch logic&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@synchronized</span> (token) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    [operations addPointer:(<span style="color:#719e07">__bridge</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>)operation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p><code>loadOperations</code> and <code>prefetchOperations</code> All use <strong>NSPointerArray</strong>, which uses its [NSPointerFunctionsWeakMemory](apple-reference-documentation: // hcx77yk4jV) feature and can store <code> Null</code> values, although its performance is not very good, see: <a href="https://objccn.io/issue-7-1/">basic collection Class</a></p>
<p>Another important thing is that PrefetchToken use the <a href="https://zhuanlan.zhihu.com/p/45566448">c++11 memory_order_relaxed</a> to ensure the thread-safe。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>atomic_ulong _skippedCount;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>atomic_ulong _finishedCount;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>atomic_flag  _isAllFinished;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> _totalCount;
</code></pre></div><p>Simply, it use memory order and atomic operations to achieve lock-free concurrency and improving efficiency.</p>
<h2 id="imageloader">ImageLoader</h2>
<p>ImageLoader is the default implementation of the <code>SDImageLoader</code> protocol, which provides HTTP / HTTPS / FTP or local URL NSURLSession source image acquisition capabilities. And it also maximizes the configurability of the entire download process. Main interface as fellow:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">SDWebImageDownloader</span> : <span style="color:#268bd2">NSObject</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">copy</span>, <span style="color:#719e07">readonly</span>, nonnull) SDWebImageDownloaderConfig <span style="color:#719e07">*</span>config;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderRequestModifier<span style="color:#719e07">&gt;</span> requestModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderResponseModifier<span style="color:#719e07">&gt;</span> responseModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderDecryptor<span style="color:#719e07">&gt;</span> decryptor;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75">/* ... */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>-(nullable SDWebImageDownloadToken <span style="color:#719e07">*</span>)<span style="color:#268bd2">downloadImageWithURL:</span>(nullable NSURL <span style="color:#719e07">*</span>)<span style="color:#268bd2">url</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#268bd2">options:</span>(SDWebImageDownloaderOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>   <span style="color:#268bd2">progress:</span>(nullable SDWebImageDownloaderProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>  <span style="color:#268bd2">completed:</span>(nullable SDWebImageDownloaderCompletedBlock)<span style="color:#268bd2">completedBlock</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#719e07">@end</span>
</code></pre></div><p>the <strong>downloaderConfig</strong> supports the NSCopy protocol, below is the main configurations provided:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">/// The maximum number of concurrent downloads.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>) NSInteger maxConcurrentDownloads;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75">/// The timeout value (in seconds) for each download operation.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>) NSTimeInterval downloadTimeout;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75">/// The session configuration, it&#39;s immutable after the downloader instance initialized. 
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) NSURLSessionConfiguration <span style="color:#719e07">*</span>sessionConfiguration;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75">/// Passing `NSOperation&lt;SDWebImageDownloaderOperation&gt;` to set as default. Passing `nil` will revert to `SDWebImageDownloaderOperation`.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>, nullable) <span style="color:#dc322f">Class</span> operationClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75">/// The download operations execution order, default is FIFO
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>) SDWebImageDownloaderExecutionOrder executionOrder;
</code></pre></div><p>the <strong>requestModifier</strong>, provide modification before download request,</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// Modify the original URL request and return a new one instead. You can modify the HTTP header, cachePolicy, etc for this URL.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">SDWebImageDownloaderRequestModifier</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">-</span> (nullable NSURLRequest <span style="color:#719e07">*</span>)modifiedRequestWithRequest:(nonnull NSURLRequest <span style="color:#719e07">*</span>)request;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@end</span>
</code></pre></div><p>Similarly, the <strong>responseModifier</strong> provides modification of the return value,</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// Modify the original URL response and return a new response. You can use this to check MIME-Type, mock server response, etc.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">SDWebImageDownloaderResponseModifier</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">-</span> (nullable NSURLResponse <span style="color:#719e07">*</span>)modifiedResponseWithResponse:(nonnull NSURLResponse <span style="color:#719e07">*</span>)response;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">@end</span>
</code></pre></div><p>The last <strong>decryptor</strong> is used for image decryption, which provides base64 conversion of imageData by default.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// Decrypt the original download data and return a new data. You can use this to decrypt the data using your perfereed algorithm.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">SDWebImageDownloaderDecryptor</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">-</span> (nullable NSData <span style="color:#719e07">*</span>)decryptedDataWithData:(nonnull NSData <span style="color:#719e07">*</span>)data response:(nullable NSURLResponse <span style="color:#719e07">*</span>)response;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@end</span>
</code></pre></div><p>Processing data through these protocolded objects origins the <strong><a href="https://www.wikiwand.com/en/Strategy_pattern">strategy pattern</a></strong>. By obtaining the protocol object through configuration, the caller only needs to care about the method provided by the protocol object, and does not need to care about its internal implementation to achieve the purpose of decoupling.</p>
<p>###DownloadImageWithURL</p>
<p>Before downloading, check whether the URL exists.</p>
<p>If not, directly throw an error and return. After getting the URL, try to reuse the operation generated before:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSOperation<span style="color:#719e07">&lt;</span>SDWebImageDownloaderOperation<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>operation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.URLOperations objectForKey:url];
</code></pre></div><p>If operation exists, call</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@synchronized</span> (operation) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    downloadOperationCancelToken <span style="color:#719e07">=</span> [operation addHandlersForProgress:progressBlock completed:completedBlock];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>And set the queuePriority. Here the <code>@synchronized (operation)</code> is used to compare the <code>@synchronized (self)</code>, which is used inside the operation to ensure the thread safety of the operation between two different classes. Because the operation may be passed to the decoding or proxy queue.</p>
<p>Then  <code>addHandlersForProgres</code> method will save progressBlock and completedBlock into <code>NSMutableDictionary &lt;NSString *, id&gt; SDCallbacksDictionary</code> and then return and save it into downloadOperationCancelToken.</p>
<p>In addition, operation in <code>addHandlersForProgress</code> method does not clear the previous stored callbacks. They are saved increamently, which means that all the callBacks will be executed in sequence after download completion.</p>
<p>If the operation is nil、isFinished or isCancelled will call <code>createDownloaderOperationWithUrl:options:context:</code> to create a new operation and store it in URLOperations and configure completionBlock. So that URLOperations can be cleared when the task is completed. Then call <code>addHandlersForProgress:completed:</code> to save progressBlock and completedBlock. At last submit operation to the downloadQueue.</p>
<p>The final operation, url, request, and downloadOperationCancelToken are packaged into <strong>SDWebImageDownloadToken</strong>, which the end of the download task.</p>
<p>###CreateDownloaderOperation</p>
<p>After downloading, let&rsquo;s talk about how the operation is created. The first is to generate a URLRequest:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>NSURLRequestCachePolicy cachePolicy <span style="color:#719e07">=</span> options <span style="color:#719e07">&amp;</span> SDWebImageDownloaderUseNSURLCache <span style="color:#719e07">?</span> NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>NSMutableURLRequest <span style="color:#719e07">*</span>mutableRequest <span style="color:#719e07">=</span> [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>mutableRequest.HTTPShouldHandleCookies <span style="color:#719e07">=</span> SD_OPTIONS_CONTAINS(options, SDWebImageDownloaderHandleCookies);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>mutableRequest.HTTPShouldUsePipelining <span style="color:#719e07">=</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>SD_LOCK(<span style="color:#b58900">self</span>.HTTPHeadersLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>mutableRequest.allHTTPHeaderFields <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>.HTTPHeaders;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>SD_UNLOCK(<span style="color:#b58900">self</span>.HTTPHeadersLock);
</code></pre></div><p>It is mainly configured by obtaining parameters through SDWebImageDownloaderOptions. The timeout is determined by downloader&rsquo;s <code>config.downloadTimeout</code>, the default is 15s.</p>
<p>Then remove <code>id &lt;SDWebImageDownloaderRequestModifier&gt; requestModifier</code> from imageContext to transform the request.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Request Modifier
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderRequestModifier<span style="color:#719e07">&gt;</span> requestModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">if</span> ([context valueForKey:SDWebImageContextDownloadRequestModifier]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    requestModifier <span style="color:#719e07">=</span> [context valueForKey:SDWebImageContextDownloadRequestModifier];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    requestModifier <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>.requestModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>}
</code></pre></div><p>What you need to pay attention to is that the access to requestModifier has <strong>priority</strong>, and the priority obtained through imageContext is higher than the downloader. This kind of method not only satisfies the controllability of the caller, but also supports the global configuration, which is suitable for all ages.</p>
<p>Similarly, <code>id &lt;SDWebImageDownloaderResponseModifier&gt; responseModifier</code> and<code> id &lt;SDWebImageDownloaderDecryptor&gt; decryptor</code> are also the same approach.</p>
<p>After that, the confirmed responseModifier and decryptor will be saved in imageContext again for later use.</p>
<p>Finally, remove operationClass from downloaderConfig to create operation:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">Class</span> operationClass <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>.config.operationClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">if</span> (operationClass <span style="color:#719e07">&amp;&amp;</span> [operationClass isSubclassOfClass:[NSOperation <span style="color:#719e07">class</span>]] <span style="color:#719e07">&amp;&amp;</span> [operationClass conformsToProtocol:@protocol(SDWebImageDownloaderOperation)]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">// Custom operation class
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    operationClass <span style="color:#719e07">=</span> [SDWebImageDownloaderOperation <span style="color:#719e07">class</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>NSOperation<span style="color:#719e07">&lt;</span>SDWebImageDownloaderOperation<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>operation <span style="color:#719e07">=</span> [[operationClass alloc] initWithRequest:request inSession:<span style="color:#b58900">self</span>.session options:options context:context];
</code></pre></div><p>Set the <em>credential, minimumProgressInterval, queuePriority, pendingOperation</em>.</p>
<p>By default, each task is added to the downloadQueue in FIFO order. If you set it as LIFO, the task priority will be modified before adding to the queue:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (<span style="color:#b58900">self</span>.config.executionOrder <span style="color:#719e07">==</span> SDWebImageDownloaderLIFOExecutionOrder) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#586e75">// Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"></span>    <span style="color:#586e75">// This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>    <span style="color:#586e75">// Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#586e75"></span>    <span style="color:#719e07">for</span> (NSOperation <span style="color:#719e07">*</span>pendingOperation <span style="color:#719e07">in</span> <span style="color:#b58900">self</span>.downloadQueue.operations) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        [pendingOperation addDependency:operation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p>###Data Processing</p>
<p>SDWebImageDownloaderOperation is also a protocolization class, which confirm NSURLSessionTaskDelegate, NSURLSessionDataDelegate. It handles URL request data, supports background downloading, supports responseData modification (by responseModifier), and supports download ImageData decryption (by decryptor). The main internal properties are as follows:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readwrite</span>) SDWebImageDownloaderOptions options;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">copy</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readwrite</span>, nullable) SDWebImageContext <span style="color:#719e07">*</span>context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nonnull) NSMutableArray<span style="color:#719e07">&lt;</span>SDCallbacksDictionary <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>callbackBlocks;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSMutableData <span style="color:#719e07">*</span>imageData;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">copy</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSData <span style="color:#719e07">*</span>cachedData; <span style="color:#586e75">// for `SDWebImageDownloaderIgnoreCachedResponse`
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger expectedSize; <span style="color:#586e75">// may be 0
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger receivedSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderResponseModifier<span style="color:#719e07">&gt;</span> responseModifier; <span style="color:#586e75">// modifiy original URLResponse
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderDecryptor<span style="color:#719e07">&gt;</span> decryptor; <span style="color:#586e75">// decrypt image data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75">// This is weak because it is injected by whoever manages this session. If this gets nil-ed out, we won&#39;t be able to run
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75">// the task associated with this operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">weak</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSURLSession <span style="color:#719e07">*</span>unownedSession;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75">// This is set if we&#39;re using not using an injected NSURLSession. We&#39;re responsible of invalidating this one
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSURLSession <span style="color:#719e07">*</span>ownedSession;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nonnull) dispatch_queue_t coderQueue; <span style="color:#586e75">// the queue to do image decoding
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span><span style="color:#586e75"></span><span style="color:#719e07">#if SD_UIKIT
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) UIBackgroundTaskIdentifier backgroundTaskId;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>- (nonnull <span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithRequest:</span>(nullable NSURLRequest <span style="color:#719e07">*</span>)<span style="color:#268bd2">request</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>                              <span style="color:#268bd2">inSession:</span>(nullable NSURLSession <span style="color:#719e07">*</span>)<span style="color:#268bd2">session</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>                                <span style="color:#268bd2">options:</span>(SDWebImageDownloaderOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>                                <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>;
</code></pre></div><p>There is nothing special about initialization. You should noted that the <code>nullable session</code> passed here is saved with unownedSessin, which is different from the <strong>ownedSession</strong> generated by default internally. If the session is empty during initialization, the ownedSession will be created at <code>start</code>.</p>
<p>Then the problem is coming, because we need to observe the various states of the session, we need to set up the delegate.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>[NSURLSession sessionWithConfiguration:delegate:delegateQueue:];
</code></pre></div><p>The delegate of the ownedSession is undoubtedly inside the operation, while the delegate of unownedSessin is the downloader. It will retrieve the operation through taskID and forwarding of the callback through the operation&rsquo;s delegate. Here is the code:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">URLSession:</span>(NSURLSession <span style="color:#719e07">*</span>)<span style="color:#268bd2">session</span> <span style="color:#268bd2">task:</span>(NSURLSessionTask <span style="color:#719e07">*</span>)<span style="color:#268bd2">task</span> <span style="color:#268bd2">didCompleteWithError:</span>(NSError <span style="color:#719e07">*</span>)<span style="color:#268bd2">error</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">// Identify the operation that runs this task and pass it the delegate method
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>    NSOperation<span style="color:#719e07">&lt;</span>SDWebImageDownloaderOperation<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>dataOperation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> operationWithTask:task];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    <span style="color:#719e07">if</span> ([dataOperation respondsToSelector:<span style="color:#719e07">@selector</span>(URLSession:task:didCompleteWithError:)]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        [dataOperation URLSession:session task:task didCompleteWithError:error];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p>Then, as a real consumer operation trigger the download task. The entire download process including start, end, and cancellation will send corresponding notifications.</p>
<ol>
<li>
<p>In <strong>didReceiveResponse</strong>, <code>response.expectedContentLength</code> will be saved as expectedSize. Then call <code>modifiedResponseWithResponse:</code> to save the edited response.</p>
</li>
<li>
<p>Every time <strong>didReceiveData</strong> will append data to imageData: <code>[self.imageData appendData: data]</code>, update receivedSize<code>self.receivedSize = self.imageData.length</code>. Finally, when receivedSize bigger then expectedSize, which means the download task is completed,  and move to the next stage. If you support <code>SDWebImageDownloaderProgressiveLoad</code>, you will be able to decoding while downloading in coderQueue:</p>
</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">// progressive decode the image in coder queue
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span>dispatch_async(<span style="color:#b58900">self</span>.coderQueue, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        UIImage <span style="color:#719e07">*</span>image <span style="color:#719e07">=</span> SDImageLoaderDecodeProgressiveImageData(imageData, <span style="color:#b58900">self</span>.request.URL, finished, <span style="color:#b58900">self</span>, [[<span style="color:#b58900">self</span> <span style="color:#719e07">class</span>] imageOptionsFromDownloaderOptions:<span style="color:#b58900">self</span>.options], <span style="color:#b58900">self</span>.context);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#719e07">if</span> (image) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>            <span style="color:#586e75">// We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span>            
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            [<span style="color:#b58900">self</span> callCompletionBlocksWithImage:image imageData:<span style="color:#b58900">nil</span> error:<span style="color:#b58900">nil</span> finished:<span style="color:#b58900">NO</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>});
</code></pre></div><p>​		Otherwise, the decoding operation will be completed when <strong>didCompleteWithError</strong>: <code>SDImageLoaderDecodeImageData</code>, but you need to decrypt it before decoding:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (imageData <span style="color:#719e07">&amp;&amp;</span> <span style="color:#b58900">self</span>.decryptor) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    imageData <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.decryptor decryptedDataWithData:imageData response:<span style="color:#b58900">self</span>.response];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>​	3. Handle the complete callback;</p>
<p><em>We will talk about the logic of decode finally.</em></p>
<h2 id="imagecache">ImageCache</h2>
<p>The design of Cache classes are consistent with the ImageLoader. There will be a <strong>SDImageCacheConfig</strong> to configure the cache expiration time, capacity, read and write permissions, and dynamically MemoryCache / DiskCache class.</p>
<p>The main properties of SDImageCacheConfig are as follows:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldDisableiCloud;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldCacheImagesInMemory;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldUseWeakMemoryCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldRemoveExpiredDataWhenEnterBackground;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSDataReadingOptions diskCacheReadingOptions;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSDataWritingOptions diskCacheWritingOptions;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSTimeInterval maxDiskAge;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger maxDiskSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger maxMemoryCost;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger maxMemoryCount;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) SDImageCacheConfigExpireType diskCacheExpireType;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75">/// Defaults to built-in `SDMemoryCache` class.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>, nonnull) <span style="color:#dc322f">Class</span> memoryCacheClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#586e75">/// Defaults to built-in `SDDiskCache` class.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span> ,<span style="color:#719e07">nonatomic</span>, nonnull) <span style="color:#dc322f">Class</span> diskCacheClass;
</code></pre></div><p>MemoryCache and DiskCache instantiation depends on SDImageCacheConfig:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// SDMemoryCache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>- (nonnull <span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithConfig:</span>(nonnull SDImageCacheConfig <span style="color:#719e07">*</span>)<span style="color:#268bd2">config</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75">/// SDDiskCache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>- (nullable <span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithCachePath:</span>(nonnull NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">cachePath</span> <span style="color:#268bd2">config:</span>(nonnull SDImageCacheConfig <span style="color:#719e07">*</span>)<span style="color:#268bd2">config</span>;
</code></pre></div><p>As a cache protocol, their interface declarations are basically the same, all of which are CURD for data. The difference is that MemoryCache Protocl operates on the <strong>id</strong> type (NSCache&rsquo;s limitation), and DiskCache is on NSData.</p>
<h3 id="sdmemorycache">SDMemoryCache</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/**
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"> A memory cache which auto purge the cache on memory warning and support weak cache.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"> */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">SDMemoryCache</span> <span style="color:#719e07">&lt;</span>KeyType, ObjectType<span style="color:#719e07">&gt;</span> <span style="color:#719e07">:</span> NSCache <span style="color:#719e07">&lt;</span>KeyType, ObjectType<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&lt;</span>SDMemoryCache<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nonnull, <span style="color:#719e07">readonly</span>) SDImageCacheConfig <span style="color:#719e07">*</span>config;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">@end</span>
</code></pre></div><p>Internally, <strong>NSCache</strong> is the implementation for SDMemoryCache, and add <strong>NSMapTable &lt;KeyType, ObjectType&gt; * weakCache</strong> property, which use semaphore lock to ensure thread safety. The weak-cache is a feature added only on the <em>iOS / tvOS</em> platform, because on macOS, NSCache will not clear the corresponding cache, when receiving system memory warning. WeakCache uses strong-weak references without additional memory overhead and does not affect the life cycle of the object.</p>
<p>The role of weakCache is to restore the cache. It is controlled by the <strong>shouldUseWeakMemoryCache</strong> switch of CacheConfig. For details, you can check the <a href="https://github.com/SDWebImage/SDWebImage/blob/master/SDWebImage/Core/SDImageCacheConfig.h">CacheConfig</a>.</p>
<p>First, look at how <em>objectForKey</em> is implemented:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>- (<span style="color:#dc322f">id</span>)<span style="color:#268bd2">objectForKey:</span>(<span style="color:#dc322f">id</span>)<span style="color:#268bd2">key</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#dc322f">id</span> obj <span style="color:#719e07">=</span> [<span style="color:#b58900">super</span> objectForKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span><span style="color:#b58900">self</span>.config.shouldUseWeakMemoryCache) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">return</span> obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">if</span> (key <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">!</span>obj) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#586e75">// Check weak cache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span>        SD_LOCK(<span style="color:#b58900">self</span>.weakCacheLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        obj <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.weakCache objectForKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        SD_UNLOCK(<span style="color:#b58900">self</span>.weakCacheLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        <span style="color:#719e07">if</span> (obj) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            <span style="color:#586e75">// Sync cache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75"></span>            NSUInteger cost <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            <span style="color:#719e07">if</span> ([obj isKindOfClass:[UIImage <span style="color:#719e07">class</span>]]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                cost <span style="color:#719e07">=</span> [(UIImage <span style="color:#719e07">*</span>)obj sd_memoryCost];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            [<span style="color:#b58900">super</span> setObject:obj forKey:key cost:cost];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    <span style="color:#719e07">return</span> obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>}
</code></pre></div><p>Since NSCache follows  <a href="apple-reference-documentation://hcnVx1bA-q"><code>NSDiscardableContent</code></a> to store temporary objects. When the memory is tight, the cached objects may be cleaned up by the system. At this time, once the application accesses MemoryCache and the cache missing, which will be transferred to the diskCache query operation. And that may cause the image to flicker. And when shouldUseWeakMemoryCache is true, because weakCache holds the weak reference of the object (when the object is cleaned by NSCache but not released), we can get the cache by weakCache and stuff it into NSCache, which will reduces disk I/O.</p>
<h3 id="sddiskcache">SDDiskCache</h3>
<p>This is simpler, internally uses NSFileManager to manage the reading and writing of image data, and calls SDDiskCacheFileNameForKey to process the key MD5 as fileName and store it in the diskCachePath directory. The other is to clear the expired cache:</p>
<ol>
<li>Sort by SDImageCacheConfigExpireType to get <code>NSDirectoryEnumerator * fileEnumerator</code> and start filtering;</li>
<li>Use <code>cacheConfig.maxDiskAage</code> to determine whether it is expired, and store the expired URL in urlsToDelete;</li>
<li>Call <code>[self.fileManager removeItemAtURL: fileURL error: nil];</code></li>
<li>According to <code>cacheConfig.maxDiskSize</code> to delete the data cached on the disk, clean up to 1/2 of maxDiskSize.</li>
</ol>
<p>By the way, SDDiskCache, like <strong><a href="https://github.com/ibireme/YYCache/blob/master/YYCache/YYKVStorage.h">YYKVStorage</a></strong>, also supports adding extendData to UIImage to store additional information, for example, the zoom ratio of the picture, <a href="https://sspai.com/post/55279">URL rich link</a>, time And other data.</p>
<p>However, <strong>YYKVStorage</strong> store the extended_data field by the <em><strong>manifest</strong></em> table in the database. SDDiskCache solution is a different way, by use system API &lt;sys/xattr.h&gt; <strong>setxattr</strong>, <strong>getxattr</strong>, <strong>listxattr</strong> to save extendData, which is really amazing. One more thing, the corresponding key is <em>SDDiskCacheExtendedAttributeName</em>.</p>
<h3 id="sdimagecache">SDImageCache</h3>
<p>It is also a protocold class, which is responsible for scheduling SDMemoryCache and SDDiskCache, and its Properties are as follows:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, <span style="color:#719e07">readwrite</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDMemoryCache<span style="color:#719e07">&gt;</span> memoryCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, <span style="color:#719e07">readwrite</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDDiskCache<span style="color:#719e07">&gt;</span> diskCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">copy</span>, <span style="color:#719e07">readwrite</span>, nonnull) SDImageCacheConfig <span style="color:#719e07">*</span>config;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">copy</span>, <span style="color:#719e07">readwrite</span>, nonnull) NSString <span style="color:#719e07">*</span>diskCachePath;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) dispatch_queue_t ioQueue;
</code></pre></div><blockquote>
<p>Note: The memoryCache and diskCache instances are generated according to the class defined in CacheConfig, and the defaults are SDMemoryCache and SDDiskCache.</p>
</blockquote>
<p>Let&rsquo;s take a look at its core method:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">storeImage:</span>(nullable UIImage <span style="color:#719e07">*</span>)<span style="color:#268bd2">image</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>         <span style="color:#268bd2">imageData:</span>(nullable NSData <span style="color:#719e07">*</span>)<span style="color:#268bd2">imageData</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>            <span style="color:#268bd2">forKey:</span>(nullable NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">key</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>          <span style="color:#268bd2">toMemory:</span>(<span style="color:#dc322f">BOOL</span>)<span style="color:#268bd2">toMemory</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>            <span style="color:#268bd2">toDisk:</span>(<span style="color:#dc322f">BOOL</span>)<span style="color:#268bd2">toDisk</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        <span style="color:#268bd2">completion:</span>(nullable SDWebImageNoParamsBlock)<span style="color:#268bd2">completionBlock</span>;
</code></pre></div><ol>
<li>
<p>Make sure that image and key exist;</p>
</li>
<li>
<p>When <strong>shouldCacheImagesInMemory</strong> is YES, it calls <code>[self.memoryCache setObject:image forKey:key cost:cost]</code> to write memoryCache;</p>
</li>
<li>
<p>Write diskCache, put the operation logic into ioQueue and autoreleasepool.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_async(<span style="color:#b58900">self</span>.ioQueue, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        NSData <span style="color:#719e07">*</span>data <span style="color:#719e07">=</span> ... <span style="color:#586e75">// 根据 SDImageFormat 对 image 进行编码获取
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>        <span style="color:#586e75">/// data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil];
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"></span>        [<span style="color:#b58900">self</span> _storeImageDataToDisk:data forKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">if</span> (image) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>            <span style="color:#586e75">// Check extended data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span>            <span style="color:#dc322f">id</span> extendedObject <span style="color:#719e07">=</span> image.sd_extendedObject;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            <span style="color:#586e75">// ... get extended data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span>            [<span style="color:#b58900">self</span>.diskCache setExtendedData:extendedData forKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#586e75">// call completionBlock in main queue
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#586e75"></span>});
</code></pre></div></li>
</ol>
<p>Another important method is image query, which is defined in the SDImageCache protocol:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>- (<span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span>)<span style="color:#268bd2">queryImageForKey:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">key</span> <span style="color:#268bd2">options:</span>(SDWebImageOptions)<span style="color:#268bd2">options</span> <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span> <span style="color:#268bd2">completion:</span>(nullable SDImageCacheQueryCompletionBlock)<span style="color:#268bd2">completionBlock</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    SDImageCacheOptions cacheOptions <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageQueryMemoryData) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheQueryMemoryData;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageQueryMemoryDataSync) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheQueryMemoryDataSync;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageQueryDiskDataSync) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheQueryDiskDataSync;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageScaleDownLargeImages) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheScaleDownLargeImages;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageAvoidDecodeImage) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheAvoidDecodeImage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageDecodeFirstFrameOnly) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheDecodeFirstFrameOnly;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImagePreloadAllFrames) cacheOptions <span style="color:#719e07">|=</span> SDImageCachePreloadAllFrames;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageMatchAnimatedImageClass) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheMatchAnimatedImageClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">return</span> [<span style="color:#b58900">self</span> queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>}
</code></pre></div><p><strong>queryImageForKey</strong> converts SDWebImageOptions to SDImageCacheOptions, then call <code>queryCacheOperationForKey:</code>, which logic is as follows:</p>
<p>First, First, if the query key exists, the transformer will be obtained from the imageContext and the query key will be converted:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>key <span style="color:#719e07">=</span> SDTransformedKeyForKey(key, transformerKey);
</code></pre></div><p>Try to get the image from the memory cache, if it exists:</p>
<ol>
<li>
<p>If SDImageCacheDecodeFirstFrameOnly is satisfied and comforts to SDAnimatedImage protocol, CGImage will be taken out for conversion</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Ensure static image
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">Class</span> animatedImageClass <span style="color:#719e07">=</span> image.<span style="color:#719e07">class</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">if</span> (image.sd_isAnimated <span style="color:#719e07">||</span> ([animatedImageClass isSubclassOfClass:[UIImage <span style="color:#719e07">class</span>]] <span style="color:#719e07">&amp;&amp;</span> [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)])) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">#if SD_MAC
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07"></span>    image <span style="color:#719e07">=</span> [[NSImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:kCGImagePropertyOrientationUp];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07"></span>    image <span style="color:#719e07">=</span> [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span><span style="color:#719e07"></span>}
</code></pre></div></li>
<li>
<p>If SDImageCacheMatchAnimatedImageClass is satisfied, it will be forced to check whether the image type matches, otherwise the data will be nil:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Check image class matching
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">Class</span> animatedImageClass <span style="color:#719e07">=</span> image.<span style="color:#719e07">class</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#dc322f">Class</span> desiredImageClass <span style="color:#719e07">=</span> context[SDWebImageContextAnimatedImageClass];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">if</span> (desiredImageClass <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">!</span>[animatedImageClass isSubclassOfClass:desiredImageClass]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    image <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
</code></pre></div></li>
</ol>
<p>When the image can be obtained from the memory cache and is SDImageCacheQueryMemoryData, return directly, otherwise continue;</p>
<p>Start reading diskCache, and use shouldQueryDiskSync to specify query cache sync/async behavior.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Check whether we need to synchronously query disk
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75">// 1. in-memory cache hit &amp; memoryDataSync
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75">// 2. in-memory cache miss &amp; diskDataSync
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span><span style="color:#dc322f">BOOL</span> shouldQueryDiskSync <span style="color:#719e07">=</span> ((image <span style="color:#719e07">&amp;&amp;</span> options <span style="color:#719e07">&amp;</span> SDImageCacheQueryMemoryDataSync) <span style="color:#719e07">||</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>                            (<span style="color:#719e07">!</span>image <span style="color:#719e07">&amp;&amp;</span> options <span style="color:#719e07">&amp;</span> SDImageCacheQueryDiskDataSync));
</code></pre></div><p>The entire diskQuery is stored in queryDiskBlock and wrapped with autorelease:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span>(<span style="color:#719e07">^</span>queryDiskBlock)(<span style="color:#dc322f">void</span>) <span style="color:#719e07">=</span>  <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (operation.isCancelled) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#586e75">// call doneBlock &amp; return
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        NSData <span style="color:#719e07">*</span>diskData <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> diskImageDataBySearchingAllPathsForKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        UIImage <span style="color:#719e07">*</span>diskImage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        SDImageCacheType cacheType <span style="color:#719e07">=</span> SDImageCacheTypeNone;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#719e07">if</span> (image) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            <span style="color:#586e75">// the image is from in-memory cache, but need image data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>            diskImage <span style="color:#719e07">=</span> image;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            cacheType <span style="color:#719e07">=</span> SDImageCacheTypeMemory;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        } <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> (diskData) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            cacheType <span style="color:#719e07">=</span> SDImageCacheTypeDisk;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            <span style="color:#586e75">// decode image data only if in-memory cache missed
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#586e75"></span>            diskImage <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> diskImageForKey:key data:diskData options:options context:context];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            <span style="color:#719e07">if</span> (diskImage <span style="color:#719e07">&amp;&amp;</span> <span style="color:#b58900">self</span>.config.shouldCacheImagesInMemory) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                NSUInteger cost <span style="color:#719e07">=</span> diskImage.sd_memoryCost;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>                [<span style="color:#b58900">self</span>.memoryCache setObject:diskImage forKey:key cost:cost];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#586e75">// call doneBlock
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span><span style="color:#586e75"></span>        <span style="color:#719e07">if</span> (doneBlock) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>            <span style="color:#719e07">if</span> (shouldQueryDiskSync) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>                doneBlock(diskImage, diskData, cacheType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>                dispatch_async(dispatch_get_main_queue(), <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>                    doneBlock(diskImage, diskData, cacheType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>                });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>}
</code></pre></div><p>For large amounts of temporary memory operations, SD will put it into autoreleasepool to ensure that the memory can be released in time.</p>
<p><strong>Special emphasis</strong>, once the code is executed here, there must be disk querying operations, so if you don&rsquo;t have to get imageData, you can use <strong>SDImageCacheQueryMemoryData</strong> to improve query efficiency.</p>
<p>One more thing, the conversion logic of <code>SDTransformedKeyForKey</code> is the transformerKey of <strong>SDImageTransformer</strong>, which is spliced behind the image key in order. E.g:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>&#39;image.png&#39; <span style="color:#719e07">|&gt;</span> flip(<span style="color:#b58900">YES</span>,<span style="color:#b58900">NO</span>) <span style="color:#719e07">|&gt;</span> rotate(pi<span style="color:#719e07">/</span><span style="color:#2aa198">4</span>,<span style="color:#b58900">YES</span>)  <span style="color:#719e07">=&gt;</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>&#39;image<span style="color:#719e07">-</span>SDImageFlippingTransformer(<span style="color:#2aa198">1</span>,<span style="color:#2aa198">0</span>)<span style="color:#719e07">-</span>SDImageRotationTransformer(<span style="color:#2aa198">0.78539816339</span>,<span style="color:#2aa198">1</span>).png&#39;
</code></pre></div><h2 id="sdimagemanaer">SDImageManaer</h2>
<p>SDImageManger serves as the dispatch center of the entire library, who is the master of the above various logics. It connects the components in series, from View &gt; Downloading &gt; Decodering &gt; Cache. The only core method it exposes is <strong>loadImage</strong>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageCache<span style="color:#719e07">&gt;</span> imageCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageLoader<span style="color:#719e07">&gt;</span> imageLoader;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageTransformer<span style="color:#719e07">&gt;</span> transformer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageCacheKeyFilter<span style="color:#719e07">&gt;</span> cacheKeyFilter;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageCacheSerializer<span style="color:#719e07">&gt;</span> cacheSerializer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOptionsProcessor<span style="color:#719e07">&gt;</span> optionsProcessor;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">class</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageCache<span style="color:#719e07">&gt;</span> defaultImageCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">class</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageLoader<span style="color:#719e07">&gt;</span> defaultImageLoader;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>- (nullable SDWebImageCombinedOperation <span style="color:#719e07">*</span>)<span style="color:#268bd2">loadImageWithURL:</span>(nullable NSURL <span style="color:#719e07">*</span>)<span style="color:#268bd2">url</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>                                                   <span style="color:#268bd2">options:</span>(SDWebImageOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>                                                   <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>                                                  <span style="color:#268bd2">progress:</span>(nullable SDImageLoaderProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                                                 <span style="color:#268bd2">completed:</span>(nonnull SDInternalCompletionBlock)<span style="color:#268bd2">completedBlock</span>;
</code></pre></div><p>Let&rsquo;s briefly talk about the three left APIs cacheKeyFilter, cacheSerializer and optionsProcessor, the rest of which have been mentioned above.</p>
<p><strong>SDWebImageCacheKeyFilter</strong></p>
<p>By default, the <code>URL.absoluteString</code> is used as cacheKey, and if fileter is set, cacheKey will be replaced by <code>cacheKeyForURL:</code>;</p>
<p><strong>SDWebImageCacheSerializer</strong></p>
<p>By default, ImageCache will directly cache downloadData, and when we use other image formats for transmission, such as WEBP format, then the data with WEBP format will be storaged to the disk directly. This will cause a problem, every time when we query the image from the disk, we have to repeat the decoding operation. The CacheSerializer can directly convert downloadData to JPEG / PNG format NSData cache, thereby improving access efficiency.</p>
<p><strong>SDWebImageOptionsProcessor</strong></p>
<p>Used to control the global parameters in SDWebImageOptions and SDWebImageContext. E.g::</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>SDWebImageManager.sharedManager.optionsProcessor <span style="color:#719e07">=</span> [SDWebImageOptionsProcessor optionsProcessorWithBlock:<span style="color:#719e07">^</span>SDWebImageOptionsResult <span style="color:#719e07">*</span> _Nullable(NSURL <span style="color:#719e07">*</span> _Nullable url, SDWebImageOptions options, SDWebImageContext <span style="color:#719e07">*</span> _Nullable context) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>     <span style="color:#586e75">// Only do animation on `SDAnimatedImageView`
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"></span>     <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>context[SDWebImageContextAnimatedImageClass]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        options <span style="color:#719e07">|=</span> SDWebImageDecodeFirstFrameOnly;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>     <span style="color:#586e75">// Do not force decode for png url
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span>     <span style="color:#719e07">if</span> ([url.lastPathComponent isEqualToString:<span style="color:#2aa198">@&#34;png&#34;</span>]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        options <span style="color:#719e07">|=</span> SDWebImageAvoidDecodeImage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>     <span style="color:#586e75">// Always use screen scale factor
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>     SDWebImageMutableContext <span style="color:#719e07">*</span>mutableContext <span style="color:#719e07">=</span> [NSDictionary dictionaryWithDictionary:context];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>     mutableContext[SDWebImageContextImageScaleFactor] <span style="color:#719e07">=</span> @(UIScreen.mainScreen.scale);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>     context <span style="color:#719e07">=</span> [mutableContext <span style="color:#719e07">copy</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>     <span style="color:#719e07">return</span> [[SDWebImageOptionsResult alloc] initWithOptions:options context:context];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span> }];
</code></pre></div><h3 id="loadimage">LoadImage</h3>
<p>The first parameter of the method,  the <strong>url</strong>, which serves as the connection core of SD, was designed to be nullable. This design may be for the convenience of users. Internally through the nil judgment of the url and the compatibility with the NSString type (forced conversion to NSURL) to ensure the subsequent process, otherwise the call ends.</p>
<p>After the download started, it was split into the following 6 methods:</p>
<ul>
<li>callCacheProcessForOperation</li>
<li>callDownloadProcessForOperation</li>
<li>callStoreCacheProcessForOperation</li>
<li>callTransformProcessForOperation</li>
<li>callCompletionBlockForOperation</li>
<li>safelyRemoveOperationFromRunning</li>
</ul>
<p>They are cache query, download, storage, conversion, execution callback, and cleanup callback. You can find that each method is delivered through the operation, which will be ready when the loadImage is loaded, then trigger the cache query.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>SDWebImageCombinedOperation <span style="color:#719e07">*</span>operation <span style="color:#719e07">=</span> [SDWebImagCombinedOperation new];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>operation.manager <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75">///  1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"></span><span style="color:#dc322f">BOOL</span> isFailedUrl <span style="color:#719e07">=</span> <span style="color:#b58900">NO</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">if</span> (url) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    SD_LOCK(<span style="color:#b58900">self</span>.failedURLsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    isFailedUrl <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.failedURLs containsObject:url];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    SD_UNLOCK(<span style="color:#b58900">self</span>.failedURLsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">if</span> (url.absoluteString.length <span style="color:#719e07">==</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">||</span> (<span style="color:#719e07">!</span>(options <span style="color:#719e07">&amp;</span> SDWebImageRetryFailed) <span style="color:#719e07">&amp;&amp;</span> isFailedUrl)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    [<span style="color:#b58900">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@{NSLocalizedDescriptionKey : <span style="color:#2aa198">@&#34;Image url is nil&#34;</span>}] url:url];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#719e07">return</span> operation;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>SD_LOCK(<span style="color:#b58900">self</span>.runningOperationsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>[<span style="color:#b58900">self</span>.runningOperations addObject:operation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>SD_UNLOCK(<span style="color:#b58900">self</span>.runningOperationsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#586e75">// 2. Preprocess the options and context arg to decide the final the result for manager
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span><span style="color:#586e75"></span>SDWebImageOptionsResult <span style="color:#719e07">*</span>result <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> processedResultForURL:url options:options context:context];
</code></pre></div><p>The implementation of <strong>loadImage</strong> is relatively simple, and the core is to generate an operation then transfer it to a chache querey.</p>
<p>After the operation is initialized, it will checks whether failedURLs contains the current url:</p>
<ul>
<li>If yes, and options is SDWebImageRetryFailed, directly return operation and retun;</li>
<li>If pass, the operation will be stored in <code>runningOperations</code>. Enclose options and imageContext in <strong>SDWebImageOptionsResult</strong>.</li>
</ul>
<p>then will update imageContext, mainly store the transformer, cacheKeyFilter, cacheSerializer as the global default setting, and then call <strong>optionsProcessor</strong> to fulfill user&rsquo;s custom options to modify imageContext again.</p>
<p>If you see here from the front,  you should have an impression of this routine. The priority logic of requestModifer in the previous ImageLoader is similar to this, but the implementation is somewhat different. Finally, transfer to CacheProcess.</p>
<p>The operation of <strong>loadImage</strong> is a combineOperation, which is a combination of cache and loader operation tasks, so that it can clean up the cache query and download tasks in one step. The statement is as follows:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">SDWebImageCombinedOperation</span> : <span style="color:#268bd2">NSObject</span> <span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75">/// imageCache queryImageForKey: 的 operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable, <span style="color:#719e07">readonly</span>) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span> cacheOperation;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75">/// imageLoader requestImageWithURL: 的 operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable, <span style="color:#719e07">readonly</span>) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span> loaderOperation;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75">/// Cancel the current operation, including cache and loader process
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#586e75"></span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">cancel</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">@end</span>
</code></pre></div><p>The cancel method provided by it will gradually check two types of opration and then call the cancel operation one by one.</p>
<p>####CallCacheProcessForOperation</p>
<p>First check the value of  <strong>SDWebImageFromLoaderOnly</strong> to determine whether need to start the download task directly.</p>
<p>If yes, forward to downloadProcess.</p>
<p>Otherwise, create a query task through <code>imageCache</code> and save it to combineOperation&rsquo;s cacheOperation:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>operation.cacheOperation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.imageCache queryImageForKey:key options:options context:context completion:<span style="color:#719e07">^</span>(UIImage <span style="color:#719e07">*</span> _Nullable cachedImage, NSData <span style="color:#719e07">*</span> _Nullable cachedData, SDImageCacheType cacheType) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>   <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>operation <span style="color:#719e07">||</span> operation.isCancelled) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    	<span style="color:#586e75">/// 1  
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>  	<span style="color:#586e75">/// 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75"></span>}];
</code></pre></div><p>There are two situations that need to be handled for the results of the cache query:</p>
<ol>
<li>When the operation is executing in the queue and operaton was marked as canceled, will end the donwload task;</li>
<li>Otherwise, forward to downloadProcess.</li>
</ol>
<p>####CallDownloadProcessForOperation</p>
<p>The most complex of the 6 methods. First, We need to decide whether we need to create a new download task, which is controlled by three variables:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">BOOL</span> shouldDownload <span style="color:#719e07">=</span> <span style="color:#719e07">!</span>SD_OPTIONS_CONTAINS(options, SDWebImageFromCacheOnly);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    shouldDownload <span style="color:#719e07">&amp;=</span> (<span style="color:#719e07">!</span>cachedImage <span style="color:#719e07">||</span> options <span style="color:#719e07">&amp;</span> SDWebImageRefreshCached);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    shouldDownload <span style="color:#719e07">&amp;=</span> (<span style="color:#719e07">!</span>[<span style="color:#b58900">self</span>.delegate respondsToSelector:<span style="color:#719e07">@selector</span>(imageManager:shouldDownloadImageForURL:)] <span style="color:#719e07">||</span> [<span style="color:#b58900">self</span>.delegate imageManager:<span style="color:#b58900">self</span> shouldDownloadImageForURL:url]);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    shouldDownload <span style="color:#719e07">&amp;=</span> [<span style="color:#b58900">self</span>.imageLoader canRequestImageForURL:url];
</code></pre></div><ul>
<li>check options value is set as SDWebImageFromCacheOnly or SDWebImageRefreshCached;</li>
<li>check the delegate method <strong>shouldDownloadImageForURL</strong> value;</li>
<li>check whether the imageLoader <strong>canRequestImageForURL</strong>;</li>
</ul>
<ol>
<li>If shouldDownload is NO, close the download task. And perform <strong>callCompletionBlockForOperation</strong> and<strong>safelyRemoveOperationFromRunning</strong>. By the way, if cacheImage exists, it will be returned with completionBlock.</li>
<li>If shouldDownload is YES, create a new download task and save it in combineOperation&rsquo;s loaderOperation. Before creating a new task, if cacheImage exist and SDWebImageRefreshCached is set, the cacheImage will be stored in imageContext (if not will create a imageContext).</li>
<li>After downloading, return to callBack, there are several situations to deal with:
<ul>
<li>If the operation is canceled, the downloaded image and data will be discarded. And call the completion block and close the download task ;</li>
<li>Error caused by reqeust is cacneled, call the completion block and close the download task ;</li>
<li>Image refresh hit the NSURLCache cache, do not call the completion block;</li>
<li>errro, <strong>callCompletionBlockForOperation</strong> and add url to failedURLs;</li>
<li>None of the above conditions, if successful by retry, will remove the url from failedURLs first, call <strong>storeCacheProcess</strong>;</li>
</ul>
</li>
</ol>
<p>    Finally, call the <strong>safelyRemoveOperation</strong> for operation which marked as finished;</p>
<p>####CallStoreCacheProcessForOperation</p>
<p>Pour out storeCacheType、originalStoreCacheType、transformer、cacheSerializer from imageContext.</p>
<p>Check if it is necessary to store the converted image data, original data, and wait for the end of the cache storage:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">BOOL</span> shouldTransformImage <span style="color:#719e07">=</span> downloadedImage <span style="color:#719e07">&amp;&amp;</span> (<span style="color:#719e07">!</span>downloadedImage.sd_isAnimated <span style="color:#719e07">||</span> (options <span style="color:#719e07">&amp;</span> SDWebImageTransformAnimatedImage)) <span style="color:#719e07">&amp;&amp;</span> transformer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#dc322f">BOOL</span> shouldCacheOriginal <span style="color:#719e07">=</span> downloadedImage <span style="color:#719e07">&amp;&amp;</span> finished;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#dc322f">BOOL</span> waitStoreCache <span style="color:#719e07">=</span> SD_OPTIONS_CONTAINS(options, SDWebImageWaitStoreCache);
</code></pre></div><p>If shouldCacheOriginal is NO, directly transfer to <strong>transformProcess</strong>. Otherwise, first confirm whether the storage type is the original data:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// normally use the store cache type, but if target image is transformed, use original store cache type instead
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>SDImageCacheType targetStoreCacheType <span style="color:#719e07">=</span> shouldTransformImage <span style="color:#719e07">?</span> originalStoreCacheType : storeCacheType;
</code></pre></div><p>If cacheSerializer exists during storage, it will first convert the data format, and finally call <code>[self stroageImage: ...]</code></p>
<p>When the storage is over, go to the last step, <strong>transformProcess</strong>.</p>
<p>####CallTransformProcessForOperation</p>
<p>Before the conversion starts, it will routinely judge whether it needs to be converted.</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageTransformer<span style="color:#719e07">&gt;</span> transformer <span style="color:#719e07">=</span> context[SDWebImageContextImageTransformer];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageCacheSerializer<span style="color:#719e07">&gt;</span> cacheSerializer <span style="color:#719e07">=</span> context[SDWebImageContextCacheSerializer];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#dc322f">BOOL</span> shouldTransformImage <span style="color:#719e07">=</span> originalImage <span style="color:#719e07">&amp;&amp;</span> (<span style="color:#719e07">!</span>originalImage.sd_isAnimated <span style="color:#719e07">||</span> (options <span style="color:#719e07">&amp;</span> SDWebImageTransformAnimatedImage)) <span style="color:#719e07">&amp;&amp;</span> transformer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#dc322f">BOOL</span> waitStoreCache <span style="color:#719e07">=</span> SD_OPTIONS_CONTAINS(options, SDWebImageWaitStoreCache);
</code></pre></div><p>If conversion is required, it will enter the global queue to start processing:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span style="color:#2aa198">0</span>), <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        UIImage <span style="color:#719e07">*</span>transformedImage <span style="color:#719e07">=</span> [transformer transformedImageWithImage:originalImage forKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">if</span> (transformedImage <span style="color:#719e07">&amp;&amp;</span> finished) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>				<span style="color:#586e75">/// 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"></span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>				callCompletionBlock
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>});        
</code></pre></div><p>After the conversion is successful, the image will be stored according to</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>cacheData <span style="color:#719e07">=</span> [cacheSerializer cacheDataWithImage: originalData: imageURL:];
</code></pre></div><p>After storing, call completion block. The end.</p>
<h2 id="the-end">The End</h2>
<p>I am honored that you can reach here. I hope you can get a general understanding of the work-flow of SD, as well as some details of processing and thinking. In SD 5.x, the most personal feeling is that the design of its architecture is worth learning.</p>
<ul>
<li>How to design a stable and extensible API that can safely support dynamic parameter addition?</li>
<li>How to design a decoupled and dynamically pluggable architecture?</li>
</ul>
<p>Finally, this article actually lacks <strong>SDImageCoder</strong>, which will be left for the next SDWebImage plugin and its extension.</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/source-code">Source Code</a>
     
    <a href="https://looseyi.github.io/tags/ios">iOS</a>
     
    <a href="https://looseyi.github.io/tags/cache">Cache</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-1/"><span>←</span><span>浅析 - CocoaLumberjack 3.6 之 DDLog</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-ios/cocoapods-packager/"><span>浅析 Cocoapods-Packager 实现</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
