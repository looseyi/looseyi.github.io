<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>浅析 - 微信 MMKV 1.1.1 - Aha Edmond</title>

  
  
  <meta name="description" content="介绍 MMKV is an efficient, small, easy-to-use mobile key-value storage framework used in the WeChat application. It&rsquo;s currently available on Android, iOS/macOS, Win32 and POSIX. 作为一个精简易用且性能强悍的全平台 K-V 存储框架，MMKV 有如下特点： 高效： 利用 mmap 直接将文件" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/sourcecode-ios/source-code-mmkv/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="浅析 - 微信 MMKV 1.1.1" />
<meta property="og:description" content="介绍 MMKV is an efficient, small, easy-to-use mobile key-value storage framework used in the WeChat application. It&rsquo;s currently available on Android, iOS/macOS, Win32 and POSIX. 作为一个精简易用且性能强悍的全平台 K-V 存储框架，MMKV 有如下特点： 高效： 利用 mmap 直接将文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/sourcecode-ios/source-code-mmkv/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-21T00:00:00&#43;08:00" />
<meta property="article:modified_time" content="2020-05-21T00:00:00&#43;08:00" />


  
  <meta itemprop="name" content="浅析 - 微信 MMKV 1.1.1">
<meta itemprop="description" content="介绍 MMKV is an efficient, small, easy-to-use mobile key-value storage framework used in the WeChat application. It&rsquo;s currently available on Android, iOS/macOS, Win32 and POSIX. 作为一个精简易用且性能强悍的全平台 K-V 存储框架，MMKV 有如下特点： 高效： 利用 mmap 直接将文件"><meta itemprop="datePublished" content="2020-05-21T00:00:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-21T00:00:00&#43;08:00" />
<meta itemprop="wordCount" content="12168">
<meta itemprop="keywords" content="Source Code,iOS,Cache," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅析 - 微信 MMKV 1.1.1"/>
<meta name="twitter:description" content="介绍 MMKV is an efficient, small, easy-to-use mobile key-value storage framework used in the WeChat application. It&rsquo;s currently available on Android, iOS/macOS, Win32 and POSIX. 作为一个精简易用且性能强悍的全平台 K-V 存储框架，MMKV 有如下特点： 高效： 利用 mmap 直接将文件"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-05-21</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>浅析 - 微信 MMKV 1.1.1</h1>
  </header>
  <section class="post-content"><h1 id="介绍">介绍</h1>
<blockquote>
<p>MMKV is an <strong>efficient</strong>, <strong>small</strong>, <strong>easy-to-use</strong> mobile key-value storage framework used in the WeChat application. It&rsquo;s currently available on <strong>Android</strong>, <strong>iOS/macOS</strong>, <strong>Win32</strong> and <strong>POSIX</strong>.</p>
</blockquote>
<p>作为一个精简易用且性能强悍的全平台 K-V 存储框架，<a href="https://github.com/tencent/mmkv">MMKV</a> 有如下特点：</p>
<ul>
<li><strong>高效</strong>：
<ul>
<li>利用 mmap 直接将文件映射到内存；</li>
<li>利用 protobuf 对键值进行编解码压缩；</li>
<li>多进程并发；</li>
</ul>
</li>
<li><strong>易用</strong>：无需手动 <code>synchronize</code> 和配置，全程自动同步；</li>
<li><strong>精简</strong>.
<ul>
<li><strong>少量的文件</strong>: 仅包括了编解码工具类和 mmap 逻辑代码，无冗余依赖；</li>
<li><strong>二进制文件仅小于 30K</strong>: 如为 ipa 文件则会更小；</li>
</ul>
</li>
</ul>
<p>具体性能，微信团队提供了简单的 <a href="https://mp.weixin.qq.com/s/cZQ3FQxRJBx4px1woBaasg">benchmark</a>。总之就是秒杀苹果的 NSUserDefaults，性能差异达 100 多倍。</p>
<p>说明，现在大家看到的这篇文章是重写的 2.0 版本。就在前不久，MMKV 悄摸地发布了主版本更新 <a href="https://github.com/Tencent/MMKV/releases/tag/v1.1.0">v1.1.0</a>，而原有的实现已面目全非 💔，原因<a href="https://github.com/Tencent/MMKV/releases">详见</a>：</p>
<blockquote>
<p>We refactor the whole MMKV project and unify the cross-platform Core library. From now on, MMKV on iOS/macOS, Android, Win32 all <strong>share the same core logic code</strong>.</p>
</blockquote>
<p>另，本篇涉及大量 C++ 实现，如果描述有误望及时指出。</p>
<h2 id="准备工作">准备工作</h2>
<p>在开始之前，我们需要了解几个概念，熟悉的同学可 pass。</p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html"><strong>mmap</strong></a></p>
<blockquote>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
</blockquote>
<p>通常，我们的文件读写操作需要页缓存作为内核和应用层的中转。因此，一次文件操作需要两次数据拷贝（内核到页缓存，页缓存到应用层），而 mmap 实现了用户空间和内核空间数据的直接交互而省去了页缓存。当然有利也有弊，如 <a href="https://developer.Apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html">苹果文档</a> 所述，想高效使用 mmap 需要符合以下场景：</p>
<blockquote>
<ul>
<li>You have a large file whose contents you want to access randomly one or more times.</li>
<li>You have a small file whose contents you want to read into memory all at once and access frequently. This technique is best for files that are no more than a few virtual memory pages in size.</li>
<li>You want to cache specific portions of a file in memory. File mapping eliminates the need to cache the data at all, which leaves more room in the system disk caches for other data.</li>
</ul>
</blockquote>
<p>因此，当我们需要高频率的访问某一较大文件中的一小部分内容的时候，mmap 的效率是最高的。</p>
<p>其实不光是 MMKV 包括微信的 XLog 和 美团的 Logan 日志工具，还有 SQLight 都使用 mmap 来提升高频更新场景下的文件访问效率。</p>
<p><a href="https://www.wikiwand.com/en/Protocol_Buffers"><strong>Protocol Buffer</strong></a></p>
<blockquote>
<p>Protobuf is a method of <a href="https://www.wikiwand.com/en/Serialization">serializing</a> structured data. It is useful in developing programs to communicate with each other over a wire or for storing data. The method involves an <a href="https://www.wikiwand.com/en/Interface_description_language">interface description language</a> that describes the structure of some data and a program that generates source code from that description for generating or parsing a stream of bytes that represents the structured data.</p>
</blockquote>
<p>Protobuf 是一种将结构化数据进行序列化的方法。它最初是为了解决服务器端新旧协议（高低版本）兼容性问题而诞生的。因此，称为“协议缓冲区”，只不过后期慢慢发展成用于传输数据和存储等。</p>
<p>MMKV 正是考虑到了 protobuf 在性能和空间上的不错表现，以简化版 protobuf 作为序列化方案，还扩展了 protobuf 的增量更新的能力，将 K-V 对象序列化后，直接 append 到内存末尾进行序列化。</p>
<p>那 Protobuf 是如何实现高效编码？</p>
<ol>
<li>以 <code>Tag - Value</code> (Tag - Length - Value)的编码方式的实现。减少了分隔符的使用，数据存储更加紧凑；</li>
<li>利用 <code>base 128 varint</code> (变长编码）原理压缩数据以后，二进制数据非常紧凑，pb 体积更小。不过 pb 并没有压缩到极限，float、double 浮点型都没有压缩；</li>
<li>相比  JSON 和 XML 少了 <code>{、}、:</code> 这些符号，体积也减少一些。再加上 varint、gzip 压缩以后体积更小。</li>
</ol>
<p><strong><a href="https://www.wikiwand.com/en/Cyclic_redundancy_check">CRC 校验</a></strong></p>
<blockquote>
<p>循环冗余校验（Cyclic redundancy check）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。</p>
</blockquote>
<p>同样是用于计算校验值，相比 MD5 或者 SHA1，CRC 的计算效率较高，安全性较弱。考虑到文件系统、操作系统都有一定的不稳定性，MMKV 增加了 CRC 校验，对无效数据进行甄别。</p>
<p>在 iOS 微信现网环境上，有平均约 70万日次的数据校验不通过。</p>
<h1 id="初始化">初始化</h1>
<p>在 v1.1.0 版本 Tencent 团队重写了整个 MMVK 项目，统一跨平台核心库。自此 MMKV 在 iOS/macOS, Android, Win32 共享同一份核心逻辑。在一定程度上提高了可维护性，以及优势共享。也正是由于这一点，在 iOS/macOS 上可以实现 <strong>Multi-Process Access</strong>。</p>
<p>在代码结构上，MMKV 独立出单独的 <a href="https://github.com/Tencent/MMKV/blob/master/MMKVCore.podspec">MMVKCore</a>，Apple 平台基于 MMKV Core 做了一层 Objc 的封装。</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cly1gehfsnonv8j21fy0w4gqq.jpg" alt="MMVK Core.png"></p>
<p>原有的实现基本都迁移到 MMKV Core 中并替换成了 C++ 实现。对不同平台的所独有的 API 或逻辑通过不同的文件名和宏来隔离。以 MemoryFile 为例：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>MemoryFile.h
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>MemoryFile.cpp
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>MemoryFile_Android.cpp
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>MemoryFile_OSX.cpp
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>MemoryFile_Win32.cpp
</code></pre></div><p>本篇我们重点关注 Apple 相关逻辑。</p>
<h2 id="class-initialize">Class Initialize</h2>
<p>MMKV 在使用前的准备工作分成两个阶段：</p>
<ol>
<li>初始化 <code>g_instanceDic</code> 等静态变量。它在应用启动时的 pre_main 函数前，在 MMKV class 的  <code>+ initialize</code> 里完成的。</li>
<li>需要用户手动执行 <code>+initializeMMKV</code> 来完成 <code>g_basePath</code> 的指定，即 MMKV 的根目录。</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>+ (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">initialize</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (<span style="color:#b58900">self</span> <span style="color:#719e07">==</span> MMKV.<span style="color:#719e07">class</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        g_instanceDic <span style="color:#719e07">=</span> [[NSMutableDictionary alloc] init];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        g_lock <span style="color:#719e07">=</span> new mmkv<span style="color:#719e07">::</span>ThreadLock();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        g_lock<span style="color:#719e07">-&gt;</span>initialize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        mmkv<span style="color:#719e07">::</span>MMKV<span style="color:#719e07">::</span>minimalInit([<span style="color:#b58900">self</span> mmkvBasePath].UTF8String);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#586e75">/* 注册启动通知 */</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>}
</code></pre></div><p>在类的初始化中，做了四件事情：</p>
<ul>
<li><code>g_instanceDic</code> ：全局 MMKV 实例的容器，key 由多个字段混合生成的，后面会说明；</li>
<li><code>g_lock</code> : 为 <code>g_instanceDic</code> 配了把线程锁；</li>
<li><code>minimalInit</code>：以 MMKV 默认的根目录 (～/Document/mmkv) ，初始化 MMKV Core 中的全局变量；</li>
<li>注册 App 生命周期相关的通知 （仅 iOS 应用主体）</li>
</ul>
<p>这里之前有不明白之处，就是为什么这里没有使用  <code>dispatch_once</code> 来保证不可重入呢？</p>
<p>当翻看该文件的 history 时，发现早期版本确实用到了 <code>dispatch_once</code> 来避免重入。而现在换成这种写法难道是</p>
<p>用了什么新特性吗？</p>
<p>我们知道 <code>+initialize</code> 是有可能被多次调用的，但是对其如何被多次调用，被谁多次调用，这里理解有误。</p>
<p>以 MMKV 为例，假设我们声明 <strong>MMKVTest</strong> 作为其 MMKV 的子类，但未实现 <code>+initialize</code> 或者 <strong>MMKVTest</strong> 在其 <code>+initialize</code>  中显式的调用 <code>[super initialize]</code> 方法，那么 MMKV 的 <code>+initialize</code> 才会被调用多次。</p>
<p>但是忽略了很重要的一点，<code>+initialize</code> 是 class method，完全可以通过判断 class 类型来避免重入。这也是第一行判断 <code>self == MMKV.class</code> 的重要性和作用。</p>
<h3 id="minimalinit">MinimalInit</h3>
<blockquote>
<p>protect from some old code that don&rsquo;t call initializeMMKV()</p>
</blockquote>
<p>为了确保相关属性访问时已初始化完成，在类初始化时需要提前备好全局变量。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>minimalInit(MMKVPath_t defaultRootDir) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    ThreadLock<span style="color:#719e07">::</span>ThreadOnce(<span style="color:#719e07">&amp;</span>once_control, initialize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#dc322f">int</span> device <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>, version <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    GetAppleMachineInfo(device, version);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">#    ifdef __aarch64__
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07"></span>    <span style="color:#719e07">if</span> ((device <span style="color:#719e07">==</span> iPhone <span style="color:#719e07">&amp;&amp;</span> version <span style="color:#719e07">&gt;=</span> <span style="color:#2aa198">9</span>) <span style="color:#719e07">||</span> (device <span style="color:#719e07">==</span> iPad <span style="color:#719e07">&amp;&amp;</span> version <span style="color:#719e07">&gt;=</span> <span style="color:#2aa198">7</span>)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        CRC32 <span style="color:#719e07">=</span> mmkv<span style="color:#719e07">::</span>armv8_crc32;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">#    endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    g_rootDir <span style="color:#719e07">=</span> defaultRootDir;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    mkPath(g_rootDir);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
</code></pre></div><p>该方法以最低限度把必须要完成的事情放到了应用的启动前，主要三件事：</p>
<ol>
<li>执行 initialize 完成全局变量的 init。</li>
<li>确定 CRC 校验的算法；</li>
<li>生成 mmkv 根目录；</li>
</ol>
<h3 id="initialize">Initialize</h3>
<p><strong>ThreadLock::ThreadOnce</strong> 背后以 <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_once.html">pthread_once</a> 来保证单词调用，以完成 <code>initialize()</code>，最后用 <code>g_rootDir</code> 创建对应的文件目录。来看私有的 <strong>initialize</strong> 方法做了啥：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">void</span> <span style="color:#268bd2">initialize</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    g_instanceDic <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> unordered_map<span style="color:#719e07">&lt;</span>string, MMKV <span style="color:#719e07">*&gt;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    g_instanceLock <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> ThreadLock();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    g_instanceLock<span style="color:#719e07">-&gt;</span>initialize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    mmkv<span style="color:#719e07">::</span>DEFAULT_MMAP_SIZE <span style="color:#719e07">=</span> mmkv<span style="color:#719e07">::</span>getPageSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>}
</code></pre></div><p>在 MMKV Core 实现中也维护了 <code>g_instanceDic</code> 和 <code>g_instanceLock</code> 。看到这不太理解，那在 iOS / MacOS 端为何仍旧保留了这两 ？求告知。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">static</span> NSMutableDictionary <span style="color:#719e07">*</span>g_instanceDic <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">static</span> mmkv<span style="color:#719e07">::</span>ThreadLock <span style="color:#719e07">*</span>g_lock;
</code></pre></div><h3 id="crc32">CRC32</h3>
<blockquote>
<p>该方法用于获取文件的 digest 校验值。</p>
</blockquote>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">typedef</span> <span style="color:#268bd2">uint32_t</span> (<span style="color:#719e07">*</span>CRC32_Func_t)(<span style="color:#dc322f">uint32_t</span> crc, <span style="color:#719e07">const</span> <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> <span style="color:#719e07">*</span>buf, size_t len);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">extern</span> CRC32_Func_t CRC32;
</code></pre></div><p>这里的 CRC32 就是正儿八经的函数指针，默认指向的是：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">static</span> <span style="color:#268bd2">inline</span> <span style="color:#dc322f">uint32_t</span> <span style="color:#268bd2">_crc32Wrap</span>(<span style="color:#dc322f">uint32_t</span> crc, <span style="color:#719e07">const</span> <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> <span style="color:#719e07">*</span>buf, size_t len) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">return</span> <span style="color:#719e07">static_cast</span><span style="color:#719e07">&lt;</span><span style="color:#dc322f">uint32_t</span><span style="color:#719e07">&gt;</span>(<span style="color:#719e07">::</span>crc32(crc, buf, <span style="color:#719e07">static_cast</span><span style="color:#719e07">&lt;</span>uInt<span style="color:#719e07">&gt;</span>(len)));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>不过这里作者做了优化，当 CPU 架构为 aarch64，则改换了 <code>mmkv::armv8_crc32</code> 的实现。由于 crc32 指令需要A10芯片，也就是 iPhone 7 或 iPad 的第六代。因此，这个通过 <code>GetAppleMachineInfo</code>  获取设备和系统版本来判断。</p>
<p>最后一步，获取内存页的大小用于后续文件存取时计算所需内存，并存入 <code>DEFAULT_MMAP_SIZE</code>。</p>
<h3 id="注册通知">注册通知</h3>
<p>MMKV 在 <a href="Core/MMKVPredef.h">Core/MMKVPredef.h</a> 定义了各个平台的宏，这里只在 iOS 应用主体注册了 Notification：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#if defined(MMKV_IOS) &amp;&amp; !defined(MMKV_IOS_EXTENSION)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07"></span><span style="color:#719e07">if</span> ([[[NSBundle mainBundle] bundlePath] hasSuffix:<span style="color:#2aa198">@&#34;.appex&#34;</span>]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>     g_isRunningInAppExtension <span style="color:#719e07">=</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
</code></pre></div><p>这里由于担心遗漏对 <code>MMKV_IOS_EXTENSION</code>  的判断，故此添加了 g_isRunningInAppExtension 静态变量；</p>
<p>注册的两个 Notification 的方法为：<code>didEnterBackground</code> 和 <code>didBecomeActive</code>，用于监听 <strong>UIApplicationState</strong> 在前后台的状态变化。在注册通知时，也会获取了当前 applicationState 并通过方法：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>setIsInBackground(<span style="color:#dc322f">bool</span> isInBackground)
</code></pre></div><p>来更新 <code>g_isInBackground</code>。这么做是为了保证在后台时能够安全的执行文件写入。</p>
<h3 id="initializemmkv">InitializeMMKV</h3>
<p>真正使用前还需要手动调用一次 <code>+initializeMMKV: logLevel:</code> 或其相关 convene method。</p>
<p>方法内部使用 <code>static BOOL g_hasCalledInitializeMMKV</code> 来防止被多次调用:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (g_hasCalledInitializeMMKV) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    MMKVWarning(<span style="color:#2aa198">&#34;already called +initializeMMKV before, ignore this request&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#719e07">return</span> [self mmkvBasePath];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>g_hasCalledInitializeMMKV <span style="color:#719e07">=</span> YES;
</code></pre></div><p><code>initializeMMKV:</code> 第一个参数为 rootDir 用于更新 <code>g_basePath</code>，为空的话就用默认值。接着传入 logLevel，执行 MMKV Core 提供的初始化方法：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>initializeMMKV(<span style="color:#719e07">const</span> MMKVPath_t <span style="color:#719e07">&amp;</span>rootDir, MMKVLogLevel logLevel) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    g_currentLogLevel <span style="color:#719e07">=</span> logLevel;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    ThreadLock<span style="color:#719e07">::</span>ThreadOnce(<span style="color:#719e07">&amp;</span>once_control, initialize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    g_rootDir <span style="color:#719e07">=</span> rootDir;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    mkPath(g_rootDir);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p>这里同样也调用了 <code>ThreadLock::ThreadOnce</code> 保证 MMKV Core 能够成功初始化。</p>
<p>在 1.1 版本中，由于底层实现的统一，iOS 端可以支持多进程调用，这里多出来一个控制参数，对应的方法为：</p>
<p><code>+initializeMMKV: groupDir: logLevel:</code>。内部也是走上面的方法，不过多出来一个全局变量：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>g_groupPath <span style="color:#719e07">=</span> [groupDir stringByAppendingPathComponent:<span style="color:#2aa198">@&#34;mmkv&#34;</span>];
</code></pre></div><h2 id="instance-initialize">Instance Initialize</h2>
<h3 id="mmkvwithid">mmkvWithID</h3>
<p>获取实例 MMKV 同样提供了多个 convince method，最终收口的私有类方法如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>+ (<span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">mmkvWithID:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">mmapID</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>                  <span style="color:#268bd2">cryptKey:</span>(NSData <span style="color:#719e07">*</span>)<span style="color:#268bd2">cryptKey</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>              <span style="color:#268bd2">relativePath:</span>(nullable NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">relativePath</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>                      <span style="color:#268bd2">mode:</span>(MMKVMode)<span style="color:#268bd2">mode</span>
</code></pre></div><p>注意，正式因为 relativePath 和 mode 是互斥的，不能同时设置，这才作为私有方法。那就一探究竟吧。</p>
<p>首先，会检查 <code>g_hasCalledInitializeMMKV</code> 是否执行过 <code>+initializeMMKV:</code> 以及 mmapID 是否有效。</p>
<p>上锁 <code>SCOPED_LOCK(g_lock)</code>之后，接着就是处理 relativePath 和 mode 的问题了：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (mode <span style="color:#719e07">==</span> MMKVMultiProcess) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>relativePath) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        relativePath <span style="color:#719e07">=</span> g_groupPath;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>relativePath) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        MMKVError(<span style="color:#2aa198">&#34;Getting a multi-process MMKV [%@] without setting groupDir makes no sense&#34;</span>, mmapID);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>        MMKV_ASSERT(<span style="color:#2aa198">0</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span>}
</code></pre></div><p><code>g_groupPath</code> 本身是服务于 multi-process 的，对于单进程而言 <code>g_groupPath</code> 值自然为 nil，也就不会有冲突一说。上述逻辑做的事情也比较清晰，就是在 multi-process 下，会将 relativePath  覆盖，并保证起不能为空。</p>
<p>至于为何不能为空？MMKVError 中已经做了很明确的说明了。</p>
<p>初始化 MMKV 实例</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>NSString <span style="color:#719e07">*</span>kvKey <span style="color:#719e07">=</span> [MMKV mmapKeyWithMMapID:mmapID relativePath:relativePath];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>MMKV <span style="color:#719e07">*</span>kv <span style="color:#719e07">=</span> [g_instanceDic objectForKey:kvKey];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">if</span> (kv <span style="color:#719e07">==</span> <span style="color:#b58900">nil</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    kv <span style="color:#719e07">=</span> [[MMKV alloc] initWithMMapID:mmapID cryptKey:cryptKey relativePath:relativePath mode:mode];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>kv<span style="color:#719e07">-&gt;</span>m_mmkv) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    kv<span style="color:#719e07">-&gt;</span>m_mmapKey <span style="color:#719e07">=</span> kvKey;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    [g_instanceDic setObject:kv forKey:kvKey];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
</code></pre></div><p>首先，通过 mmapID 和 relativePath 来生成 kvKey，用于关联生成的 mmkv 实例，最终存储在 <code>g_instanceDic</code> 中。如果 relativePath 为有效字符串，key 值为 relativePath 和 mmapID 拼接后的的 md5 值。</p>
<p>接着，尝试通过 key 来获取实例。没有的话就需要进行初始化，并将 mmkv 实例保存到 <code>g_instanceDic</code>。</p>
<p>这里每个实例本身也会将 key 保存在 <code>m_mmapKey</code> 中，以待其结束时，将自身从 <code>g_instanceDic</code> 中移除。</p>
<h3 id="initwithmmapid">initWithMMapID</h3>
<p>通过 MMKV Core 的 <code>mmkv::MMKV::mmkvWithID</code> 方法来获取 m_mmkv 实例。参数就是将 mmapID、cryptKey、relativePath 转为 c string 传入。</p>
<p>同类的初始化一样，MMKV Core 构造函数的实现与 iOS 侧无异，只是用 C++ 的方式再做了一遍。这里除了对 variable 进行默认值的赋值之外，最终调用 <code>loadFromFile()</code> 来加载 mmkv 文件和 CRC 文体。MMKV 的构造函数完整实现就不贴出来了，简单看一下声明吧：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#ifndef MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07"></span>    MMKV(<span style="color:#719e07">const</span> std<span style="color:#719e07">::</span>string <span style="color:#719e07">&amp;</span>mmapID, MMKVMode mode, std<span style="color:#719e07">::</span>string <span style="color:#719e07">*</span>cryptKey, MMKVPath_t <span style="color:#719e07">*</span>relativePath);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    std<span style="color:#719e07">::</span>string m_mmapKey;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">#else </span><span style="color:#586e75">// defined(MMKV_ANDROID)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#586e75"></span>    MMKV(<span style="color:#719e07">const</span> std<span style="color:#719e07">::</span>string <span style="color:#719e07">&amp;</span>mmapID, <span style="color:#dc322f">int</span> size, MMKVMode mode, std<span style="color:#719e07">::</span>string <span style="color:#719e07">*</span>cryptKey, MMKVPath_t <span style="color:#719e07">*</span>relativePath);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    MMKV(<span style="color:#719e07">const</span> std<span style="color:#719e07">::</span>string <span style="color:#719e07">&amp;</span>mmapID, <span style="color:#dc322f">int</span> ashmemFD, <span style="color:#dc322f">int</span> ashmemMetaFd, std<span style="color:#719e07">::</span>string <span style="color:#719e07">*</span>cryptKey <span style="color:#719e07">=</span> <span style="color:#719e07">nullptr</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">#endif
</span></code></pre></div><h2 id="data-structure">Data Structure</h2>
<p>本节，会稍微介绍一下 MMKV 中用到的相关数据结构和一些变量。对主要数据结构有基本了解后，在解释实现时我们更能够 Focus 在核心逻辑。</p>
<p>先来看 MMKV 的实例变量：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>mmkv<span style="color:#719e07">::</span>MMKVMap m_dic; <span style="color:#586e75">/// 保存当前映射到内存的 k-v 
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span>std<span style="color:#719e07">::</span>string m_mmapID;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>MMKVPath_t m_path; <span style="color:#586e75">// mmkv path
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>MMKVPath_t m_crcPath; <span style="color:#586e75">// crc file path
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>mmkv<span style="color:#719e07">::</span>MemoryFile <span style="color:#719e07">*</span>m_file; <span style="color:#586e75">// mmap 映射真实数据文件的相关信息，包括 file descrpitot 等
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span>size_t m_actualSize; <span style="color:#586e75">//当前 k-v 占用内存大小
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span>mmkv<span style="color:#719e07">::</span>CodedOutputData <span style="color:#719e07">*</span>m_output; <span style="color:#586e75">// 映射内存所剩余空间
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#dc322f">bool</span> m_needLoadFromFile; <span style="color:#586e75">// 标记是否需要重新载入 m_file
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span><span style="color:#dc322f">bool</span> m_hasFullWriteback; <span style="color:#586e75">// 是否需要执行写回，例如 m_file 读取失败，内存异常等等
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#dc322f">uint32_t</span> m_crcDigest;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>mmkv<span style="color:#719e07">::</span>MemoryFile <span style="color:#719e07">*</span>m_metaFile; <span style="color:#586e75">// mmap 映射 crc 文件的相关信息，包括 file descrpitot etc.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75"></span>mmkv<span style="color:#719e07">::</span>MMKVMetaInfo <span style="color:#719e07">*</span>m_metaInfo; <span style="color:#586e75">// 保存了 crc 文件的 digest 和 size etc.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>mmkv<span style="color:#719e07">::</span>AESCrypt <span style="color:#719e07">*</span>m_crypter; <span style="color:#586e75">// 加密器，文件内容更新后会重新计算加密值
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>mmkv<span style="color:#719e07">::</span>ThreadLock <span style="color:#719e07">*</span>m_lock; <span style="color:#586e75">// k-v 文件锁
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#586e75"></span>mmkv<span style="color:#719e07">::</span>FileLock <span style="color:#719e07">*</span>m_fileLock; <span style="color:#586e75">// crc 文件锁
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#586e75"></span>mmkv<span style="color:#719e07">::</span>InterProcessLock <span style="color:#719e07">*</span>m_sharedProcessLock; <span style="color:#586e75">// 读锁
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span><span style="color:#586e75"></span>mmkv<span style="color:#719e07">::</span>InterProcessLock <span style="color:#719e07">*</span>m_exclusiveProcessLock; <span style="color:#586e75">// 写锁
</span></code></pre></div><p>上述变量会在 MMKV 构造函数调用时完成 initialize。</p>
<h3 id="mmkvmap">MMKVMap</h3>
<p>首先是 <code>MMKVMap</code>，它区分了 Apple 系和其他系统。如果是 Apple 系，则使用 NSString 为 key，value 不仅是 <code>MMBuffer</code> 类型，需要实现 KeyHasher 和 KeyEqualer 协议，毕竟 unordered_map 是 C++ 泛型。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objc" data-lang="objc"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">struct</span> KeyHasher {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    size_t operator()(NSString <span style="color:#719e07">*</span>key) <span style="color:#719e07">const</span> { <span style="color:#719e07">return</span> key.hash; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">struct</span> KeyEqualer {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#dc322f">bool</span> operator()(NSString <span style="color:#719e07">*</span>left, NSString <span style="color:#719e07">*</span>right) <span style="color:#719e07">const</span> { <span style="color:#586e75">/* left isEqual right */</span> }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07"></span>using MMKVMap <span style="color:#719e07">=</span> std<span style="color:#719e07">::</span>unordered_map<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*</span>, mmkv<span style="color:#719e07">::</span>MMBuffer, KeyHasher, KeyEqualer<span style="color:#719e07">&gt;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07"></span>using MMKVMap <span style="color:#719e07">=</span> std<span style="color:#719e07">::</span>unordered_map<span style="color:#719e07">&lt;</span>std<span style="color:#719e07">::</span>string, mmkv<span style="color:#719e07">::</span>MMBuffer<span style="color:#719e07">&gt;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">#endif
</span></code></pre></div><p>注意，在我们的 <code>m_dic</code> 中存储的数据类型是 <code>MMBuffer</code> 而非真实数据类型。只有当我们通过 Access 访问的时候才会 encode / decode 出来。</p>
<h3 id="mmkvkey_t">MMKVKey_t</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07"></span>    <span style="color:#719e07">using</span> MMKVKey_t <span style="color:#719e07">=</span> NSString <span style="color:#719e07">*</span>__unsafe_unretained;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#719e07">static</span> <span style="color:#dc322f">bool</span> <span style="color:#268bd2">isKeyEmpty</span>(MMKVKey_t key) { <span style="color:#719e07">return</span> key.length <span style="color:#719e07">&lt;=</span> <span style="color:#2aa198">0</span>; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07"></span>    <span style="color:#719e07">using</span> MMKVKey_t <span style="color:#719e07">=</span> <span style="color:#719e07">const</span> std<span style="color:#719e07">::</span>string <span style="color:#719e07">&amp;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    <span style="color:#719e07">static</span> <span style="color:#dc322f">bool</span> <span style="color:#268bd2">isKeyEmpty</span>(MMKVKey_t key) { <span style="color:#719e07">return</span> key.empty(); }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">#endif
</span></code></pre></div><p>注意，整个 MMKV Core 的源码中，应该只有 <strong>MMKV.cpp</strong> 这个文件是以 MRC 的方式进行内存管理的，其他的 C++ 类则使用了 ARC，可以查看 <a href="https://github.com/Tencent/MMKV/blob/master/MMKVCore.podspec">MMKVCore.podspec</a>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>s<span style="color:#719e07">.</span>requires_arc <span style="color:#719e07">=</span> <span style="color:#719e07">[</span><span style="color:#2aa198">&#39;Core/MemoryFile.cpp&#39;</span>, <span style="color:#719e07">...]</span>
</code></pre></div><p>这里并未发现包含了 MMKV.cpp 文件，后续代码中会说明。</p>
<h3 id="mmkvpath_t">MMKVPath_t</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">using</span> MMKVPath_t <span style="color:#719e07">=</span> std<span style="color:#719e07">::</span>string;
</code></pre></div><h3 id="memoryfile">MemoryFile</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">class</span> <span style="color:#268bd2">MemoryFile</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    MMKVPath_t m_name;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    MMKVFileHandle_t m_fd; <span style="color:#586e75">// file descriptior (不同平台有所差异)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span><span style="color:#719e07">#ifdef MMKV_WIN32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07"></span>    HANDLE m_fileMapping;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07"></span>    <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>m_ptr; <span style="color:#586e75">// 指向 mmap 内存的起始地址
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span>    size_t m_size; <span style="color:#586e75">// 表示的是文件按照内存整数页截断后的 size。
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#dc322f">bool</span> <span style="color:#268bd2">mmap</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">doCleanMemoryCache</span>(<span style="color:#dc322f">bool</span> forceClean);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">public</span><span style="color:#719e07">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#719e07">#ifndef MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#719e07"></span>    <span style="color:#719e07">explicit</span> MemoryFile(<span style="color:#719e07">const</span> MMKVPath_t <span style="color:#719e07">&amp;</span>path);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#719e07"></span>    MemoryFile(<span style="color:#719e07">const</span> MMKVPath_t <span style="color:#719e07">&amp;</span>path, size_t size, FileType fileType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#719e07">explicit</span> <span style="color:#268bd2">MemoryFile</span>(MMKVFileHandle_t ashmemFD);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#719e07">const</span> FileType m_fileType;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07">#endif </span><span style="color:#586e75">// MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#586e75"></span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>   <span style="color:#586e75">/* methods ... */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>}
</code></pre></div><p>MMKV 之所以高效就是源自 mmap，正是 MemoryFile 封装了 mmap、mumap、msync 等。</p>
<p>非安卓平台构造函数只需 filePath，其余变量均通过 <code>reloadFromFile()</code> 来获取。这里多说一嘴 <strong>FileType</strong>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">enum</span> <span style="color:#268bd2">FileType</span> <span style="color:#719e07">:</span> <span style="color:#dc322f">bool</span> { MMFILE_TYPE_FILE <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>, MMFILE_TYPE_ASHMEM <span style="color:#719e07">=</span> <span style="color:#b58900">true</span> };
</code></pre></div><p><code>MMFILE_TYPE_ASHMEM</code> 指 Android 中所独有的匿名共享内存方式 <a href="https://developer.android.com/ndk/reference/group/memory">ASharedMemory</a>，本质也是 mmap 哈。</p>
<p><strong>reloadFromFile</strong></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MemoryFile<span style="color:#719e07">::</span>reloadFromFile() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">#    ifdef MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07"></span>    <span style="color:#719e07">if</span> (m_fileType <span style="color:#719e07">==</span> MMFILE_TYPE_ASHMEM) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">#    endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07"></span>    <span style="color:#719e07">if</span> (isFileValid()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        MMKVWarning(<span style="color:#2aa198">&#34;calling reloadFromFile while the cache [%s] is still valid&#34;</span>, m_name.c_str());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        MMKV_ASSERT(<span style="color:#2aa198">0</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        clearMemoryCache();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    m_fd <span style="color:#719e07">=</span> open(m_name.c_str(), O_RDWR <span style="color:#719e07">|</span> O_CREAT <span style="color:#719e07">|</span> O_CLOEXEC, S_IRWXU);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#719e07">if</span> (m_fd <span style="color:#719e07">&lt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>        MMKVError(<span style="color:#2aa198">&#34;fail to open:%s, %s&#34;</span>, m_name.c_str(), strerror(errno));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>        FileLock <span style="color:#268bd2">fileLock</span>(m_fd);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        InterProcessLock <span style="color:#268bd2">lock</span>(<span style="color:#719e07">&amp;</span>fileLock, ExclusiveLockType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>        SCOPED_LOCK(<span style="color:#719e07">&amp;</span>lock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        mmkv<span style="color:#719e07">::</span>getFileSize(m_fd, m_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#586e75">// round up to (n * pagesize)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span><span style="color:#586e75"></span>        <span style="color:#719e07">if</span> (m_size <span style="color:#719e07">&lt;</span> DEFAULT_MMAP_SIZE <span style="color:#719e07">||</span> (m_size <span style="color:#719e07">%</span> DEFAULT_MMAP_SIZE <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span>)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>            size_t roundSize <span style="color:#719e07">=</span> ((m_size <span style="color:#719e07">/</span> DEFAULT_MMAP_SIZE) <span style="color:#719e07">+</span> <span style="color:#2aa198">1</span>) <span style="color:#719e07">*</span> DEFAULT_MMAP_SIZE;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>            truncate(roundSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>            <span style="color:#719e07">auto</span> ret <span style="color:#719e07">=</span> mmap();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>            <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>ret) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>                doCleanMemoryCache(<span style="color:#b58900">true</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span><span style="color:#719e07">#    ifdef MMKV_IOS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span><span style="color:#719e07"></span>        tryResetFileProtection(m_name);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span><span style="color:#719e07">#    endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span><span style="color:#719e07"></span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">36</span>}
</code></pre></div><p>第一步就是判断 <code>m_fileType</code>，如果为 <strong>MMFILE_TYPE_ASHMEM</strong> 则直接 return 以通过 <a href="https://developer.android.com/ndk/reference/group/memory#group___memory_1ga77a46b5986e5ab903b3c343df5870439">ASharedMemory_create</a> 来完成内存映射。</p>
<p>接着判断 <code>fd</code> 是否指向有效内存：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#ifndef MMKV_WIN32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07"></span>    <span style="color:#dc322f">bool</span> <span style="color:#268bd2">isFileValid</span>() { <span style="color:#719e07">return</span> m_fd <span style="color:#719e07">&gt;=</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">&amp;&amp;</span> m_size <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">&amp;&amp;</span> m_ptr; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07"></span>    <span style="color:#dc322f">bool</span> <span style="color:#268bd2">isFileValid</span>() { <span style="color:#719e07">return</span> m_fd <span style="color:#719e07">!=</span> INVALID_HANDLE_VALUE <span style="color:#719e07">&amp;&amp;</span> m_size <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">&amp;&amp;</span> m_fileMapping <span style="color:#719e07">&amp;&amp;</span> m_ptr; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">#endif
</span></code></pre></div><p>如果有效，则会执行 <strong>MemoryFile::clearMemoryCache()</strong> ，内部先调用 <code>mumap(m_ptr, m_size)</code> 清理内存缓存，再关闭文件访问 <code>close(m_fd)</code> 还原 <code>m_fd</code> 和 <code>m_size</code>。</p>
<p>在 mmap 前会有一个内存取整的检查，以保证所映射的数据是内存页 <strong>DEFAULT_MMAP_SIZE</strong> 的整数倍，以减少内存碎片。</p>
<p>最后，在 iOS 上会调整文件的读写保护，前面在注册通知中提到过，为了确保应用在后台时能安全的进行文件访问，而不至于被系统错杀 ⚠️。</p>
<p><strong>truncate</strong></p>
<p>内存区取整。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MemoryFile<span style="color:#719e07">::</span>truncate(size_t size) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (m_fd <span style="color:#719e07">&lt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (size <span style="color:#719e07">==</span> m_size) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">#    ifdef MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07"></span>        ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">#    endif </span><span style="color:#586e75">// MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">auto</span> oldSize <span style="color:#719e07">=</span> m_size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    m_size <span style="color:#719e07">=</span> size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#586e75">// round up to (n * pagesize)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75"></span>    <span style="color:#719e07">if</span> (m_size <span style="color:#719e07">&lt;</span> DEFAULT_MMAP_SIZE <span style="color:#719e07">||</span> (m_size <span style="color:#719e07">%</span> DEFAULT_MMAP_SIZE <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span>)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        m_size <span style="color:#719e07">=</span> ((m_size <span style="color:#719e07">/</span> DEFAULT_MMAP_SIZE) <span style="color:#719e07">+</span> <span style="color:#2aa198">1</span>) <span style="color:#719e07">*</span> DEFAULT_MMAP_SIZE;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">::</span>ftruncate(m_fd, <span style="color:#719e07">static_cast</span><span style="color:#719e07">&lt;</span>off_t<span style="color:#719e07">&gt;</span>(m_size)) <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        MMKVError(<span style="color:#2aa198">&#34;fail to truncate [%s] to size %zu, %s&#34;</span>, m_name.c_str(), m_size, strerror(errno));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        m_size <span style="color:#719e07">=</span> oldSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    <span style="color:#719e07">if</span> (m_size <span style="color:#719e07">&gt;</span> oldSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>zeroFillFile(m_fd, oldSize, m_size <span style="color:#719e07">-</span> oldSize)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            MMKVError(<span style="color:#2aa198">&#34;fail to zeroFile [%s] to size %zu, %s&#34;</span>, m_name.c_str(), m_size, strerror(errno));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>            m_size <span style="color:#719e07">=</span> oldSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>            <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>    <span style="color:#719e07">if</span> (m_ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>        <span style="color:#719e07">if</span> (munmap(m_ptr, oldSize) <span style="color:#719e07">!=</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span>            MMKVError(<span style="color:#2aa198">&#34;fail to munmap [%s], %s&#34;</span>, m_name.c_str(), strerror(errno));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">36</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">37</span>    <span style="color:#719e07">auto</span> ret <span style="color:#719e07">=</span> mmap();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">38</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>ret) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">39</span>        doCleanMemoryCache(<span style="color:#b58900">true</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">40</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">41</span>    <span style="color:#719e07">return</span> ret;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">42</span>}
</code></pre></div><p>为保证 size 准确性，再进行一次 <strong>round up to (n * pagesize)</strong> 后才进行取整。两步走：</p>
<p><strong><a href="https://linux.die.net/man/2/ftruncate">ftruncate</a> + <a href="http://man7.org/linux/man-pages/man2/lseek.2.html">lseek</a></strong></p>
<p>对文件扩容或裁剪，并将 file offset 更新至当前容量的最后位置。由于 truncate 并不会操作 file offset 所以需要借助 lseek，剩余的部分均用 <code>'\0'</code> 写入。</p>
<p><strong><a href="https://linux.die.net/man/2/munmap">munmap</a> + mmap</strong></p>
<p>由于 mmap 关联的是 oldSize 的内存，而现在我们调整了 <code>m_size</code> 大小，需要重新绑定文件与内存关系。</p>
<h3 id="mmbuffer">MMBuffer</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">class</span> <span style="color:#268bd2">MMBuffer</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">private</span><span style="color:#719e07">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>ptr;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    size_t size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    MMBufferCopyFlag isNoCopy;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07"></span>    NSData <span style="color:#719e07">*</span>m_data <span style="color:#719e07">=</span> nil;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">public</span><span style="color:#719e07">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#719e07">explicit</span> MMBuffer(size_t length <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    MMBuffer(<span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>source, size_t length, MMBufferCopyFlag flag <span style="color:#719e07">=</span> MMBufferCopy);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#719e07"></span>    <span style="color:#719e07">explicit</span> <span style="color:#268bd2">MMBuffer</span>(NSData <span style="color:#719e07">*</span>data, MMBufferCopyFlag flag <span style="color:#719e07">=</span> MMBufferCopy);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#719e07"></span>   <span style="color:#586e75">// 数据读写方法 ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span><span style="color:#586e75"></span>}
</code></pre></div><p>就是一段连续的内存地址，在 Apple 上则用 NSData 指向，其他平台则是通过 <code>ptr + size</code> 来引用。</p>
<p>在 MMKV 中不论是从数据写入文件还是从文件中读取，统一转换为 MMBuffer 作为过渡。</p>
<h3 id="codedoutputdata">CodedOutputData</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">class</span> <span style="color:#268bd2">CodedOutputData</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span><span style="color:#719e07">const</span> m_ptr;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    size_t m_size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    size_t m_position;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">public</span><span style="color:#719e07">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    CodedOutputData(<span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>ptr, size_t len);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    size_t <span style="color:#268bd2">spaceLeft</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span><span style="color:#268bd2">curWritePointer</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">seek</span>(size_t addedSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">writeRawByte</span>(<span style="color:#dc322f">uint8_t</span> value);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#586e75">/// 其他基本数据类型写入 ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75"></span>}
</code></pre></div><h3 id="codedoutputdata-1">CodedOutputData</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">class</span> <span style="color:#268bd2">CodedInputData</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span><span style="color:#719e07">const</span> m_ptr;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>	 size_t m_size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    size_t m_position;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#dc322f">int8_t</span> <span style="color:#268bd2">readRawByte</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">public</span><span style="color:#719e07">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    CodedInputData(<span style="color:#719e07">const</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>oData, size_t length);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#dc322f">bool</span> <span style="color:#268bd2">isAtEnd</span>() { <span style="color:#719e07">return</span> m_position <span style="color:#719e07">==</span> m_size; };
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#586e75">/// 其他基本数据类型读取 ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75"></span>}
</code></pre></div><p><code>CodedInputData</code> 和 <code>CodedOutputData</code> 主要用于真实数据类型和 MMBuffer 之间转换，关系如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>MMBuffer <span style="color:#719e07">-&gt;</span> Input <span style="color:#719e07">-&gt;</span> 真实数据 <span style="color:#719e07">-&gt;</span> output <span style="color:#719e07">-&gt;</span> MMBuffer
</code></pre></div><p><code>CodedInputData</code> 将 binary Data 从 MMBuffer 中读取出来，转换为真实数据类型；</p>
<p><code>CodedOutputData</code> 则将真实数据类型转换为 binaryData 输出到 MMBuffer 中；</p>
<p>可见，它们两起到了桥梁的作用，完成了真实数据和 MMBuffer 的相互转换。</p>
<h3 id="interprocesslock">InterProcessLock</h3>
<p>MMKV 采用文件锁来处理多进程中的文件访问。<strong>用排他锁作为写锁，用共享锁作为读锁。</strong> 这里没有直接使用系统的 <a href="http://man7.org/linux/man-pages/man2/flock.2.html">flock</a> 而是用 FileLock 将其封装了一层，读写锁均为 <code>InterProcessLock</code> 本质为 FileLock。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">class</span> <span style="color:#268bd2">InterProcessLock</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    FileLock <span style="color:#719e07">*</span>m_fileLock;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    LockType m_lockType;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">public</span><span style="color:#719e07">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    InterProcessLock(FileLock <span style="color:#719e07">*</span>fileLock, LockType lockType)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">:</span> m_fileLock(fileLock), m_lockType(lockType), m_enable(<span style="color:#b58900">true</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        MMKV_ASSERT(m_fileLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#dc322f">bool</span> m_enable;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">lock</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#719e07">if</span> (m_enable) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            m_fileLock<span style="color:#719e07">-&gt;</span>lock(m_lockType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#dc322f">bool</span> <span style="color:#268bd2">try_lock</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        <span style="color:#719e07">if</span> (m_enable) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>            <span style="color:#719e07">return</span> m_fileLock<span style="color:#719e07">-&gt;</span>try_lock(m_lockType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">unlock</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>        <span style="color:#719e07">if</span> (m_enable) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>            m_fileLock<span style="color:#719e07">-&gt;</span>unlock(m_lockType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>};
</code></pre></div><p>MMVK.h 中还声明了变量 <strong>m_isInterProcess</strong> 用于控制锁功能开关。对于支持多进程的 MMKV 而言，m_isInterProcess 代表了当前实例所采用的读写模式：<strong>MMKVMode</strong>：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">enum</span> <span style="color:#268bd2">MMKVMode</span> <span style="color:#719e07">:</span> <span style="color:#dc322f">uint32_t</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    MMKV_SINGLE_PROCESS <span style="color:#719e07">=</span> <span style="color:#2aa198">0x1</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    MMKV_MULTI_PROCESS <span style="color:#719e07">=</span> <span style="color:#2aa198">0x2</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">#ifdef MMKV_ANDROID
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07"></span>    CONTEXT_MODE_MULTI_PROCESS <span style="color:#719e07">=</span> <span style="color:#2aa198">0x4</span>, <span style="color:#586e75">// in case someone mistakenly pass Context.MODE_MULTI_PROCESS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75"></span>    MMKV_ASHMEM <span style="color:#719e07">=</span> <span style="color:#2aa198">0x8</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07"></span>};
</code></pre></div><p>关于锁的，感兴趣的可以看看这篇：<a href="https://zhuanlan.zhihu.com/p/25134841">flock 文件锁</a>。</p>
<p>由于本文篇幅较长，很多描述中忽略了锁相关的细节（其实非常重要的），之后会单独开篇来聊聊。</p>
<h1 id="loaddata">LoadData</h1>
<p>本节主要介绍 MMKV 如何从文件中读取数据、异常数据处理、以及如何利用 CRC 来校验文件的完整性。</p>
<p>在应用首次初始化、数据异常，内存警告、清理数据时都会执行 <code>loadFromFile()</code> 来刷新内存中对应的数据，保证其准确性。整个 m_file 加载主要分三步：</p>
<ol>
<li>校验 CRC 文件、m_file 的有效性，初始化 AESCrypter；</li>
<li>检查文件内部数据的有效性；</li>
<li>加载数据到内存。</li>
</ol>
<h2 id="文件有效性">文件有效性</h2>
<p>在 MMKV 构造函数执行时，m_metaFile 为本地 crc 文件的内存映射，而 m_metaInfo 则记录了当前内存数据的相关 crc 校验值，默认为空。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">struct</span> <span style="color:#268bd2">MMKVMetaInfo</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#dc322f">uint32_t</span> m_crcDigest <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#dc322f">uint32_t</span> m_version <span style="color:#719e07">=</span> MMKVVersionSequence;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#dc322f">uint32_t</span> m_sequence <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>; <span style="color:#586e75">// full write-back count
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"></span>    <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> m_vector[AES_KEY_LEN] <span style="color:#719e07">=</span> {};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#dc322f">uint32_t</span> m_actualSize <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#586e75">// confirmed info: it&#39;s been synced to file
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"></span>    <span style="color:#719e07">struct</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        <span style="color:#dc322f">uint32_t</span> lastActualSize <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        <span style="color:#dc322f">uint32_t</span> lastCRCDigest <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        <span style="color:#dc322f">uint32_t</span> __reserved__[<span style="color:#2aa198">16</span>] <span style="color:#719e07">=</span> {};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    } m_lastConfirmedMetaInfo;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">write</span>(<span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        MMKV_ASSERT(ptr);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>        memcpy(ptr, <span style="color:#719e07">this</span>, <span style="color:#719e07">sizeof</span>(MMKVMetaInfo));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">writeCRCAndActualSizeOnly</span>(<span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        MMKV_ASSERT(ptr);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#719e07">auto</span> other <span style="color:#719e07">=</span> (MMKVMetaInfo <span style="color:#719e07">*</span>) ptr;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        other<span style="color:#719e07">-&gt;</span>m_crcDigest <span style="color:#719e07">=</span> m_crcDigest;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>        other<span style="color:#719e07">-&gt;</span>m_actualSize <span style="color:#719e07">=</span> m_actualSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>    <span style="color:#dc322f">void</span> <span style="color:#268bd2">read</span>(<span style="color:#719e07">const</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>        MMKV_ASSERT(ptr);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>        memcpy(<span style="color:#719e07">this</span>, ptr, <span style="color:#719e07">sizeof</span>(MMKVMetaInfo));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>};
</code></pre></div><p>因此，MMKV 在加载 m_file 前要将 crc 的校验值载入 m_metaInfo，载入前会确认 crc 完成映射：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (m_metaFile<span style="color:#719e07">-&gt;</span>isFileValid()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    m_metaInfo<span style="color:#719e07">-&gt;</span>read(m_metaFile<span style="color:#719e07">-&gt;</span>getMemory());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>注意 m_version 表示当前缓存的内容数据的状态，初始值为 MMKVVersionSequence。有以下几种：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">enum</span> <span style="color:#268bd2">MMKVVersion</span> <span style="color:#719e07">:</span> <span style="color:#dc322f">uint32_t</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    MMKVVersionDefault <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">// 记录了完全回写的次数
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>    MMKVVersionSequence <span style="color:#719e07">=</span> <span style="color:#2aa198">1</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    <span style="color:#586e75">// 存储了加密的随机 iv 
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75"></span>    MMKVVersionRandomIV <span style="color:#719e07">=</span> <span style="color:#2aa198">2</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    <span style="color:#586e75">// 存储了 actual size、crc checksum, 用于减少文件损坏的情况
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#586e75"></span>    MMKVVersionActualSize <span style="color:#719e07">=</span> <span style="color:#2aa198">3</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span>};
</code></pre></div><h3 id="aescrypter">AESCrypter</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">&gt;=</span> MMKVVersionRandomIV) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>        m_crypter<span style="color:#719e07">-&gt;</span>resetIV(m_metaInfo<span style="color:#719e07">-&gt;</span>m_vector, <span style="color:#719e07">sizeof</span>(m_metaInfo<span style="color:#719e07">-&gt;</span>m_vector));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>}
</code></pre></div><p>MMKV 初始化时，用户如果传入 AES Key，会通过 <code>resetIV</code> 来初始化 AES。</p>
<p>AES 属于块加密且存在多种加密模式，MMKV 中使用的是 CFB-128 模式。该模式需要同时使用 KEY 和 IV 来完成对数据的加密。</p>
<p>关于 AES 的介绍可以看 <a href="https://www.wikiwand.com/en/Block_cipher_mode_of_operation">WiKi</a>，这里只介绍一下 IV 向量的作用。</p>
<blockquote>
<p>IV称为初始向量，不同的IV加密后的字符串是不同的，加密和解密需要相同的IV，既然IV看起来和key一样，却还要多一个IV的目的，对于每个块来说，key是不变的，但是只有第一个块的IV是用户提供的，其他块IV都是自动生成。
IV的长度为16字节。超过或者不足，可能实现的库都会进行补齐或截断。但是由于块的长度是16字节，所以一般可以认为需要的IV是16字节。</p>
</blockquote>
<p>所以 metaInfo-&gt;m_vector 记录的就是 AES 的 IV 向量，其长度 <strong>AES_KEY_LEN</strong> 为 16。</p>
<p>接着就是 m_file 有效性检查 <code>isFileValid</code>。通过就进入下一阶段，否则尝试 <strong>reloadFromFile</strong>。</p>
<h2 id="数据有效性">数据有效性</h2>
<p>整个数据有效性是在 <code>checkDataValid</code> 中完成的，首先是读取 <code>m_actualSize</code> 。</p>
<h3 id="readactualsize">readActualSize</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>size_t MMKV<span style="color:#719e07">::</span>readActualSize() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    MMKV_ASSERT(m_file<span style="color:#719e07">-&gt;</span>getMemory());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    MMKV_ASSERT(m_metaFile<span style="color:#719e07">-&gt;</span>isFileValid());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#dc322f">uint32_t</span> actualSize <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    memcpy(<span style="color:#719e07">&amp;</span>actualSize, m_file<span style="color:#719e07">-&gt;</span>getMemory(), Fixed32Size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">&gt;=</span> MMKVVersionActualSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_actualSize <span style="color:#719e07">!=</span> actualSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            MMKVWarning(<span style="color:#2aa198">&#34;[%s] actual size %u, meta actual size %u&#34;</span>，...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        <span style="color:#719e07">return</span> m_metaInfo<span style="color:#719e07">-&gt;</span>m_actualSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#719e07">return</span> actualSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>}
</code></pre></div><p>如果 m_metaInfo 记录了 m_actualSize 将其优先返回。否则以文件记录值为准。这里 actualSize 通过读取 m_file 头部的固定长度 <strong>Fixed32Size</strong> 的数据。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">constexpr</span> <span style="color:#dc322f">uint32_t</span> LittleEdian32Size <span style="color:#719e07">=</span> <span style="color:#2aa198">4</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">constexpr</span> <span style="color:#dc322f">uint32_t</span> <span style="color:#268bd2">pbFixed32Size</span>() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    <span style="color:#719e07">return</span> LittleEdian32Size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">constexpr</span> <span style="color:#dc322f">uint32_t</span> Fixed32Size <span style="color:#719e07">=</span> pbFixed32Size();
</code></pre></div><p>其次，确认当前文件所剩余空间是否足够使用。前面提过对于未存储数据的部分默认是以 <code>\0</code> 填充的，因此这里需要将文件大小和真实数据大小进行比较。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>checkDataValid(<span style="color:#dc322f">bool</span> <span style="color:#719e07">&amp;</span>loadFromFile, <span style="color:#dc322f">bool</span> <span style="color:#719e07">&amp;</span>needFullWriteback) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#586e75">// try auto recover from last confirmed location
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"></span>    <span style="color:#719e07">auto</span> fileSize <span style="color:#719e07">=</span> m_file<span style="color:#719e07">-&gt;</span>getFileSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">auto</span> checkLastConfirmedInfo <span style="color:#719e07">=</span> [<span style="color:#719e07">&amp;</span>] { ... }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    m_actualSize <span style="color:#719e07">=</span> readActualSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">if</span> (m_actualSize <span style="color:#719e07">&lt;</span> fileSize <span style="color:#719e07">&amp;&amp;</span> (m_actualSize <span style="color:#719e07">+</span> Fixed32Size) <span style="color:#719e07">&lt;=</span> fileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#719e07">if</span> (checkFileCRCValid(m_actualSize, m_metaInfo<span style="color:#719e07">-&gt;</span>m_crcDigest)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            loadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>; <span style="color:#586e75">/// 数据正确且剩余空间足够
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            checkLastConfirmedInfo();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>           <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>loadFromFile) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                ⚠️ Handler <span style="color:#2aa198">3</span><span style="color:#719e07">:</span> 数据异常
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        checkLastConfirmedInfo();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>loadFromFile) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>            ⚠️ Handler <span style="color:#2aa198">4</span><span style="color:#719e07">:</span> 空间不足
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>}
</code></pre></div><p>如果空间足够，则计算出当前 m_file 真实数据的 crc digest，并与 m_metaInfo 的 m_crcDigest 对比。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>checkFileCRCValid(size_t actualSize, <span style="color:#dc322f">uint32_t</span> crcDigest) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">auto</span> ptr <span style="color:#719e07">=</span> (<span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span>) m_file<span style="color:#719e07">-&gt;</span>getMemory();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">if</span> (ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        m_crcDigest <span style="color:#719e07">=</span> (<span style="color:#dc322f">uint32_t</span>) CRC32(<span style="color:#2aa198">0</span>, (<span style="color:#719e07">const</span> <span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span>) ptr <span style="color:#719e07">+</span> Fixed32Size, (<span style="color:#dc322f">uint32_t</span>) actualSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">if</span> (m_crcDigest <span style="color:#719e07">==</span> crcDigest) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>            <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        MMKVError(<span style="color:#2aa198">&#34;check crc [%s] fail, crc32:%u, m_crcDigest:%u&#34;</span>, ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>}
</code></pre></div><p>另，关于 CRC 差错检测能力，移步<a href="https://baike.baidu.com/item/CRC/1453359">百科</a>。</p>
<p>校验通过就开始 m_file 内容的加载。</p>
<h3 id="checklastconfirmedinfo">checkLastConfirmedInfo</h3>
<p>如果数据异常或者空间不足，都会调用 checkLastConfirmedInfo 重新确认 loadFromFile 状态。checkLastConfirmedInfo 为 C++ 中的 lambda 函数，其声明在 checkDataValid 中，具体逻辑如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">&gt;=</span> MMKVVersionActualSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#586e75">// downgrade &amp; upgrade support
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"></span>    <span style="color:#dc322f">uint32_t</span> oldStyleActualSize <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    memcpy(<span style="color:#719e07">&amp;</span>oldStyleActualSize, m_file<span style="color:#719e07">-&gt;</span>getMemory(), Fixed32Size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (oldStyleActualSize <span style="color:#719e07">!=</span> m_actualSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        MMKVWarning(<span style="color:#2aa198">&#34;oldStyleActualSize not equal to meta actual size&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">if</span> (oldStyleActualSize <span style="color:#719e07">&lt;</span> fileSize <span style="color:#719e07">&amp;&amp;</span> (oldStyleActualSize <span style="color:#719e07">+</span> Fixed32Size) <span style="color:#719e07">&lt;=</span> fileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#719e07">if</span> (checkFileCRCValid(oldStyleActualSize, m_metaInfo<span style="color:#719e07">-&gt;</span>m_crcDigest)) { ⚠️ Handler <span style="color:#2aa198">1</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>                MMKVInfo(<span style="color:#2aa198">&#34;looks like [%s] been downgrade &amp; upgrade again&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>                loadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>                writeActualSize(oldStyleActualSize, m_metaInfo<span style="color:#719e07">-&gt;</span>m_crcDigest, <span style="color:#719e07">nullptr</span>, KeepSequence);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>                <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            MMKVWarning(<span style="color:#2aa198">&#34;oldStyleActualSize greater than file size&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#719e07">auto</span> lastActualSize <span style="color:#719e07">=</span> m_metaInfo<span style="color:#719e07">-&gt;</span>m_lastConfirmedMetaInfo.lastActualSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    <span style="color:#719e07">if</span> (lastActualSize <span style="color:#719e07">&lt;</span> fileSize <span style="color:#719e07">&amp;&amp;</span> (lastActualSize <span style="color:#719e07">+</span> Fixed32Size) <span style="color:#719e07">&lt;=</span> fileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        <span style="color:#719e07">auto</span> lastCRCDigest <span style="color:#719e07">=</span> m_metaInfo<span style="color:#719e07">-&gt;</span>m_lastConfirmedMetaInfo.lastCRCDigest;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#719e07">if</span> (checkFileCRCValid(lastActualSize, lastCRCDigest)) { ⚠️ Handler <span style="color:#2aa198">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>            loadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>            writeActualSize(lastActualSize, lastCRCDigest, <span style="color:#719e07">nullptr</span>, KeepSequence);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            MMKVError(<span style="color:#2aa198">&#34;check lastActualSize, lastActualCRC error&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>        MMKVError(<span style="color:#2aa198">&#34;check lastActualSize, file size error&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>}
</code></pre></div><p>在 MMKVMetaInfo 中的 <strong>m_lastConfirmedMetaInfo</strong> 可能记录了上一次校验过的 metaInfo，而只在 m_version 为 <strong>MMKVVersionActualSize</strong> 时，m_lastConfirmedMetaInfo 才有数据。故而 check 的前置条件为  &gt;= MMKVVersionActualSize。</p>
<p>检查中有两次恢复正确 metaInfo 的机会：</p>
<p><strong>Handler 1</strong></p>
<p><code>oldStyleActualSize</code> 记录值为 m_file 的内容数据大小，当其值不等于 m_metaInfo-&gt;m_actualSize 时，尝试以 <code>oldStyleActualSize</code> 为准更新 metaInfo 的信息。更新仍然要进行 CRC 校验，通过后将 loadFromFile 标记为 true，调用 writeActualSize 完成 metaInfo 的恢复。</p>
<p><strong>Handler 2</strong></p>
<p>最后一根救命稻草为 <strong>m_metaInfo-&gt;m_lastConfirmedMetaInfo.lastActualSize</strong>。用它再进行一次 Handler 1 的检查。</p>
<h3 id="writeactualsize">writeActualSize</h3>
<p>用于更新 m_metaInfo 信息，包括 actualSize、crcDigest、IV、lastConfrimInfo。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>writeActualSize(size_t size, <span style="color:#dc322f">uint32_t</span> crcDigest, <span style="color:#719e07">const</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>iv, <span style="color:#dc322f">bool</span> increaseSequence) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>   <span style="color:#586e75">// backward compatibility
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"></span>   oldStyleWriteActualSize(size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>   <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>m_metaFile<span style="color:#719e07">-&gt;</span>isFileValid()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>       <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>   <span style="color:#dc322f">bool</span> needsFullWrite <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>   m_actualSize <span style="color:#719e07">=</span> size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>   m_metaInfo<span style="color:#719e07">-&gt;</span>m_actualSize <span style="color:#719e07">=</span> <span style="color:#719e07">static_cast</span><span style="color:#719e07">&lt;</span><span style="color:#dc322f">uint32_t</span><span style="color:#719e07">&gt;</span>(size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>   m_crcDigest <span style="color:#719e07">=</span> crcDigest;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>   m_metaInfo<span style="color:#719e07">-&gt;</span>m_crcDigest <span style="color:#719e07">=</span> crcDigest;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>   <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">&lt;</span> MMKVVersionSequence) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>       m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">=</span> MMKVVersionSequence;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>       needsFullWrite <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>   <span style="color:#719e07">if</span> (unlikely(iv)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>       memcpy(m_metaInfo<span style="color:#719e07">-&gt;</span>m_vector, iv, <span style="color:#719e07">sizeof</span>(m_metaInfo<span style="color:#719e07">-&gt;</span>m_vector));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>       <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">&lt;</span> MMKVVersionRandomIV) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>           m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">=</span> MMKVVersionRandomIV;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>       }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>       needsFullWrite <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>   <span style="color:#719e07">if</span> (unlikely(increaseSequence)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>       m_metaInfo<span style="color:#719e07">-&gt;</span>m_sequence<span style="color:#719e07">++</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>       m_metaInfo<span style="color:#719e07">-&gt;</span>m_lastConfirmedMetaInfo.lastActualSize <span style="color:#719e07">=</span> <span style="color:#719e07">static_cast</span><span style="color:#719e07">&lt;</span><span style="color:#dc322f">uint32_t</span><span style="color:#719e07">&gt;</span>(size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>       m_metaInfo<span style="color:#719e07">-&gt;</span>m_lastConfirmedMetaInfo.lastCRCDigest <span style="color:#719e07">=</span> crcDigest;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>       <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">&lt;</span> MMKVVersionActualSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>           m_metaInfo<span style="color:#719e07">-&gt;</span>m_version <span style="color:#719e07">=</span> MMKVVersionActualSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>       }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>       needsFullWrite <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span><span style="color:#719e07">#ifdef MMKV_IOS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span><span style="color:#719e07"></span>   <span style="color:#719e07">return</span> <span style="color:#268bd2">protectFromBackgroundWriting</span>(m_metaFile<span style="color:#719e07">-&gt;</span>getMemory(), <span style="color:#719e07">sizeof</span>(MMKVMetaInfo), <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">36</span>     <span style="color:#719e07">if</span> (unlikely(needsFullWrite)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">37</span>         m_metaInfo<span style="color:#719e07">-&gt;</span>write(m_metaFile<span style="color:#719e07">-&gt;</span>getMemory());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">38</span>     } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">39</span>         m_metaInfo<span style="color:#719e07">-&gt;</span>writeCRCAndActualSizeOnly(m_metaFile<span style="color:#719e07">-&gt;</span>getMemory());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">40</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">41</span>   });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">42</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">43</span><span style="color:#719e07"></span>   ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">44</span><span style="color:#719e07">#endif
</span></code></pre></div><p>前三个参数就不用说了，看最后参数 <code>increaseSequence</code>，类型如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">enum</span> : <span style="color:#268bd2">bool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    KeepSequence <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    IncreaseSequence <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>};
</code></pre></div><p>它用于控制是否更新文件的 full write-back count 及 needsFullWrite。needsFullWrite 相当于 dirty bit 的作用，每当 m_version 有更新，都会将 needsFullWrite 标记为 dirty 用于之后的写回更新。</p>
<p><strong>write-back</strong> 概念后面会介绍。</p>
<h3 id="checkdatavalid">checkDataValid</h3>
<p>到这里，数据校验的主流程算是介绍完了，我们回到 checkDataValid，补上 checkLastConfirmedInfo 后数据状态依旧错误，loadlFromFile 为 false 的情况。</p>
<p><strong>Handler 3</strong> （标记在👆代码中）</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">auto</span> strategic <span style="color:#719e07">=</span> onMMKVCRCCheckFail(m_mmapID);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">if</span> (strategic <span style="color:#719e07">==</span> OnErrorRecover) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    loadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    needFullWriteback <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>MMKVInfo(<span style="color:#2aa198">&#34;recover strategic for [%s] is %d&#34;</span>, m_mmapID.c_str(), strategic);
</code></pre></div><p><strong>Handler 4</strong></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">auto</span> strategic <span style="color:#719e07">=</span> onMMKVFileLengthError(m_mmapID);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">if</span> (strategic <span style="color:#719e07">==</span> OnErrorRecover) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">// make sure we don&#39;t over read the file
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>    m_actualSize <span style="color:#719e07">=</span> fileSize <span style="color:#719e07">-</span> Fixed32Size;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    loadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    needFullWriteback <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>MMKVInfo(<span style="color:#2aa198">&#34;recover strategic for [%s] is %d&#34;</span>, m_mmapID.c_str(), strategic);
</code></pre></div><p>对于异常的处理策略，MMKV 为我们提供了修改的回调。策略有两种：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">enum</span> <span style="color:#268bd2">MMKVRecoverStrategic</span> <span style="color:#719e07">:</span> <span style="color:#dc322f">int</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    OnErrorDiscard <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    OnErrorRecover,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>};
</code></pre></div><p>默认 MMKV 会丢弃当前数据、清空文件和 metaInfo。此时可通过 <strong>g_errorHandler</strong> 修改：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">static</span> MMKVRecoverStrategic <span style="color:#268bd2">onMMKVCRCCheckFail</span>(<span style="color:#719e07">const</span> string <span style="color:#719e07">&amp;</span>mmapID) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (g_errorHandler) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> g_errorHandler(mmapID, MMKVErrorType<span style="color:#719e07">::</span>MMKVCRCCheckFail);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">return</span> OnErrorDiscard;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">static</span> MMKVRecoverStrategic <span style="color:#268bd2">onMMKVFileLengthError</span>(<span style="color:#719e07">const</span> string <span style="color:#719e07">&amp;</span>mmapID) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">if</span> (g_errorHandler) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        <span style="color:#719e07">return</span> g_errorHandler(mmapID, MMKVErrorType<span style="color:#719e07">::</span>MMKVFileLength);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">return</span> OnErrorDiscard;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>}
</code></pre></div><h2 id="数据处理">数据处理</h2>
<p>校验完有效性，依据其结果 <strong>loadFromFile</strong> 和 <strong>needFullWriteback</strong> 值来判定后续操作。简化后的 loadFromFile：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>loadFromFile() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#586e75">/// 1. 文件有效性
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"></span>    <span style="color:#586e75">/// 2. 数据有效性
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>    ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#dc322f">bool</span> loadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>, needFullWriteback <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    checkDataValid(loadFromFile, needFullWriteback);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">auto</span> ptr <span style="color:#719e07">=</span> (<span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span>) m_file<span style="color:#719e07">-&gt;</span>getMemory();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">if</span> (loadFromFile <span style="color:#719e07">&amp;&amp;</span> m_actualSize <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>       MMKVInfo(<span style="color:#2aa198">&#34;loading [%s] with crc %u sequence %u version&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>       <span style="color:#586e75">// loading    
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75"></span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>       <span style="color:#586e75">// file not valid or empty, discard everything
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75"></span>       SCOPED_LOCK(m_exclusiveProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>       m_output <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> CodedOutputData(ptr <span style="color:#719e07">+</span> Fixed32Size, m_file<span style="color:#719e07">-&gt;</span>getFileSize() <span style="color:#719e07">-</span> Fixed32Size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>       <span style="color:#719e07">if</span> (m_actualSize <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>           writeActualSize(<span style="color:#2aa198">0</span>, <span style="color:#2aa198">0</span>, <span style="color:#719e07">nullptr</span>, IncreaseSequence);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>           sync(MMKV_SYNC);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>       } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>           writeActualSize(<span style="color:#2aa198">0</span>, <span style="color:#2aa198">0</span>, <span style="color:#719e07">nullptr</span>, KeepSequence);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>       }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>};
</code></pre></div><p>先看异常处理。</p>
<p>当校验失败或文件为空，直接调用 writeActualSize 清理 metaInfo 缓存。</p>
<p>如果文件异常，传入 IncreaseSequence 来设置 dirt bit，以待下次重载 m_file。</p>
<h3 id="loading">Loading</h3>
<p>当 loadFromFile 为 true 且文件内容不为空，将数据从内存读入 MMBuffer，进行 AES 解密、清空 m_dic、准备 buffer 数据写入。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">// loading
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span>MMBuffer <span style="color:#268bd2">inputBuffer</span>(ptr <span style="color:#719e07">+</span> Fixed32Size, m_actualSize, MMBufferNoCopy);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    decryptBuffer(<span style="color:#719e07">*</span>m_crypter, inputBuffer);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>clearDictionary(m_dic);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">if</span> (needFullWriteback) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    MiniPBCoder<span style="color:#719e07">::</span>greedyDecodeMap(m_dic, inputBuffer);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    MiniPBCoder<span style="color:#719e07">::</span>decodeMap(m_dic, inputBuffer);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>m_output <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> CodedOutputData(ptr <span style="color:#719e07">+</span> Fixed32Size, m_file<span style="color:#719e07">-&gt;</span>getFileSize() <span style="color:#719e07">-</span> Fixed32Size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>m_output<span style="color:#719e07">-&gt;</span>seek(m_actualSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#719e07">if</span> (needFullWriteback) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    fullWriteback();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>}
</code></pre></div><p>数据写入 m_dic 后，创建 CodedOutputData 对象来记录当前映射的内存指针和文件大小，通过 seek 来记录读取的文件位置。</p>
<p>最后，当 needFullWriteback 为 true 时进行文件写回 <code>fullWriteback</code>。</p>
<p>写入策略分为贪婪模式和普通两种：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">void</span> MiniPBCoder<span style="color:#719e07">::</span>decodeMap(MMKVMap <span style="color:#719e07">&amp;</span>dic, <span style="color:#719e07">const</span> MMBuffer <span style="color:#719e07">&amp;</span>oData, size_t size) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    MiniPBCoder <span style="color:#268bd2">oCoder</span>(<span style="color:#719e07">&amp;</span>oData);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    oCoder.decodeOneMap(dic, size, <span style="color:#b58900">false</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#dc322f">void</span> MiniPBCoder<span style="color:#719e07">::</span>greedyDecodeMap(MMKVMap <span style="color:#719e07">&amp;</span>dic, <span style="color:#719e07">const</span> MMBuffer <span style="color:#719e07">&amp;</span>oData, size_t size) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    MiniPBCoder <span style="color:#268bd2">oCoder</span>(<span style="color:#719e07">&amp;</span>oData);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>    oCoder.decodeOneMap(dic, size, <span style="color:#b58900">true</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span>}
</code></pre></div><p>区别在于 greed 会将所有 buffer 转成 k-v 保存在 m_dic 中。</p>
<p>在前面的数据校验中可知，仅当校验失败且恢复策略为 <code>OnErrorRecover</code> 会将 <strong>needFullWriteback</strong> 标记为 ture。就是说，当数据异常或空间不足时，会采用贪婪策略尽可能的将数据优先读入内存。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MiniPBCoder<span style="color:#719e07">::</span>decodeOneMap(MMKVMap <span style="color:#719e07">&amp;</span>dic, size_t size, <span style="color:#dc322f">bool</span> greedy) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">auto</span> block <span style="color:#719e07">=</span> [size, <span style="color:#719e07">this</span>](MMKVMap <span style="color:#719e07">&amp;</span>dictionary) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">if</span> (size <span style="color:#719e07">==</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>            [[maybe_unused]] <span style="color:#719e07">auto</span> length <span style="color:#719e07">=</span> m_inputData<span style="color:#719e07">-&gt;</span>readInt32();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">while</span> (<span style="color:#719e07">!</span>m_inputData<span style="color:#719e07">-&gt;</span>isAtEnd()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>            <span style="color:#719e07">const</span> <span style="color:#719e07">auto</span> <span style="color:#719e07">&amp;</span>key <span style="color:#719e07">=</span> m_inputData<span style="color:#719e07">-&gt;</span>readString();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#719e07">if</span> (key.length <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>                <span style="color:#719e07">auto</span> value <span style="color:#719e07">=</span> m_inputData<span style="color:#719e07">-&gt;</span>readData();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>                <span style="color:#719e07">if</span> (value.length() <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>                    dictionary[key] <span style="color:#719e07">=</span> move(value);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>                    [key retain];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>                } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>                    <span style="color:#719e07">auto</span> itr <span style="color:#719e07">=</span> dictionary.find(key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                    <span style="color:#719e07">if</span> (itr <span style="color:#719e07">!=</span> dictionary.end()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>                        dictionary.erase(itr);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>                        [itr<span style="color:#719e07">-&gt;</span>first release];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>                }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>    };
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    <span style="color:#719e07">if</span> (greedy) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        <span style="color:#719e07">try</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            block(dic);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>        } <span style="color:#719e07">catch</span> (std<span style="color:#719e07">::</span>exception <span style="color:#719e07">&amp;</span>exception) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>            MMKVError(<span style="color:#2aa198">&#34;%s&#34;</span>, exception.what());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>        <span style="color:#719e07">try</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>            MMKVMap tmpDic;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>            block(tmpDic);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span>            dic.swap(tmpDic);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span>            <span style="color:#719e07">for</span> (<span style="color:#719e07">auto</span> <span style="color:#719e07">&amp;</span>pair : tmpDic) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">36</span>                [pair.first release];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">37</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">38</span>        } <span style="color:#719e07">catch</span> (std<span style="color:#719e07">::</span>exception <span style="color:#719e07">&amp;</span>exception) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">39</span>            MMKVError(<span style="color:#2aa198">&#34;%s&#34;</span>, exception.what());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">40</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">41</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">42</span>}
</code></pre></div><h3 id="fullwriteback">fullWriteback</h3>
<p>写回 (write-back) 作为缓存策略中的一种，其概念可以查看 <strong><a href="https://www.wikiwand.com/en/Cache_(computing)">wiki</a></strong>，简单描述如下：</p>
<blockquote>
<p>仅当一个缓存块需要被替换回内存时，才将其内容写入内存。而为了减少内存写操作，通过脏位标识该块在被载入之后是否发生过更新。如果一个缓存块在被置换回内存之前从未被写入过，则可以免去回写操作。</p>
</blockquote>
<p>MMKV 的写回操作就是将内存数据 m_dic 序列化后写回文件。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>fullWriteback() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    ...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">auto</span> allData <span style="color:#719e07">=</span> MiniPBCoder<span style="color:#719e07">::</span>encodeDataWithObject(m_dic);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    SCOPED_LOCK(m_exclusiveProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (allData.length() <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">auto</span> fileSize <span style="color:#719e07">=</span> m_file<span style="color:#719e07">-&gt;</span>getFileSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">if</span> (allData.length() <span style="color:#719e07">+</span> Fixed32Size <span style="color:#719e07">&lt;=</span> fileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            <span style="color:#719e07">return</span> <span style="color:#268bd2">doFullWriteBack</span>(std<span style="color:#719e07">::</span>move(allData));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            <span style="color:#586e75">// ensureMemorySize will extend file &amp; full rewrite, no need to write back again
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>            <span style="color:#719e07">return</span> <span style="color:#268bd2">ensureMemorySize</span>(allData.length() <span style="color:#719e07">+</span> Fixed32Size <span style="color:#719e07">-</span> fileSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>}
</code></pre></div><p>操作前会检查几个状态：</p>
<ul>
<li>m_hasFullWriteback：直接 return true</li>
<li>m_needLoadFromFile：直接 return true</li>
<li>isFileValid() 为 false：直接 return false</li>
<li>m_dic.empty() ：<code>clearAll()</code> 后 return true</li>
</ul>
<p>既然是数据读取，如果 m_dic 为空，认为数据可能出现异常。将会清理临时数据和内存缓存、重置相关标记位、重新加载文件。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>clearAll() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    MMKVInfo(<span style="color:#2aa198">&#34;cleaning all key-values from [%s]&#34;</span>, m_mmapID.c_str());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    SCOPED_LOCK(m_lock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    SCOPED_LOCK(m_exclusiveProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">if</span> (m_needLoadFromFile) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        m_file<span style="color:#719e07">-&gt;</span>reloadFromFile();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    m_file<span style="color:#719e07">-&gt;</span>truncate(DEFAULT_MMAP_SIZE);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#719e07">auto</span> ptr <span style="color:#719e07">=</span> m_file<span style="color:#719e07">-&gt;</span>getMemory();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">if</span> (ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        memset(ptr, <span style="color:#2aa198">0</span>, m_file<span style="color:#719e07">-&gt;</span>getFileSize());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    m_file<span style="color:#719e07">-&gt;</span>msync(MMKV_SYNC);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> newIV[AES_KEY_LEN];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    AESCrypt<span style="color:#719e07">::</span>fillRandomIV(newIV);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        m_crypter<span style="color:#719e07">-&gt;</span>resetIV(newIV, <span style="color:#719e07">sizeof</span>(newIV));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>    writeActualSize(<span style="color:#2aa198">0</span>, <span style="color:#2aa198">0</span>, newIV, IncreaseSequence);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>    m_metaFile<span style="color:#719e07">-&gt;</span>msync(MMKV_SYNC);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>    clearMemoryCache();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>    loadFromFile();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>}
</code></pre></div><p>检查通过后，将 m_dic 转换为 <strong>MiniPBCoder</strong> 即 binary data，写入前会确认当前文件 size 是否足够满足当前数据的写入，否则进行扩容。</p>
<h3 id="dofullwriteback">doFullWriteBack</h3>
<p>首先，生成 AES 随机 IV 对 allData 进行加密，接着通过 CodedOutputData 把 MMBuffer 写入 m_file，最后更新 crc 校验值。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>doFullWriteBack(MMBuffer <span style="color:#719e07">&amp;&amp;</span>allData) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">#ifdef MMKV_IOS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07"></span>    <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> oldIV[AES_KEY_LEN];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> newIV[AES_KEY_LEN];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        memcpy(oldIV, m_crypter<span style="color:#719e07">-&gt;</span>m_vector, <span style="color:#719e07">sizeof</span>(oldIV));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07"></span>    <span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">char</span> newIV[AES_KEY_LEN];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07"></span>        AESCrypt<span style="color:#719e07">::</span>fillRandomIV(newIV);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        m_crypter<span style="color:#719e07">-&gt;</span>resetIV(newIV, <span style="color:#719e07">sizeof</span>(newIV));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        <span style="color:#719e07">auto</span> ptr <span style="color:#719e07">=</span> allData.getPtr();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        m_crypter<span style="color:#719e07">-&gt;</span>encrypt(ptr, ptr, allData.length());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#719e07">auto</span> ptr <span style="color:#719e07">=</span> (<span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span>) m_file<span style="color:#719e07">-&gt;</span>getMemory();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    <span style="color:#719e07">delete</span> m_output;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    m_output <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> CodedOutputData(ptr <span style="color:#719e07">+</span> Fixed32Size, m_file<span style="color:#719e07">-&gt;</span>getFileSize() <span style="color:#719e07">-</span> Fixed32Size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07">#ifdef MMKV_IOS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#719e07"></span>    <span style="color:#719e07">auto</span> ret <span style="color:#719e07">=</span> protectFromBackgroundWriting(m_output<span style="color:#719e07">-&gt;</span>curWritePointer(), allData.length(), <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>      m_output<span style="color:#719e07">-&gt;</span>writeRawData(allData); <span style="color:#586e75">// note: don&#39;t write size of data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span><span style="color:#586e75"></span>    });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>ret) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        <span style="color:#586e75">// revert everything
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span><span style="color:#586e75"></span>        <span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>            m_crypter<span style="color:#719e07">-&gt;</span>resetIV(oldIV);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>        <span style="color:#719e07">delete</span> m_output;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>        m_output <span style="color:#719e07">=</span> <span style="color:#719e07">new</span> CodedOutputData(ptr <span style="color:#719e07">+</span> Fixed32Size, m_file<span style="color:#719e07">-&gt;</span>getFileSize() <span style="color:#719e07">-</span> Fixed32Size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>        m_output<span style="color:#719e07">-&gt;</span>seek(m_actualSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span><span style="color:#719e07"></span>    m_output<span style="color:#719e07">-&gt;</span>writeRawData(allData); <span style="color:#586e75">// note: don&#39;t write size of data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">36</span><span style="color:#586e75"></span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">37</span><span style="color:#719e07"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">38</span>    m_actualSize <span style="color:#719e07">=</span> allData.length();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">39</span>    <span style="color:#719e07">if</span> (m_crypter) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">40</span>        recaculateCRCDigestWithIV(newIV);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">41</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">42</span>        recaculateCRCDigestWithIV(<span style="color:#719e07">nullptr</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">43</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">44</span>    m_hasFullWriteback <span style="color:#719e07">=</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">45</span>    <span style="color:#586e75">// make sure lastConfirmedMetaInfo is saved
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">46</span><span style="color:#586e75"></span>    sync(MMKV_SYNC);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">47</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">48</span>}
</code></pre></div><h3 id="recaculatecrcdigestwithiv">recaculateCRCDigestWithIV</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>recaculateCRCDigestWithIV(<span style="color:#719e07">const</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>iv) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">auto</span> ptr <span style="color:#719e07">=</span> (<span style="color:#719e07">const</span> <span style="color:#dc322f">uint8_t</span> <span style="color:#719e07">*</span>) m_file<span style="color:#719e07">-&gt;</span>getMemory();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">if</span> (ptr) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    m_crcDigest <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    m_crcDigest <span style="color:#719e07">=</span> (<span style="color:#dc322f">uint32_t</span>) CRC32(<span style="color:#2aa198">0</span>, ptr <span style="color:#719e07">+</span> Fixed32Size, (<span style="color:#dc322f">uint32_t</span>) m_actualSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    writeActualSize(m_actualSize, m_crcDigest, iv, IncreaseSequence);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>}
</code></pre></div><p>注意，重新生成 crc digest 这一行为只有在 full write-back 中被调用。尽管这里调用 writeActualSize 更新 m_metaInfo 并增加了 m_sequence，<strong>但是 actualSize 并没有变化</strong>。</p>
<h3 id="ensurememorysize">ensureMemorySize</h3>
<p>除了完全写回的情况，当 append 的数据超出 fileSize 也会进行扩容。扩容策略以 2 倍于原来的 fileSize，不断扩充，直到比扩充的额外容量大为止。最后通过 truncate 裁剪至 <code>DEFAULT_MMAP_SIZE</code> 的整数倍。</p>
<p>核心逻辑如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">constexpr</span> size_t ItemSizeHolderSize <span style="color:#719e07">=</span> <span style="color:#2aa198">4</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">if</span> (m_dic.empty()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    newSize <span style="color:#719e07">+=</span> ItemSizeHolderSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">if</span> (newSize <span style="color:#719e07">&gt;=</span> m_output<span style="color:#719e07">-&gt;</span>spaceLeft() <span style="color:#719e07">||</span> m_dic.empty()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">auto</span> fileSize <span style="color:#719e07">=</span> m_file<span style="color:#719e07">-&gt;</span>getFileSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    MMBuffer data <span style="color:#719e07">=</span> MiniPBCoder<span style="color:#719e07">::</span>encodeDataWithObject(m_dic);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    size_t lenNeeded <span style="color:#719e07">=</span> data.length() <span style="color:#719e07">+</span> Fixed32Size <span style="color:#719e07">+</span> newSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    size_t avgItemSize <span style="color:#719e07">=</span> lenNeeded <span style="color:#719e07">/</span> std<span style="color:#719e07">::</span>max<span style="color:#719e07">&lt;</span>size_t<span style="color:#719e07">&gt;</span>(<span style="color:#2aa198">1</span>, m_dic.size());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    size_t futureUsage <span style="color:#719e07">=</span> avgItemSize <span style="color:#719e07">*</span> std<span style="color:#719e07">::</span>max<span style="color:#719e07">&lt;</span>size_t<span style="color:#719e07">&gt;</span>(<span style="color:#2aa198">8</span>, (m_dic.size() <span style="color:#719e07">+</span> <span style="color:#2aa198">1</span>) <span style="color:#719e07">/</span> <span style="color:#2aa198">2</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>	<span style="color:#586e75">// 所需空间 &gt;= 当前文件大小 || 所需空间的 1.5 倍于当前文件大小
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75"></span>    <span style="color:#719e07">if</span> (lenNeeded <span style="color:#719e07">&gt;=</span> fileSize <span style="color:#719e07">||</span> (lenNeeded <span style="color:#719e07">+</span> futureUsage) <span style="color:#719e07">&gt;=</span> fileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        size_t oldSize <span style="color:#719e07">=</span> fileSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#719e07">do</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            fileSize <span style="color:#719e07">*=</span> <span style="color:#2aa198">2</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>        } <span style="color:#719e07">while</span> (lenNeeded <span style="color:#719e07">+</span> futureUsage <span style="color:#719e07">&gt;=</span> fileSize);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>m_file<span style="color:#719e07">-&gt;</span>truncate(fileSize)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>            <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>isFileValid()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>            MMKVWarning(<span style="color:#2aa198">&#34;[%s] file not valid&#34;</span>, m_mmapID.c_str());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>            <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>    <span style="color:#719e07">return</span> <span style="color:#268bd2">doFullWriteBack</span>(std<span style="color:#719e07">::</span>move(data));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>}
</code></pre></div><h1 id="setter">Setter</h1>
<p>改版后 iOS 端的 setter 则直接在 C++ API 上套了一层。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">bool</span> <span style="color:#268bd2">set</span>(<span style="color:#dc322f">bool</span> value, MMKVKey_t key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75">// avoid unexpected type conversion (pointer to bool, etc)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#586e75"></span><span style="color:#719e07">template</span> <span style="color:#719e07">&lt;</span><span style="color:#719e07">typename</span> T<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#dc322f">bool</span> set(T value, MMKVKey_t key) <span style="color:#719e07">=</span> <span style="color:#719e07">delete</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#dc322f">bool</span> <span style="color:#268bd2">set</span>(NSObject<span style="color:#719e07">&lt;</span>NSCoding<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>__unsafe_unretained obj, MMKVKey_t key);
</code></pre></div><p>先以 bool 为例：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>set(<span style="color:#dc322f">bool</span> value, MMKVKey_t key) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (isKeyEmpty(key)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    size_t size <span style="color:#719e07">=</span> pbBoolSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    MMBuffer <span style="color:#268bd2">data</span>(size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    CodedOutputData <span style="color:#268bd2">output</span>(data.getPtr(), size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    output.writeBool(value);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">return</span> <span style="color:#268bd2">setDataForKey</span>(std<span style="color:#719e07">::</span>move(data), key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>}
</code></pre></div><p>value 通过 CodedOutputData 写入 MMBuffer，最后走向了 setDataForKey。其他数据类型也是一样套路。</p>
<h2 id="setdataforkey">setDataForKey</h2>
<p>更新 k-v 的核心方法，承接了全部数据更新的入口，做了三件事情：</p>
<ol>
<li>数据校验，确认是否需要刷新缓存，重新加载文件；</li>
<li>将 buffer 数据写入文件；</li>
<li>更新 m_dic;</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>setDataForKey(MMBuffer <span style="color:#719e07">&amp;&amp;</span>data, MMKVKey_t key) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (data.length() <span style="color:#719e07">==</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">||</span> isKeyEmpty(key)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    SCOPED_LOCK(m_lock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    SCOPED_LOCK(m_exclusiveProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    checkLoadData();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">auto</span> ret <span style="color:#719e07">=</span> appendDataWithKey(data, key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">if</span> (ret) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        m_dic[key] <span style="color:#719e07">=</span> std<span style="color:#719e07">::</span>move(data);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>        m_hasFullWriteback <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#719e07"></span>        [key retain];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#719e07"></span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>    <span style="color:#719e07">return</span> ret;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>}
</code></pre></div><p>整个 MMKV.cpp 文件中就这方法里冒出来一行 <strong>[key retain]</strong>，这也是为啥这里 MMKV.cpp 采用 MRC 的原因。至于为啥要 retain 大家可以 🤔 一下。</p>
<h3 id="checkloaddata">checkLoadData</h3>
<p>数据校验，第一步是确认 m_needLoadFromFile 为 true，是则加锁执行 loadFromFile。</p>
<p>接下来的检查是防止文件被其他进程篡改，对于单进程则无需考虑该 case，直接 return。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span> MMKV<span style="color:#719e07">::</span>checkLoadData() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (m_needLoadFromFile) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        SCOPED_LOCK(m_sharedProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        m_needLoadFromFile <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        loadFromFile();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>m_isInterProcess) { <span style="color:#586e75">// single process
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span>        <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>m_metaFile<span style="color:#719e07">-&gt;</span>isFileValid()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>        <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>    <span style="color:#586e75">// TODO: atomic lock m_metaFile?
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span><span style="color:#586e75"></span>    MMKVMetaInfo metaInfo;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    metaInfo.read(m_metaFile<span style="color:#719e07">-&gt;</span>getMemory());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    <span style="color:#719e07">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_sequence <span style="color:#719e07">!=</span> metaInfo.m_sequence) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        MMKVInfo(<span style="color:#2aa198">&#34;[%s] oldSeq %u, newSeq %u&#34;</span>, ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        SCOPED_LOCK(m_sharedProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>        clearMemoryCache();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>        loadFromFile();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>        notifyContentChanged();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>    } <span style="color:#719e07">else</span> <span style="color:#268bd2">if</span> (m_metaInfo<span style="color:#719e07">-&gt;</span>m_crcDigest <span style="color:#719e07">!=</span> metaInfo.m_crcDigest) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>        MMKVDebug(<span style="color:#2aa198">&#34;[%s] oldCrc %u, newCrc %u, new actualSize&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>        SCOPED_LOCK(m_sharedProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>        size_t fileSize <span style="color:#719e07">=</span> m_file<span style="color:#719e07">-&gt;</span>getActualFileSize();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>        <span style="color:#719e07">if</span> (m_file<span style="color:#719e07">-&gt;</span>getFileSize() <span style="color:#719e07">!=</span> fileSize) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>            MMKVInfo(<span style="color:#2aa198">&#34;file size has changed [%s] from %zu to %zu&#34;</span> ...);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>            clearMemoryCache();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">34</span>            loadFromFile();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">35</span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">36</span>            partialLoadFromFile();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">37</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">38</span>        notifyContentChanged();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">39</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">40</span>}
</code></pre></div><p>防止文件的多进程篡改，会先读取 crc 文件中记录的 metaInfo 与当前内存的 m_metaInfo 对比。metaInfo 中的数据更新都在 writeActualSize 中完成。而当文件读取异常、空间不足或 crc 校验失败，这些情况发生时，会触发 meta_info 的变更。具体处理：</p>
<ol>
<li>m_sequence 代表了脏位数据 dirt bit 存在，此时需要 重新加载 m_file。</li>
<li>m_crcDigest 不同且 fileSize 不同，说明进行了扩容，也需要重新加载 m_file。</li>
<li>m_crcDigest 不同且 fileSize 相同，说明进行了 full write-back，之后会通过 <code>partialLoadFromFile</code> 完成相关内存数据的更新。</li>
</ol>
<h3 id="appenddata">appendData</h3>
<p>官方说明</p>
<blockquote>
<p>标准 protobuf 不提供增量更新的能力，每次写入都必须全量写入。考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力：将增量 kv 对象序列化后，直接 append 到内存末尾；这样同一个 key 会有新旧若干份数据，最新的数据在最后；那么只需在程序启动第一次打开 mmkv 时，不断用后读入的 value 替换之前的值，就可以保证数据是最新有效的。</p>
</blockquote>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>appendDataWithKey(<span style="color:#719e07">const</span> MMBuffer <span style="color:#719e07">&amp;</span>data, MMKVKey_t key) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07"></span>    <span style="color:#719e07">auto</span> keyData <span style="color:#719e07">=</span> [key dataUsingEncoding:NSUTF8StringEncoding];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    size_t keyLength <span style="color:#719e07">=</span> keyData.length;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07"></span>    size_t keyLength <span style="color:#719e07">=</span> key.length();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07"></span>    <span style="color:#586e75">// size needed to encode the key
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"></span>    size_t size <span style="color:#719e07">=</span> keyLength <span style="color:#719e07">+</span> pbRawVarint32Size((<span style="color:#dc322f">int32_t</span>) keyLength);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#586e75">// size needed to encode the value
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>    size <span style="color:#719e07">+=</span> data.length() <span style="color:#719e07">+</span> pbRawVarint32Size((<span style="color:#dc322f">int32_t</span>) data.length());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    SCOPED_LOCK(m_exclusiveProcessLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    <span style="color:#dc322f">bool</span> hasEnoughSize <span style="color:#719e07">=</span> ensureMemorySize(size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>hasEnoughSize <span style="color:#719e07">||</span> <span style="color:#719e07">!</span>isFileValid()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07">#ifdef MMKV_IOS
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#719e07"></span>    <span style="color:#719e07">auto</span> ret <span style="color:#719e07">=</span> protectFromBackgroundWriting(m_output<span style="color:#719e07">-&gt;</span>curWritePointer(), size, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>      m_output<span style="color:#719e07">-&gt;</span>writeData(MMBuffer(keyData, MMBufferNoCopy));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>      m_output<span style="color:#719e07">-&gt;</span>writeData(data); <span style="color:#586e75">// note: write size of data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span><span style="color:#586e75"></span>    });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>ret) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span><span style="color:#719e07"></span>    ... <span style="color:#586e75">/// 除了 iOS 需要判断 background mode，其余均直接 m_output-&gt;writeData(data);
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span><span style="color:#586e75"></span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span><span style="color:#719e07"></span>    ... <span style="color:#586e75">// encrypt 数据，更新 m_actualSize、crcDigest
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span><span style="color:#586e75"></span>    <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>}
</code></pre></div><p>追加逻辑比较简单，就是将存储 Key、Data 的 MMBuffer 经过 pb 压缩后写入 m_file。直接追加到 m_file 末尾带来的问题就是空间快速增长，导致文件大小不可控。因此，每次写入需要检查剩余文件空间。</p>
<h3 id="set-object">Set Object</h3>
<p>再来看看 Objc 中的 NSObject 是如何存取的。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>set(NSObject<span style="color:#719e07">&lt;</span>NSCoding<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>__unsafe_unretained obj, MMKVKey_t key) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (isKeyEmpty(key)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>obj) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        removeValueForKey(key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    MMBuffer data;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">if</span> (MiniPBCoder<span style="color:#719e07">::</span>isCompatibleObject(obj)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        data <span style="color:#719e07">=</span> MiniPBCoder<span style="color:#719e07">::</span>encodeDataWithObject(obj);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        <span style="color:#586e75">/*if ([object conformsToProtocol:@protocol(NSCoding)])*/</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            <span style="color:#719e07">auto</span> tmp <span style="color:#719e07">=</span> [NSKeyedArchiver archivedDataWithRootObject:obj];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            <span style="color:#719e07">if</span> (tmp.length <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>                data <span style="color:#719e07">=</span> MMBuffer(tmp);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    <span style="color:#719e07">return</span> <span style="color:#268bd2">setDataForKey</span>(std<span style="color:#719e07">::</span>move(data), key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>}
</code></pre></div><p>对 Objc 而言 MiniPBCoder 仅支持了基本数据类型和 NSString、NSData、NSDate 这三种：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MiniPBCoder<span style="color:#719e07">::</span>isCompatibleObject(NSObject <span style="color:#719e07">*</span>obj) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> ([obj isKindOfClass:[NSString <span style="color:#719e07">class</span>]]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> ([obj isKindOfClass:[NSData <span style="color:#719e07">class</span>]]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">if</span> ([obj isKindOfClass:[NSDate <span style="color:#719e07">class</span>]]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#719e07">return</span> <span style="color:#b58900">true</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">return</span> <span style="color:#b58900">false</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>}
</code></pre></div><p>其余 NSObject 对象就需要走 NSCoding 协议通过 NSArchive 方式编码为 NSData 存入。</p>
<h1 id="getter">Getter</h1>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">bool</span> <span style="color:#268bd2">getBool</span>(MMKVKey_t key, <span style="color:#dc322f">bool</span> defaultValue <span style="color:#719e07">=</span> <span style="color:#b58900">false</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>...
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">#ifdef MMKV_APPLE
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07"></span>    NSObject <span style="color:#719e07">*</span>getObject(MMKVKey_t key, Class cls);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">#else  </span><span style="color:#586e75">// !defined(MMKV_APPLE)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#586e75"></span>    mmkv<span style="color:#719e07">::</span>MMBuffer getBytes(MMKVKey_t key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>    <span style="color:#dc322f">bool</span> <span style="color:#268bd2">getVector</span>(MMKVKey_t key, std<span style="color:#719e07">::</span>vector<span style="color:#719e07">&lt;</span>std<span style="color:#719e07">::</span>string<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&amp;</span>result);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span><span style="color:#719e07">#endif </span><span style="color:#586e75">// MMKV_APPLE
</span></code></pre></div><p>以 bool 为例：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">bool</span> MMKV<span style="color:#719e07">::</span>getBool(MMKVKey_t key, <span style="color:#dc322f">bool</span> defaultValue) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (isKeyEmpty(key)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> defaultValue;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    SCOPED_LOCK(m_lock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">auto</span> <span style="color:#719e07">&amp;</span>data <span style="color:#719e07">=</span> getDataForKey(key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">if</span> (data.length() <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#719e07">try</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            CodedInputData <span style="color:#268bd2">input</span>(data.getPtr(), data.length());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            <span style="color:#719e07">return</span> input.readBool();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        } <span style="color:#719e07">catch</span> (std<span style="color:#719e07">::</span>exception <span style="color:#719e07">&amp;</span>exception) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            MMKVError(<span style="color:#2aa198">&#34;%s&#34;</span>, exception.what());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>    <span style="color:#719e07">return</span> defaultValue;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>}
</code></pre></div><p>数据读取就更简单了，直接从 getDataForKey 中取出 MMBuffer，经过 CodedOutputData 转换得到 bool。</p>
<h2 id="getdataforkey">getDataForKey</h2>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">const</span> MMBuffer <span style="color:#719e07">&amp;</span>MMKV<span style="color:#719e07">::</span>getDataForKey(MMKVKey_t key) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    checkLoadData();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#719e07">auto</span> itr <span style="color:#719e07">=</span> m_dic.find(key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    <span style="color:#719e07">if</span> (itr <span style="color:#719e07">!=</span> m_dic.end()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>        <span style="color:#719e07">return</span> itr<span style="color:#719e07">-&gt;</span>second;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    <span style="color:#719e07">static</span> MMBuffer nan;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>    <span style="color:#719e07">return</span> nan;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span>}
</code></pre></div><h2 id="get-object">Get Object</h2>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>NSObject <span style="color:#719e07">*</span>MMKV<span style="color:#719e07">::</span>getObject(MMKVKey_t key, Class cls) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (isKeyEmpty(key) <span style="color:#719e07">||</span> <span style="color:#719e07">!</span>cls) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#719e07">return</span> nil;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    SCOPED_LOCK(m_lock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">auto</span> <span style="color:#719e07">&amp;</span>data <span style="color:#719e07">=</span> getDataForKey(key);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">if</span> (data.length() <span style="color:#719e07">&gt;</span> <span style="color:#2aa198">0</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#719e07">if</span> (MiniPBCoder<span style="color:#719e07">::</span>isCompatibleClass(cls)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            <span style="color:#719e07">try</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>                <span style="color:#719e07">auto</span> result <span style="color:#719e07">=</span> MiniPBCoder<span style="color:#719e07">::</span>decodeObject(data, cls);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>                <span style="color:#719e07">return</span> result;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            } <span style="color:#719e07">catch</span> (std<span style="color:#719e07">::</span>exception <span style="color:#719e07">&amp;</span>exception) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>                MMKVError(<span style="color:#2aa198">&#34;%s&#34;</span>, exception.what());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            <span style="color:#719e07">if</span> ([cls conformsToProtocol:@protocol(NSCoding)]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>                <span style="color:#719e07">auto</span> tmp <span style="color:#719e07">=</span> [NSData dataWithBytesNoCopy:data.getPtr() length:data.length() freeWhenDone:NO];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                <span style="color:#719e07">return</span> [NSKeyedUnarchiver unarchiveObjectWithData:tmp];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>    <span style="color:#719e07">return</span> nil;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>}
</code></pre></div><p>这个也比较简单就不展开了。</p>
<h2 id="总结"><strong>总结</strong></h2>
<p><strong>宁可错杀一千，也绝不放过一个。</strong></p>
<p>这是整体读完 MMKV 核心逻辑的第一感受。为什么呢？</p>
<p>MMKV 作为多进程读写的框架。细心的同学可以发现，在它的每一个方法的真正逻辑执行前都进行了大量的异常校验，同时对于脏数据的保护和容错也比较绕。感觉你不把所有方法看过一遍，比较难 get 到其中的用意。相比这一点，<a href="https://juejin.im/post/5eafe0796fb9a0438c2550e3">CocoaLumberjack</a> 的代码就非常友好了，每个关键字段的作用，核心逻辑的解释，以及背后的一些原理都有很详细的注释。</p>
<p>本文忽略了 MiniPB 的编解码逻辑和读写锁保护，以核心逻辑文件读写为主。MMKV 对于只要异常就是各种标记，然后重载。整个框架也是围绕 loadFromFile 不断的添加保护，文件锁，crc 校验，脏数据写回。</p>
<p>如果你看到这里，应该能发现，本文是按照调用逻辑一层层深入，尽可能地让各个方法的上下文是衔接有序。希望能帮助各位大致了解 MMKV 的核心逻辑。</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/source-code">Source Code</a>
     
    <a href="https://looseyi.github.io/tags/ios">iOS</a>
     
    <a href="https://looseyi.github.io/tags/cache">Cache</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/sourcecode-cocoapods/01-cocoapods-toolchains/"><span>←</span><span>1. 版本管理工具及 Ruby 工具链环境</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-ios/source-code-lumberjack-3/"><span>浅析 - CocoaLumberjack 3.6 之 DatabaseLogger</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
