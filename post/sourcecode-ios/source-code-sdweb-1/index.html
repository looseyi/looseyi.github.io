<!DOCTYPE html>















<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>浅析 SDWebImage 5.6 - Aha Edmond</title>

  
  
  <meta name="description" content="本文基于 SDWebImage 5.6。重读的原因也是由于发现它的 API 在不断迭代，许多结构已经不同与早期版本，同时也是为了做一个记录。阅读顺序也会依据 API 执行顺序进行" />
  <meta name="author" content="土土Edmond木" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://looseyi.github.io/app.min.css" />

  

  
  <link rel="preload" as="image" href="https://looseyi.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://looseyi.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://looseyi.github.io/github.svg" />
  

  
  <link rel="icon" href="https://looseyi.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://looseyi.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.82.1" />

  
  
  <link
    rel="alternate"
    type="application/rss&#43;xml"
    href="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-1/index.xml"
    title="Aha Edmond"
  />
  

  
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62789092-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
  
  <meta property="og:title" content="浅析 SDWebImage 5.6" />
<meta property="og:description" content="本文基于 SDWebImage 5.6。重读的原因也是由于发现它的 API 在不断迭代，许多结构已经不同与早期版本，同时也是为了做一个记录。阅读顺序也会依据 API 执行顺序进行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-1/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-02-22T23:08:12&#43;08:00" />
<meta property="article:modified_time" content="2020-02-22T23:08:12&#43;08:00" />


  
  <meta itemprop="name" content="浅析 SDWebImage 5.6">
<meta itemprop="description" content="本文基于 SDWebImage 5.6。重读的原因也是由于发现它的 API 在不断迭代，许多结构已经不同与早期版本，同时也是为了做一个记录。阅读顺序也会依据 API 执行顺序进行"><meta itemprop="datePublished" content="2020-02-22T23:08:12&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-22T23:08:12&#43;08:00" />
<meta itemprop="wordCount" content="8772">
<meta itemprop="keywords" content="Source Code,iOS,cache," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="浅析 SDWebImage 5.6"/>
<meta name="twitter:description" content="本文基于 SDWebImage 5.6。重读的原因也是由于发现它的 API 在不断迭代，许多结构已经不同与早期版本，同时也是为了做一个记录。阅读顺序也会依据 API 执行顺序进行"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://looseyi.github.io/">Aha Edmond</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/">Home</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="twitter"
      style="--url: url(./twitter.svg)"
      href="https://twitter.com/looseyi"
      target="_blank"
    ></a>
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/looseyi"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">
			

<article class="post-single">
  <header class="post-title">
    <p>
      <time>2020-02-22</time>
      
      <span>土土Edmond木</span>
      
    </p>
    <h1>浅析 SDWebImage 5.6</h1>
  </header>
  <section class="post-content"><p>本文基于 SDWebImage 5.6。重读的原因也是由于发现它的 API 在不断迭代，许多结构已经不同与早期版本，同时也是为了做一个记录。阅读顺序也会依据 API 执行顺序进行，不会太拘泥于细节，更多是了解整个框架是如何运行的。</p>
<p><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="highlevel"></p>
<h2 id="5x-migration-guid">5.x Migration Guid</h2>
<p>如果大家有兴趣的，强烈推荐观看官方的推荐的<a href="https://github.com/SDWebImage/SDWebImage/wiki/5.0-Migration-guide">迁移文档</a>，提到了5.x 版本的需要新特性，里面详细介绍其新特性和变化动机，主要 features：</p>
<ul>
<li>全新的 Animated Image View  (4.0 为 <code>FLAnimatedImageView</code>)；</li>
<li>提供了 Image Transform 方便用户在下载图片后增加 scale, rotate, rounded corner 等操作；</li>
<li>Customization，可以说一切皆协议，可以 custom <a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-cache-50">cache</a>、<a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-loader-50">loader</a>、<a href="https://github.com/SDWebImage/SDWebImage/wiki/Advanced-Usage#custom-coder-420">coder</a>；</li>
<li>新增 View Indicator 来标识 Image 的 loading 状态；</li>
</ul>
<p>可以说，5.x 的变化在于将整个 SDWebImage 中的核心类进行了协议化，同时将图片的请求、加载、解码、缓存等操作尽可能的进行了插件化处理，达到方便扩展、可替换。</p>
<p>协议化的类型很多，这里仅列出一小部分：</p>
<table>
<thead>
<tr>
<th>4.4</th>
<th>5.x</th>
</tr>
</thead>
<tbody>
<tr>
<td>SDWebImageCacheSerializerBlock</td>
<td>id&lt;SDWebImageCacheSerializer&gt;</td>
</tr>
<tr>
<td>SDWebImageCacheKeyFilterBlock</td>
<td>id&lt;SDWebImageCacheKeyFilter&gt;</td>
</tr>
<tr>
<td>SDWebImageDownloader</td>
<td>id&lt;SDImageLoader&gt;</td>
</tr>
<tr>
<td>SDImageCache</td>
<td>id&lt;SDImageCache&gt;</td>
</tr>
<tr>
<td>SDWebImageDownloaderProgressBlock</td>
<td>id&lt;SDWebImageIndicator&gt;</td>
</tr>
<tr>
<td>FLAnimatedImageView</td>
<td>id&lt;SDAnimatedImage&gt;</td>
</tr>
</tbody>
</table>
<h2 id="view-category">View Category</h2>
<p>作为上层 API 调用是通过在 <code>UIView + WebCache</code> 之上提供便利方法实现的，包含以下几个 ：</p>
<ul>
<li>UIImageView+HighlightedWebCache</li>
<li>UIImageView+WebCache</li>
<li>UIView+WebCacheOperation</li>
<li>UIButton+WebCache</li>
<li>NSButton+WebCache</li>
</ul>
<p>开始前，先来看看 <a href="https://github.com/SDWebImage/SDWebImage/blob/09f06159a3284f6981d5495728e5c3cb3dfb82fa/SDWebImage/Core/SDWebImageCompat.h">SDWebImageCompat.h</a> 它定义了<strong>SD_MAC、SD_UIKIT、SD_WATCH</strong> 这三个宏用来区分不同系统的 API 来满足条件编译，同时还利用其来抹除 API 在不同平台的差异，比如利用 <code>#define UIImage NSImage</code> 将 mac 上的 NSImage 统一为 UIImage。另外值得注意的一点就是：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#ifndef dispatch_main_async_safe
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">#define dispatch_main_async_safe(block)\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">        block();\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">    } else {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">        dispatch_async(dispatch_get_main_queue(), block);\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">    }
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">#endif
</span></code></pre></div><p>区别于早起版本的实现：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">#define dispatch_main_async_safe(block)\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">    if ([NSThread isMainThread]) {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">        block();\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">    } else {\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">        dispatch_async(dispatch_get_main_queue(), block);\
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">    }
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">#endif
</span></code></pre></div><ul>
<li><code>#ifndef</code> 提高了代码的严谨度，防止重复定义 <code>dispatch_main_async_safe</code></li>
<li>判断条件由 isMainThread 改为了 dispatch_queue_t label 是否相等</li>
</ul>
<p>关于第二点，有一篇 <a href="https://github.com/SDWebImage/SDWebImage/pull/781">SD 的讨论</a>，以及另一篇说明 <a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/">GCD&rsquo;s Main Queue vs. Main Thread</a></p>
<blockquote>
<p>Calling an API from a non-main queue that is executing on the main thread will lead to issues if the library (like VektorKit) relies on checking for execution on the main queue.</p>
</blockquote>
<p>区别就是从判断<strong>是否在主线程执行</strong>改为<strong>是否在主队列上调度</strong>。因为 <strong>在主队列中的任务，一定会放到主线程执行</strong>。</p>
<p>相比 UIImageView 的分类，UIButton 需要存储不同 <code>UIControlState</code> 和 backgrounImage 下的 image，Associate 了一个内部字典 <code>(NSMutableDictionary&lt;NSString *, NSURL *&gt; *)sd_imageURLStorage</code> 来保存图片。</p>
<p>所有 View Category 的 <code>setImageUrl:</code> 最终收口到下面这个方法:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">sd_internalSetImageWithURL:</span>(nullable NSURL <span style="color:#719e07">*</span>)<span style="color:#268bd2">url</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>                  <span style="color:#268bd2">placeholderImage:</span>(nullable UIImage <span style="color:#719e07">*</span>)<span style="color:#268bd2">placeholder</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>                           <span style="color:#268bd2">options:</span>(SDWebImageOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>                           <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>                     <span style="color:#268bd2">setImageBlock:</span>(nullable SDSetImageBlock)<span style="color:#268bd2">setImageBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>                          <span style="color:#268bd2">progress:</span>(nullable SDImageLoaderProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>                         <span style="color:#268bd2">completed:</span>(nullable SDInternalCompletionBlock)<span style="color:#268bd2">completedBlock</span>;
</code></pre></div><p>这个方法实现很长，简单说明流程：</p>
<ol>
<li>将 <code>SDWebImageContext</code>  复制并转换为 immutable，获取其中的 <code>validOperationKey</code> 值作为校验 id，默认值为当前 view 的类名；</li>
<li>执行 <code>sd_cancelImageLoadOperationWithKey</code> 取消上一次任务，保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突；</li>
<li>设置占位图；</li>
<li>初始化 <code>SDWebImageManager</code> 、<code>SDImageLoaderProgressBlock</code> , 重置 <code>NSProgress</code>、<code>SDWebImageIndicator</code>;</li>
<li>开启下载<code>loadImageWithURL:</code> 并将返回的 <code>SDWebImageOperation</code> 存入 <code>sd_operationDictionary</code>，key 为 <code>validOperationKey</code>;</li>
<li>取到图片后，调用 <code>sd_setImage:</code> 同时为新的 image 添加 Transition 过渡动画；</li>
<li>动画结束后停止 indicator。</li>
</ol>
<p>稍微说明的是 <code>SDWebImageOperation</code>它是一个 **strong - weak **的 NSMapTable，也是通过关联值添加的：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// key is strong, value is weak because operation instance is retained by SDWebImageManager&#39;s runningOperations property
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75">// we should use lock to keep thread-safe because these method may not be acessed from main queue
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"></span><span style="color:#719e07">typedef</span> NSMapTable<span style="color:#719e07">&lt;</span>NSString <span style="color:#719e07">*</span>, <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;&gt;</span> SDOperationsDictionary;
</code></pre></div><p>用 weak 是因为 operation 实例是保存在 SDWebImageManager 的 runningOperations，这里只是保存了引用，以方便 cancel 。</p>
<h3 id="sdwebimagecontext">SDWebImageContext</h3>
<blockquote>
<p>A SDWebImageContext object which hold the original context options from top-level API.</p>
</blockquote>
<p>image context 贯穿图片处理的整个流程，它将数据逐级带入各个处理任务中，存在两种类型的 ImageContext:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objectivec" data-lang="objectivec"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">typedef</span> NSString <span style="color:#719e07">*</span> SDWebImageContextOption NS_EXTENSIBLE_STRING_ENUM;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">typedef</span> NSDictionary<span style="color:#719e07">&lt;</span>SDWebImageContextOption, <span style="color:#dc322f">id</span><span style="color:#719e07">&gt;</span> SDWebImageContext;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">typedef</span> NSMutableDictionary<span style="color:#719e07">&lt;</span>SDWebImageContextOption, <span style="color:#dc322f">id</span><span style="color:#719e07">&gt;</span>SDWebImageMutableContext;
</code></pre></div><p>SDWebImageContextOption 是一个可扩展的 String 枚举，目前有 15 种类型。基本上，你只需看名字也能猜出个大概，<a href="https://github.com/SDWebImage/SDWebImage/blob/5c3c40288f7e465ba94db9736e624f663831951a/SDWebImage/Core/SDWebImageDefine.h">文档</a>，简单做了如下分类：</p>
<p><img src="http://ww1.sinaimg.cn/large/8157560cgy1gcbeto2gb6j20xj1whajv.jpg" alt="image context"></p>
<p>从其参与度来看，可见其重要性。</p>
<h2 id="imageprefetcher">ImagePrefetcher</h2>
<p>Prefetcher 它与 SD 整个处理流关系不大，主要用 imageManger 进行图片批量下载，核心方法如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (nullable SDWebImagePrefetchToken <span style="color:#719e07">*</span>)<span style="color:#268bd2">prefetchURLs:</span>(nullable NSArray<span style="color:#719e07">&lt;</span>NSURL <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>)<span style="color:#268bd2">urls</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>                                          <span style="color:#268bd2">progress:</span>(nullable SDWebImagePrefetcherProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>                                         <span style="color:#268bd2">completed:</span>(nullable SDWebImagePrefetcherCompletionBlock)<span style="color:#268bd2">completionBlock</span>;
</code></pre></div><p>它将下载的 URLs 作为 <code>事务</code> 存入 <code>SDWebImagePrefetchToken</code> 中，避免之前版本在每次 <code>prefetchURLs:</code> 时将上一次的 fetching 操作 cancel 的问题。</p>
<p>每个下载任务都是在 autoreleasesepool 环境下，且会用 <code>SDAsyncBlockOperation</code> 来包装真正的下载任务，来达到任务的可取消操作：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    @weakify(<span style="color:#b58900">self</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    SDAsyncBlockOperation <span style="color:#719e07">*</span>prefetchOperation <span style="color:#719e07">=</span> [SDAsyncBlockOperation blockOperationWithBlock:<span style="color:#719e07">^</span>(SDAsyncBlockOperation <span style="color:#719e07">*</span> _Nonnull asyncOperation) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        @strongify(<span style="color:#b58900">self</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span><span style="color:#b58900">self</span> <span style="color:#719e07">||</span> asyncOperation.isCancelled) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>            <span style="color:#719e07">return</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        <span style="color:#586e75">/// load Image ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75"></span>    }];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">@synchronized</span> (token) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        [token.prefetchOperations addPointer:(<span style="color:#719e07">__bridge</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>)prefetchOperation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    [<span style="color:#b58900">self</span>.prefetchQueue addOperation:prefetchOperation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>}
</code></pre></div><p>最后将任务存入 prefetchQueue，其最大限制下载数默认为 3 。而 URLs 下载的真正任务是放在 <code>token.loadOperations</code>:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSPointerArray <span style="color:#719e07">*</span>operations <span style="color:#719e07">=</span> token.loadOperations;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span> operation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.manager loadImageWithURL:url options:<span style="color:#b58900">self</span>.options context:<span style="color:#b58900">self</span>.context progress:<span style="color:#b58900">nil</span> completed:<span style="color:#719e07">^</span>(UIImage <span style="color:#719e07">*</span> _Nullable image, NSData <span style="color:#719e07">*</span> _Nullable data, NSError <span style="color:#719e07">*</span> _Nullable error, SDImageCacheType cacheType, <span style="color:#dc322f">BOOL</span> finished, NSURL <span style="color:#719e07">*</span> _Nullable imageURL) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">/// progress handler    
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>}];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>NSAssert(operation <span style="color:#719e07">!=</span> <span style="color:#b58900">nil</span>, <span style="color:#2aa198">@&#34;Operation should not be nil, [SDWebImageManager loadImageWithURL:options:context:progress:completed:] break prefetch logic&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@synchronized</span> (token) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    [operations addPointer:(<span style="color:#719e07">__bridge</span> <span style="color:#dc322f">void</span> <span style="color:#719e07">*</span>)operation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p><code>loadOperations</code> 与 <code>prefetchOperations</code> 均使用 <strong>NSPointerArray</strong> ，这里用到了其 <a href="apple-reference-documentation://hcx77yk4jV"><code>NSPointerFunctionsWeakMemory</code></a> 特性以及可以存储 <code>Null</code> 值，尽管其性能并不是很好，参见：<a href="https://objccn.io/issue-7-1/">基础集合类</a></p>
<p>另外一个值得注意的是 PrefetchToken 对下载状态的线程安全管理，使用了 <a href="https://zhuanlan.zhihu.com/p/45566448">c++11 memory_order_relaxed</a> 。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>atomic_ulong _skippedCount;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>atomic_ulong _finishedCount;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>atomic_flag  _isAllFinished;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#dc322f">unsigned</span> <span style="color:#dc322f">long</span> _totalCount;
</code></pre></div><p>即通过内存顺序和原子操作做到无锁并发，从而提高效率。具体原理感兴趣的同学可以自行查阅资料。</p>
<h2 id="imageloader">ImageLoader</h2>
<p>SDWebImageDownloader 是 &lt;SDImageLoader&gt; 协议在 SD 内部的默认实现。它提供了 HTTP/HTTPS/FTP 或者 local URL 的 NSURLSession 来源的图片获取能力。同时它最大程度的开放整个下载过程的的可配置性。主要 properties ：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">SDWebImageDownloader</span> : <span style="color:#268bd2">NSObject</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">copy</span>, <span style="color:#719e07">readonly</span>, nonnull) SDWebImageDownloaderConfig <span style="color:#719e07">*</span>config;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderRequestModifier<span style="color:#719e07">&gt;</span> requestModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderResponseModifier<span style="color:#719e07">&gt;</span> responseModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderDecryptor<span style="color:#719e07">&gt;</span> decryptor;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75">/* ... */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>-(nullable SDWebImageDownloadToken <span style="color:#719e07">*</span>)<span style="color:#268bd2">downloadImageWithURL:</span>(nullable NSURL <span style="color:#719e07">*</span>)<span style="color:#268bd2">url</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#268bd2">options:</span>(SDWebImageDownloaderOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>   <span style="color:#268bd2">progress:</span>(nullable SDWebImageDownloaderProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>  <span style="color:#268bd2">completed:</span>(nullable SDWebImageDownloaderCompletedBlock)<span style="color:#268bd2">completedBlock</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#719e07">@end</span>
</code></pre></div><p>其中 downloaderConfig 是支持 NSCopy 协议的，提供的主要配置如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">/// Defaults to 6.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>) NSInteger maxConcurrentDownloads;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75">/// Defaults to 15.0s.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>) NSTimeInterval downloadTimeout;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75">/// custom session configuration，不支持在使用过程中动态替换类型； 
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) NSURLSessionConfiguration <span style="color:#719e07">*</span>sessionConfiguration;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75">/// 动态扩展类，需要遵循 `NSOperation&lt;SDWebImageDownloaderOperation&gt;` 以实现 SDImageLoader 定制
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>, nullable) <span style="color:#dc322f">Class</span> operationClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#586e75">/// 图片下载顺序，默认 FIFO
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">assign</span>) SDWebImageDownloaderExecutionOrder executionOrder;
</code></pre></div><p>request modifier，提供在下载前修改 request，</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// Modify the original URL request and return a new one instead. You can modify the HTTP header, cachePolicy, etc for this URL.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">SDWebImageDownloaderRequestModifier</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">-</span> (nullable NSURLRequest <span style="color:#719e07">*</span>)modifiedRequestWithRequest:(nonnull NSURLRequest <span style="color:#719e07">*</span>)request;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">@end</span>
</code></pre></div><p>同样，response modifier 则提供对返回值的修改，</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// Modify the original URL response and return a new response. You can use this to check MIME-Type, mock server response, etc.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">SDWebImageDownloaderResponseModifier</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">-</span> (nullable NSURLResponse <span style="color:#719e07">*</span>)modifiedResponseWithResponse:(nonnull NSURLResponse <span style="color:#719e07">*</span>)response;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07">@end</span>
</code></pre></div><p>最后一个 decryptor 用于图片解密，默认提供了对 imageData 的 base64 转换，</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// Decrypt the original download data and return a new data. You can use this to decrypt the data using your perfereed algorithm.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#719e07">@protocol</span> <span style="color:#268bd2">SDWebImageDownloaderDecryptor</span> <span style="color:#719e07">&lt;</span>NSObject<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">-</span> (nullable NSData <span style="color:#719e07">*</span>)decryptedDataWithData:(nonnull NSData <span style="color:#719e07">*</span>)data response:(nullable NSURLResponse <span style="color:#719e07">*</span>)response;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@end</span>
</code></pre></div><p>通过这个协议化后的对象来处理数据，可以说是利用了设计模式中的 <strong>策略模式</strong> 或者 <strong>依赖注入</strong>。通过配置的方式获取到协议对象，调用方仅需关心协议对象提供的方法，无需在意其内部实现，达到解耦的目的。</p>
<p>###DownloadImageWithURL</p>
<p>下载前先检查 URL 是否存在，没有则直接抛错返回。取到 URL 后尝试复用之前生成的 operation：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>NSOperation<span style="color:#719e07">&lt;</span>SDWebImageDownloaderOperation<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>operation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.URLOperations objectForKey:url];
</code></pre></div><p>如果 operation 存在，调用</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@synchronized</span> (operation) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    downloadOperationCancelToken <span style="color:#719e07">=</span> [operation addHandlersForProgress:progressBlock completed:completedBlock];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>并设置  queuePriority。这里用了 @synchronized(operation) ，同时 Operation 内部则会用 @synchronized(self)，以保证两个不同类间 operation 的线程安全，因为 operation 有可能被传递到解码或代理的队列中。这里 <code>addHandlersForProgress：</code> 会将 progressBlock 与 completedBlock 一起存入 <code>NSMutableDictionary&lt;NSString *, id&gt; SDCallbacksDictionary</code> 然后返回保存在 downloadOperationCancelToken 中。</p>
<p>另外，Operation 在 <code>addHandlersForProgress:</code> 时并不会清除之前存储的 callbacks 是增量保存的，也就是说多次调用的 callBack 在完成后都会被依次执行。</p>
<p>如果 operation 不存在、任务被取消、任务已完成，调用 <code>createDownloaderOperationWithUrl:options:context:</code> 创建出新的 operation 并存储在 URLOperations 中 。同时会配置 completionBlock，使得任务完成后可以及时清理 URLOperations。保存 progressBlock 和 completedBlock；提交 operation 到 downloadQueue。</p>
<p>最终 operation、url、request、downloadOperationCancelToken 一起被打包进 SDWebImageDownloadToken， 下载方法结束。</p>
<p>###CreateDownloaderOperation</p>
<p>下载结束，我们来聊聊 operation 是如何创建的。首先是生成 URLRequest：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>NSURLRequestCachePolicy cachePolicy <span style="color:#719e07">=</span> options <span style="color:#719e07">&amp;</span> SDWebImageDownloaderUseNSURLCache <span style="color:#719e07">?</span> NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>NSMutableURLRequest <span style="color:#719e07">*</span>mutableRequest <span style="color:#719e07">=</span> [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>mutableRequest.HTTPShouldHandleCookies <span style="color:#719e07">=</span> SD_OPTIONS_CONTAINS(options, SDWebImageDownloaderHandleCookies);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>mutableRequest.HTTPShouldUsePipelining <span style="color:#719e07">=</span> <span style="color:#b58900">YES</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>SD_LOCK(<span style="color:#b58900">self</span>.HTTPHeadersLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>mutableRequest.allHTTPHeaderFields <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>.HTTPHeaders;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>SD_UNLOCK(<span style="color:#b58900">self</span>.HTTPHeadersLock);
</code></pre></div><p>主要通过 SDWebImageDownloaderOptions 获取参数来配置， timeout 是由 downloader 的 config.downloadTimeout 决定，默认为 15s。然后从 imageContext 中取出 <code>id&lt;SDWebImageDownloaderRequestModifier&gt; requestModifier</code> 对 request 进行改造。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Request Modifier
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderRequestModifier<span style="color:#719e07">&gt;</span> requestModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">if</span> ([context valueForKey:SDWebImageContextDownloadRequestModifier]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    requestModifier <span style="color:#719e07">=</span> [context valueForKey:SDWebImageContextDownloadRequestModifier];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>    requestModifier <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>.requestModifier;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>}
</code></pre></div><p>值得注意的是 requestModifier 的获取是有<strong>优先级</strong>的，通过 imageContext 得到的优先级高于 downloader 所拥有的。通过这种方既满足了接口调用方可控，又能支持全局配置，可谓老少皆宜。同理，<code>id&lt;SDWebImageDownloaderResponseModifier&gt; responseModifier</code> 、<code>id&lt;SDWebImageDownloaderDecryptor&gt; decryptor</code> 也是如此。</p>
<p>之后会将确认过的 responseModifier 和 decryptor 再次保存到 imageContext 中为之后使用。</p>
<p>最后，从 downloaderConfig 中取出 operationClass 创建 operation：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">Class</span> operationClass <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>.config.operationClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">if</span> (operationClass <span style="color:#719e07">&amp;&amp;</span> [operationClass isSubclassOfClass:[NSOperation <span style="color:#719e07">class</span>]] <span style="color:#719e07">&amp;&amp;</span> [operationClass conformsToProtocol:@protocol(SDWebImageDownloaderOperation)]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">// Custom operation class
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>} <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    operationClass <span style="color:#719e07">=</span> [SDWebImageDownloaderOperation <span style="color:#719e07">class</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>NSOperation<span style="color:#719e07">&lt;</span>SDWebImageDownloaderOperation<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>operation <span style="color:#719e07">=</span> [[operationClass alloc] initWithRequest:request inSession:<span style="color:#b58900">self</span>.session options:options context:context];
</code></pre></div><p>设置其 credential、minimumProgressInterval、queuePriority、pendingOperation。</p>
<p>默认情况下，每个任务是按照 FIFO 顺序添加到 downloadQueue 中，如果用户设置的是 LIFO 时，添加进队列前会修改队列中现有任务的优先级来达到效果：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (<span style="color:#b58900">self</span>.config.executionOrder <span style="color:#719e07">==</span> SDWebImageDownloaderLIFOExecutionOrder) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    <span style="color:#586e75">// Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"></span>    <span style="color:#586e75">// This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>    <span style="color:#586e75">// Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#586e75"></span>    <span style="color:#719e07">for</span> (NSOperation <span style="color:#719e07">*</span>pendingOperation <span style="color:#719e07">in</span> <span style="color:#b58900">self</span>.downloadQueue.operations) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        [pendingOperation addDependency:operation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p>通过遍历队列，将新任务修改为当前队列中所有任务的依赖以反转优先级。</p>
<h3 id="数据处理">数据处理</h3>
<p>SDWebImageDownloaderOperation 也是协议化后的类型，协议本身遵循 NSURLSessionTaskDelegate, NSURLSessionDataDelegate，它是真正处理 URL 请求数据的类，支持后台下载，支持对 responseData 修改(by responseModifier)，支持对 download ImageData 进行解密 (by decryptor)。其主要内部 properties 如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readwrite</span>) SDWebImageDownloaderOptions options;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">copy</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readwrite</span>, nullable) SDWebImageContext <span style="color:#719e07">*</span>context;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nonnull) NSMutableArray<span style="color:#719e07">&lt;</span>SDCallbacksDictionary <span style="color:#719e07">*&gt;</span> <span style="color:#719e07">*</span>callbackBlocks;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSMutableData <span style="color:#719e07">*</span>imageData;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">copy</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSData <span style="color:#719e07">*</span>cachedData; <span style="color:#586e75">// for `SDWebImageDownloaderIgnoreCachedResponse`
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger expectedSize; <span style="color:#586e75">// may be 0
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger receivedSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderResponseModifier<span style="color:#719e07">&gt;</span> responseModifier; <span style="color:#586e75">// modifiy original URLResponse
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageDownloaderDecryptor<span style="color:#719e07">&gt;</span> decryptor; <span style="color:#586e75">// decrypt image data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75">// This is weak because it is injected by whoever manages this session. If this gets nil-ed out, we won&#39;t be able to run
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75">// the task associated with this operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">weak</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSURLSession <span style="color:#719e07">*</span>unownedSession;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75">// This is set if we&#39;re using not using an injected NSURLSession. We&#39;re responsible of invalidating this one
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) NSURLSession <span style="color:#719e07">*</span>ownedSession;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nonnull) dispatch_queue_t coderQueue; <span style="color:#586e75">// the queue to do image decoding
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span><span style="color:#586e75"></span><span style="color:#719e07">#if SD_UIKIT
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span><span style="color:#719e07"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) UIBackgroundTaskIdentifier backgroundTaskId;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>- (nonnull <span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithRequest:</span>(nullable NSURLRequest <span style="color:#719e07">*</span>)<span style="color:#268bd2">request</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span>                              <span style="color:#268bd2">inSession:</span>(nullable NSURLSession <span style="color:#719e07">*</span>)<span style="color:#268bd2">session</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>                                <span style="color:#268bd2">options:</span>(SDWebImageDownloaderOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>                                <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>;
</code></pre></div><p>初始化没有什么特别的，需要注意的是这里传入的 <code>nullable session</code> 是以 unownedSessin 保存，区别于内部默认生成的 <strong>ownedSession</strong>。如果初始化时 session 为空，会在 <code>start</code> 时创建 ownedSession。</p>
<p>那么问题来了，由于我们需观察 session 的各个状态，需要设置 delegate 来完成，</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>[NSURLSession sessionWithConfiguration:delegate:delegateQueue:];
</code></pre></div><p>ownedSession 的 delegate 毋庸置疑就在 operation 内部，而初始化传入 session 的 delegate 则是 downloader 。它会通过 taskID 取出 operation 调用对应实现来完成回调的统一处理和转发，例如：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">URLSession:</span>(NSURLSession <span style="color:#719e07">*</span>)<span style="color:#268bd2">session</span> <span style="color:#268bd2">task:</span>(NSURLSessionTask <span style="color:#719e07">*</span>)<span style="color:#268bd2">task</span> <span style="color:#268bd2">didCompleteWithError:</span>(NSError <span style="color:#719e07">*</span>)<span style="color:#268bd2">error</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    <span style="color:#586e75">// Identify the operation that runs this task and pass it the delegate method
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>    NSOperation<span style="color:#719e07">&lt;</span>SDWebImageDownloaderOperation<span style="color:#719e07">&gt;</span> <span style="color:#719e07">*</span>dataOperation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> operationWithTask:task];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    <span style="color:#719e07">if</span> ([dataOperation respondsToSelector:<span style="color:#719e07">@selector</span>(URLSession:task:didCompleteWithError:)]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        [dataOperation URLSession:session task:task didCompleteWithError:error];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span>}
</code></pre></div><p>接着作为真正的消费者 operation 开始下载任务，整个下载过程包括开始、结束、取消都会发送对应通知。</p>
<ol>
<li>
<p>在 <strong>didReceiveResponse</strong> 时，会保存 response.expectedContentLength 作为 expectedSize。然后调用 <code>modifiedResponseWithResponse:</code> 保存编辑后的 reponse。</p>
</li>
<li>
<p>每次 <strong>didReceiveData</strong> 会将 data 追加到 imageData：<code>[self.imageData appendData:data]</code> ，更新 receivedSize<code>self.receivedSize = self.imageData.length</code> 。最终，当 receivedSize &gt; expectedSize 判定下载完成，执行后续处理。如果你支持了 <code>SDWebImageDownloaderProgressiveLoad</code>，每当收到数据时，将会进入 coderQueue 进行边下载边解码:</p>
</li>
</ol>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#586e75">// progressive decode the image in coder queue
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#586e75"></span>dispatch_async(<span style="color:#b58900">self</span>.coderQueue, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        UIImage <span style="color:#719e07">*</span>image <span style="color:#719e07">=</span> SDImageLoaderDecodeProgressiveImageData(imageData, <span style="color:#b58900">self</span>.request.URL, finished, <span style="color:#b58900">self</span>, [[<span style="color:#b58900">self</span> <span style="color:#719e07">class</span>] imageOptionsFromDownloaderOptions:<span style="color:#b58900">self</span>.options], <span style="color:#b58900">self</span>.context);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>        <span style="color:#719e07">if</span> (image) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>            <span style="color:#586e75">// We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span>            
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>            [<span style="color:#b58900">self</span> callCompletionBlocksWithImage:image imageData:<span style="color:#b58900">nil</span> error:<span style="color:#b58900">nil</span> finished:<span style="color:#b58900">NO</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>});
</code></pre></div><p>​		否则，会在 <strong>didCompleteWithError</strong> 时完成解码操作：<code>SDImageLoaderDecodeImageData</code> ，不过在解码前需要先解密:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">if</span> (imageData <span style="color:#719e07">&amp;&amp;</span> <span style="color:#b58900">self</span>.decryptor) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    imageData <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.decryptor decryptedDataWithData:imageData response:<span style="color:#b58900">self</span>.response];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>}
</code></pre></div><p>​	3. 处理 complete 回调；</p>
<p>关于 decode 的逻辑我们最后聊。</p>
<h2 id="imagecache">ImageCache</h2>
<p>基本上 Cache 相关类的设计思路与 ImageLoader 一致，会有一份 <strong>SDImageCacheConfig</strong> 以配置缓存的过期时间，容量大小，读写权限，以及动态可扩展的 MemoryCache/DiskCache。</p>
<p>SDImageCacheConfig 主要属性如下:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldDisableiCloud;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldCacheImagesInMemory;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldUseWeakMemoryCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) <span style="color:#dc322f">BOOL</span> shouldRemoveExpiredDataWhenEnterBackground;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSDataReadingOptions diskCacheReadingOptions;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSDataWritingOptions diskCacheWritingOptions;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSTimeInterval maxDiskAge;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger maxDiskSize;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger maxMemoryCost;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) NSUInteger maxMemoryCount;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>) SDImageCacheConfigExpireType diskCacheExpireType;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#586e75">/// Defaults to built-in `SDMemoryCache` class.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span>, <span style="color:#719e07">nonatomic</span>, nonnull) <span style="color:#dc322f">Class</span> memoryCacheClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#586e75">/// Defaults to built-in `SDDiskCache` class.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">assign</span> ,<span style="color:#719e07">nonatomic</span>, nonnull) <span style="color:#dc322f">Class</span> diskCacheClass;
</code></pre></div><p>MemoryCache、DiskCache 的实例化都需要 SDImageCacheConfig 的传入：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/// SDMemoryCache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>- (nonnull <span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithConfig:</span>(nonnull SDImageCacheConfig <span style="color:#719e07">*</span>)<span style="color:#268bd2">config</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75">/// SDDiskCache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>- (nullable <span style="color:#dc322f">instancetype</span>)<span style="color:#268bd2">initWithCachePath:</span>(nonnull NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">cachePath</span> <span style="color:#268bd2">config:</span>(nonnull SDImageCacheConfig <span style="color:#719e07">*</span>)<span style="color:#268bd2">config</span>;
</code></pre></div><p>作为缓存协议，他们的接口声明基本一致，都是对数据的 CURD，区别在于 MemoryCache Protocl 操作的是 <strong>id</strong> 类型 (NSCache API 限制)，DiskCache 则是对 NSData。</p>
<p>我们来看看他们的默认实现吧。</p>
<h3 id="sdmemorycache">SDMemoryCache</h3>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">/**
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"> A memory cache which auto purge the cache on memory warning and support weak cache.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"> */</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">SDMemoryCache</span> <span style="color:#719e07">&lt;</span>KeyType, ObjectType<span style="color:#719e07">&gt;</span> <span style="color:#719e07">:</span> NSCache <span style="color:#719e07">&lt;</span>KeyType, ObjectType<span style="color:#719e07">&gt;</span> <span style="color:#719e07">&lt;</span>SDMemoryCache<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nonnull, <span style="color:#719e07">readonly</span>) SDImageCacheConfig <span style="color:#719e07">*</span>config;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">@end</span>
</code></pre></div><p>内部就是将 <strong>NSCache</strong> 扩展为了 SDMemoryCache 协议，并加入了 *<em>NSMapTable&lt;KeyType, ObjectType&gt; <em>weakCache</em></em> ，并为其添加了信号量锁来保证线程安全。这里的 weak-cache 是仅在 <em>iOS/tvOS</em> 平台添加的特性，因为在 macOS 上尽管收到系统内存警告，NSCache 也不会清理对应的缓存。weakCache 使用的是 strong-weak 引用不会有有额外的内存开销且不影响对象的生命周期。</p>
<p>weakCache 的作用在于恢复缓存，它通过 CacheConfig 的 <strong>shouldUseWeakMemoryCache</strong> 开关以控制，详细说明可以查看 <a href="https://github.com/SDWebImage/SDWebImage/blob/master/SDWebImage/Core/SDImageCacheConfig.h">CacheConfig.h</a>。先看看其如何实现的：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>- (<span style="color:#dc322f">id</span>)<span style="color:#268bd2">objectForKey:</span>(<span style="color:#dc322f">id</span>)<span style="color:#268bd2">key</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#dc322f">id</span> obj <span style="color:#719e07">=</span> [<span style="color:#b58900">super</span> objectForKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span><span style="color:#b58900">self</span>.config.shouldUseWeakMemoryCache) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">return</span> obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">if</span> (key <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">!</span>obj) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        <span style="color:#586e75">// Check weak cache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span>        SD_LOCK(<span style="color:#b58900">self</span>.weakCacheLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        obj <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.weakCache objectForKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>        SD_UNLOCK(<span style="color:#b58900">self</span>.weakCacheLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        <span style="color:#719e07">if</span> (obj) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            <span style="color:#586e75">// Sync cache
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span><span style="color:#586e75"></span>            NSUInteger cost <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            <span style="color:#719e07">if</span> ([obj isKindOfClass:[UIImage <span style="color:#719e07">class</span>]]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                cost <span style="color:#719e07">=</span> [(UIImage <span style="color:#719e07">*</span>)obj sd_memoryCost];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            [<span style="color:#b58900">super</span> setObject:obj forKey:key cost:cost];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>    <span style="color:#719e07">return</span> obj;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>}
</code></pre></div><p>由于 NSCache 遵循  <a href="apple-reference-documentation://hcnVx1bA-q"><code>NSDiscardableContent</code></a>  策略来存储临时对象的，当内存紧张时，缓存对象有可能被系统清理掉。此时，如果应用访问 MemoryCache 时，缓存一旦未命中，则会转入 diskCache 的查询操作，可能导致 image 闪烁现象。而当开启 shouldUseWeakMemoryCache 时，因为 weakCache 保存着对象的弱引用 （在对象 被 NSCache 被清理且没有被释放的情况下)，我们可通过 weakCache 取到缓存，将其塞会 NSCache 中。从而减少磁盘 I/O。</p>
<h3 id="sddiskcache">SDDiskCache</h3>
<p>这个更简单，内部使用 NSFileManager 管理图片数据读写， 调用 SDDiskCacheFileNameForKey 将 key MD5 处理后作为 fileName，存放在 diskCachePath 目录下。另外就是过期缓存的清理：</p>
<ol>
<li>根据 SDImageCacheConfigExpireType 排序得到 <code>NSDirectoryEnumerator *fileEnumerator</code> ，开始过滤；</li>
<li>以 cacheConfig.maxDiskAage 对比判断是否过期，将过期 URL 存入 urlsToDelete；</li>
<li>调用 <code>[self.fileManager removeItemAtURL:fileURL error:nil];</code></li>
<li>根据 cacheConfig.maxDiskSize 来删除磁盘缓存的数据，清理到 maxDiskSize 的 1/2 为止。</li>
</ol>
<p>另外一点就是 SDDiskCache 同 <strong><a href="https://github.com/ibireme/YYCache/blob/master/YYCache/YYKVStorage.h">YYKVStorage</a></strong> 一样同样支持为 UIImage 添加 extendData 用以存储额外信息，例如，图片的缩放比例, <a href="https://sspai.com/post/55279">URL rich link</a>, 时间等其他数据。</p>
<p>不过 <strong>YYKVStorage</strong> 本身是用数据库中 <em><strong>manifest</strong></em> 表的 extended_data 字段来存储的。SDDiskCache 就另辟蹊径解决了。利用系统 API &lt;sys/xattr.h&gt; 的 <strong>setxattr</strong>、<strong>getxattr</strong>、<strong>listxattr</strong> 将 extendData 保存。可以说又涨姿势了。顺便说一下，它对应的 key 是用 <em>SDDiskCacheExtendedAttributeName</em>。</p>
<h3 id="sdimagecache">SDImageCache</h3>
<p>也是协议化后的类，负责调度 SDMemoryCache、SDDiskCache，其 Properties 如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, <span style="color:#719e07">readwrite</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDMemoryCache<span style="color:#719e07">&gt;</span> memoryCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, <span style="color:#719e07">readwrite</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDDiskCache<span style="color:#719e07">&gt;</span> diskCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">copy</span>, <span style="color:#719e07">readwrite</span>, nonnull) SDImageCacheConfig <span style="color:#719e07">*</span>config;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">copy</span>, <span style="color:#719e07">readwrite</span>, nonnull) NSString <span style="color:#719e07">*</span>diskCachePath;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) dispatch_queue_t ioQueue;
</code></pre></div><blockquote>
<p>说明：memoryCache 和  diskCache 实例是依据 CacheConfig 中定义的 class 来生成的，默认为 SDMemoryCache 和 SDDiskCache。</p>
</blockquote>
<p>我们看看其核心方法：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">storeImage:</span>(nullable UIImage <span style="color:#719e07">*</span>)<span style="color:#268bd2">image</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>         <span style="color:#268bd2">imageData:</span>(nullable NSData <span style="color:#719e07">*</span>)<span style="color:#268bd2">imageData</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>            <span style="color:#268bd2">forKey:</span>(nullable NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">key</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>          <span style="color:#268bd2">toMemory:</span>(<span style="color:#dc322f">BOOL</span>)<span style="color:#268bd2">toMemory</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>            <span style="color:#268bd2">toDisk:</span>(<span style="color:#dc322f">BOOL</span>)<span style="color:#268bd2">toDisk</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>        <span style="color:#268bd2">completion:</span>(nullable SDWebImageNoParamsBlock)<span style="color:#268bd2">completionBlock</span>;
</code></pre></div><ol>
<li>
<p>确保 image 和 key 存在；</p>
</li>
<li>
<p>当 <em>shouldCacheImagesInMemory</em> 为 YES，则会调用 <code>[self.memoryCache setObject:image forKey:key cost:cost]</code> 进行 memoryCache 写入；</p>
</li>
<li>
<p>进行 diskCache 写入，操作逻辑放入 ioQueue 和 autoreleasepool 中。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_async(<span style="color:#b58900">self</span>.ioQueue, <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        NSData <span style="color:#719e07">*</span>data <span style="color:#719e07">=</span> ... <span style="color:#586e75">// 根据 SDImageFormat 对 image 进行编码获取
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>        <span style="color:#586e75">/// data = [[SDImageCodersManager sharedManager] encodedDataWithImage:image format:format options:nil];
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"></span>        [<span style="color:#b58900">self</span> _storeImageDataToDisk:data forKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        <span style="color:#719e07">if</span> (image) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>            <span style="color:#586e75">// Check extended data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#586e75"></span>            <span style="color:#dc322f">id</span> extendedObject <span style="color:#719e07">=</span> image.sd_extendedObject;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>            <span style="color:#586e75">// ... get extended data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span><span style="color:#586e75"></span>            [<span style="color:#b58900">self</span>.diskCache setExtendedData:extendedData forKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    <span style="color:#586e75">// call completionBlock in main queue
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span><span style="color:#586e75"></span>});
</code></pre></div></li>
</ol>
<p>另一个重要的方法就是 image query，定义在 SDImageCache 协议中：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>- (<span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span>)<span style="color:#268bd2">queryImageForKey:</span>(NSString <span style="color:#719e07">*</span>)<span style="color:#268bd2">key</span> <span style="color:#268bd2">options:</span>(SDWebImageOptions)<span style="color:#268bd2">options</span> <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span> <span style="color:#268bd2">completion:</span>(nullable SDImageCacheQueryCompletionBlock)<span style="color:#268bd2">completionBlock</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    SDImageCacheOptions cacheOptions <span style="color:#719e07">=</span> <span style="color:#2aa198">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageQueryMemoryData) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheQueryMemoryData;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageQueryMemoryDataSync) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheQueryMemoryDataSync;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageQueryDiskDataSync) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheQueryDiskDataSync;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageScaleDownLargeImages) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheScaleDownLargeImages;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageAvoidDecodeImage) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheAvoidDecodeImage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageDecodeFirstFrameOnly) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheDecodeFirstFrameOnly;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImagePreloadAllFrames) cacheOptions <span style="color:#719e07">|=</span> SDImageCachePreloadAllFrames;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>    <span style="color:#719e07">if</span> (options <span style="color:#719e07">&amp;</span> SDWebImageMatchAnimatedImageClass) cacheOptions <span style="color:#719e07">|=</span> SDImageCacheMatchAnimatedImageClass;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>    <span style="color:#719e07">return</span> [<span style="color:#b58900">self</span> queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>}
</code></pre></div><p>它只做了一件事情，将 SDWebImageOptions 转换为 SDImageCacheOptions，然后调用 <code>queryCacheOperationForKey:</code> ，其内部逻辑如下：</p>
<p>首先，如果 query key 存在，会从 imageContext 中获取 transformer，对 query key 进行转换:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>key <span style="color:#719e07">=</span> SDTransformedKeyForKey(key, transformerKey);
</code></pre></div><p>尝试从 memory cache 获取 image，如果存在：</p>
<ol>
<li>
<p>满足 SDImageCacheDecodeFirstFrameOnly 且遵循 SDAnimatedImage 协议，则会取出 CGImage 进行转换</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Ensure static image
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">Class</span> animatedImageClass <span style="color:#719e07">=</span> image.<span style="color:#719e07">class</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#719e07">if</span> (image.sd_isAnimated <span style="color:#719e07">||</span> ([animatedImageClass isSubclassOfClass:[UIImage <span style="color:#719e07">class</span>]] <span style="color:#719e07">&amp;&amp;</span> [animatedImageClass conformsToProtocol:@protocol(SDAnimatedImage)])) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">#if SD_MAC
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#719e07"></span>    image <span style="color:#719e07">=</span> [[NSImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:kCGImagePropertyOrientationUp];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#719e07">#else
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#719e07"></span>    image <span style="color:#719e07">=</span> [[UIImage alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">#endif
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">9</span><span style="color:#719e07"></span>}
</code></pre></div></li>
<li>
<p>满足 SDImageCacheMatchAnimatedImageClass ，则会强制检查 image 类型是否匹配，否则将数据至 nil:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Check image class matching
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span><span style="color:#dc322f">Class</span> animatedImageClass <span style="color:#719e07">=</span> image.<span style="color:#719e07">class</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#dc322f">Class</span> desiredImageClass <span style="color:#719e07">=</span> context[SDWebImageContextAnimatedImageClass];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#719e07">if</span> (desiredImageClass <span style="color:#719e07">&amp;&amp;</span> <span style="color:#719e07">!</span>[animatedImageClass isSubclassOfClass:desiredImageClass]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>    image <span style="color:#719e07">=</span> <span style="color:#b58900">nil</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span>}
</code></pre></div></li>
</ol>
<p>当可以从 memory cache 获取到 image 且为 SDImageCacheQueryMemoryData，直接完成返回，否则继续；</p>
<p>开始 diskCache 读取，依据读取条件判定 I/O 操作是否为同步。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// Check whether we need to synchronously query disk
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75">// 1. in-memory cache hit &amp; memoryDataSync
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75">// 2. in-memory cache miss &amp; diskDataSync
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span><span style="color:#dc322f">BOOL</span> shouldQueryDiskSync <span style="color:#719e07">=</span> ((image <span style="color:#719e07">&amp;&amp;</span> options <span style="color:#719e07">&amp;</span> SDImageCacheQueryMemoryDataSync) <span style="color:#719e07">||</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>                            (<span style="color:#719e07">!</span>image <span style="color:#719e07">&amp;&amp;</span> options <span style="color:#719e07">&amp;</span> SDImageCacheQueryDiskDataSync));
</code></pre></div><p>整个 diskQuery 存在 queryDiskBlock 中并用 autorelease 包裹：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#dc322f">void</span>(<span style="color:#719e07">^</span>queryDiskBlock)(<span style="color:#dc322f">void</span>) <span style="color:#719e07">=</span>  <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">if</span> (operation.isCancelled) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        <span style="color:#586e75">// call doneBlock &amp; return
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75"></span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>        NSData <span style="color:#719e07">*</span>diskData <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> diskImageDataBySearchingAllPathsForKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>        UIImage <span style="color:#719e07">*</span>diskImage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        SDImageCacheType cacheType <span style="color:#719e07">=</span> SDImageCacheTypeNone;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>        <span style="color:#719e07">if</span> (image) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>            <span style="color:#586e75">// the image is from in-memory cache, but need image data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>            diskImage <span style="color:#719e07">=</span> image;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>            cacheType <span style="color:#719e07">=</span> SDImageCacheTypeMemory;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>        } <span style="color:#719e07">else</span> <span style="color:#719e07">if</span> (diskData) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>            cacheType <span style="color:#719e07">=</span> SDImageCacheTypeDisk;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>            <span style="color:#586e75">// decode image data only if in-memory cache missed
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span><span style="color:#586e75"></span>            diskImage <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> diskImageForKey:key data:diskData options:options context:context];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>            <span style="color:#719e07">if</span> (diskImage <span style="color:#719e07">&amp;&amp;</span> <span style="color:#b58900">self</span>.config.shouldCacheImagesInMemory) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>                NSUInteger cost <span style="color:#719e07">=</span> diskImage.sd_memoryCost;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>                [<span style="color:#b58900">self</span>.memoryCache setObject:diskImage forKey:key cost:cost];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span>        <span style="color:#586e75">// call doneBlock
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">23</span><span style="color:#586e75"></span>        <span style="color:#719e07">if</span> (doneBlock) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">24</span>            <span style="color:#719e07">if</span> (shouldQueryDiskSync) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">25</span>                doneBlock(diskImage, diskData, cacheType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">26</span>            } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">27</span>                dispatch_async(dispatch_get_main_queue(), <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">28</span>                    doneBlock(diskImage, diskData, cacheType);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">29</span>                });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">30</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">31</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">32</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">33</span>}
</code></pre></div><p>对于大量临时内存操作 SD 都会将其放入 autoreleasepool 以保证内存能及时被释放。</p>
<p>特别强调，代码如果执行到这，就一定会有磁盘读取到操作，因此，如果不是非要获取 imageData 可以通过 <strong>SDImageCacheQueryMemoryData</strong> 来提高查询效率；</p>
<p>最后，<code>SDTransformedKeyForKey</code> 的转换逻辑是以 <strong>SDImageTransformer</strong> 的 transformerKey 按顺序依次拼接在 image key 后面。例如：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>&#39;image.png&#39; <span style="color:#719e07">|&gt;</span> flip(<span style="color:#b58900">YES</span>,<span style="color:#b58900">NO</span>) <span style="color:#719e07">|&gt;</span> rotate(pi<span style="color:#719e07">/</span><span style="color:#2aa198">4</span>,<span style="color:#b58900">YES</span>)  <span style="color:#719e07">=&gt;</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>&#39;image<span style="color:#719e07">-</span>SDImageFlippingTransformer(<span style="color:#2aa198">1</span>,<span style="color:#2aa198">0</span>)<span style="color:#719e07">-</span>SDImageRotationTransformer(<span style="color:#2aa198">0.78539816339</span>,<span style="color:#2aa198">1</span>).png&#39;
</code></pre></div><h2 id="sdimagemanaer">SDImageManaer</h2>
<p>SDImageManger 作为整个库的调度中心，上述各种逻辑的集大成者，它把各个组建串联，从视图 &gt; 下载 &gt; 解码器 &gt; 缓存。而它暴露的核心方法就一个，就是 loadImage:</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageCache<span style="color:#719e07">&gt;</span> imageCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">readonly</span>, nonnull) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageLoader<span style="color:#719e07">&gt;</span> imageLoader;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageTransformer<span style="color:#719e07">&gt;</span> transformer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageCacheKeyFilter<span style="color:#719e07">&gt;</span> cacheKeyFilter;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageCacheSerializer<span style="color:#719e07">&gt;</span> cacheSerializer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">strong</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOptionsProcessor<span style="color:#719e07">&gt;</span> optionsProcessor;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">class</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageCache<span style="color:#719e07">&gt;</span> defaultImageCache;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span><span style="color:#719e07">@property</span> (<span style="color:#719e07">nonatomic</span>, <span style="color:#719e07">class</span>, nullable) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageLoader<span style="color:#719e07">&gt;</span> defaultImageLoader;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>- (nullable SDWebImageCombinedOperation <span style="color:#719e07">*</span>)<span style="color:#268bd2">loadImageWithURL:</span>(nullable NSURL <span style="color:#719e07">*</span>)<span style="color:#268bd2">url</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>                                                   <span style="color:#268bd2">options:</span>(SDWebImageOptions)<span style="color:#268bd2">options</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>                                                   <span style="color:#268bd2">context:</span>(nullable SDWebImageContext <span style="color:#719e07">*</span>)<span style="color:#268bd2">context</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>                                                  <span style="color:#268bd2">progress:</span>(nullable SDImageLoaderProgressBlock)<span style="color:#268bd2">progressBlock</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>                                                 <span style="color:#268bd2">completed:</span>(nonnull SDInternalCompletionBlock)<span style="color:#268bd2">completedBlock</span>;
</code></pre></div><p>这里先简单说一下 cacheKeyFilter、cacheSerializer 和 optionsProcessor 这三个 API，其余的上面都提到过了。</p>
<p><strong>SDWebImageCacheKeyFilter</strong></p>
<p>默认情况下，是把 URL.absoluteString 作为 cacheKey ，而如果设置了 fileter 则会对通过 <code>cacheKeyForURL:</code> 对 cacheKey 拦截并进行修改；</p>
<p><strong>SDWebImageCacheSerializer</strong></p>
<p>默认情况下，ImageCache 会直接将 downloadData 进行缓存，而当我们使用其他图片格式进行传输时，例如 WEBP 格式的，那么磁盘中的存储则会按 WEBP 格式来。这会产生一个问题，每次当我们需要从磁盘读取 image 时都需要进行重复的解码操作。而通过 CacheSerializer 可以直接将 downloadData 转换为 JPEG/PNG 的格式的 NSData 缓存，从而提高访问效率。</p>
<p><strong>SDWebImageOptionsProcessor</strong></p>
<p>用于控制全局的 SDWebImageOptions 和 SDWebImageContext 中的参数。示例如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span> SDWebImageManager.sharedManager.optionsProcessor <span style="color:#719e07">=</span> [SDWebImageOptionsProcessor optionsProcessorWithBlock:<span style="color:#719e07">^</span>SDWebImageOptionsResult <span style="color:#719e07">*</span> _Nullable(NSURL <span style="color:#719e07">*</span> _Nullable url, SDWebImageOptions options, SDWebImageContext <span style="color:#719e07">*</span> _Nullable context) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>     <span style="color:#586e75">// Only do animation on `SDAnimatedImageView`
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span><span style="color:#586e75"></span>     <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>context[SDWebImageContextAnimatedImageClass]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        options <span style="color:#719e07">|=</span> SDWebImageDecodeFirstFrameOnly;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span>     <span style="color:#586e75">// Do not force decode for png url
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span><span style="color:#586e75"></span>     <span style="color:#719e07">if</span> ([url.lastPathComponent isEqualToString:<span style="color:#2aa198">@&#34;png&#34;</span>]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        options <span style="color:#719e07">|=</span> SDWebImageAvoidDecodeImage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>     <span style="color:#586e75">// Always use screen scale factor
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span><span style="color:#586e75"></span>     SDWebImageMutableContext <span style="color:#719e07">*</span>mutableContext <span style="color:#719e07">=</span> [NSDictionary dictionaryWithDictionary:context];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span>     mutableContext[SDWebImageContextImageScaleFactor] <span style="color:#719e07">=</span> @(UIScreen.mainScreen.scale);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>     context <span style="color:#719e07">=</span> [mutableContext <span style="color:#719e07">copy</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span> 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>     <span style="color:#719e07">return</span> [[SDWebImageOptionsResult alloc] initWithOptions:options context:context];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span> }];
</code></pre></div><h3 id="loadimage">LoadImage</h3>
<p>接口的的第一个参数 url 作为整个框架的连接核心，却设计成 nullable 应该完全是方便调用方而设计的。内部通过对 url 的 nil 判断以及对 NSString 类型的兼容 (强制转成 NSURL) 以保证后续的流程，否则结束调用。下载开始后又拆分成了一下 6 个方法：</p>
<ul>
<li>callCacheProcessForOperation</li>
<li>callDownloadProcessForOperation</li>
<li>callStoreCacheProcessForOperation</li>
<li>callTransformProcessForOperation</li>
<li>callCompletionBlockForOperation</li>
<li>safelyRemoveOperationFromRunning</li>
</ul>
<p>分别是：缓存查询、下载、存储、转换、执行回调、清理回调。你可以发现每个方法都是针对 operation 的操作，operation 在 loadImage 时会准备好，然后开始缓存查询。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>SDWebImageCombinedOperation <span style="color:#719e07">*</span>operation <span style="color:#719e07">=</span> [SDWebImagCombinedOperation new];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>operation.manager <span style="color:#719e07">=</span> <span style="color:#b58900">self</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span><span style="color:#586e75">///  1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span><span style="color:#586e75"></span><span style="color:#dc322f">BOOL</span> isFailedUrl <span style="color:#719e07">=</span> <span style="color:#b58900">NO</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#719e07">if</span> (url) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>    SD_LOCK(<span style="color:#b58900">self</span>.failedURLsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>    isFailedUrl <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.failedURLs containsObject:url];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    SD_UNLOCK(<span style="color:#b58900">self</span>.failedURLsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">12</span><span style="color:#719e07">if</span> (url.absoluteString.length <span style="color:#719e07">==</span> <span style="color:#2aa198">0</span> <span style="color:#719e07">||</span> (<span style="color:#719e07">!</span>(options <span style="color:#719e07">&amp;</span> SDWebImageRetryFailed) <span style="color:#719e07">&amp;&amp;</span> isFailedUrl)) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">13</span>    [<span style="color:#b58900">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@{NSLocalizedDescriptionKey : <span style="color:#2aa198">@&#34;Image url is nil&#34;</span>}] url:url];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">14</span>    <span style="color:#719e07">return</span> operation;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">15</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">16</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">17</span>SD_LOCK(<span style="color:#b58900">self</span>.runningOperationsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">18</span>[<span style="color:#b58900">self</span>.runningOperations addObject:operation];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">19</span>SD_UNLOCK(<span style="color:#b58900">self</span>.runningOperationsLock);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">21</span><span style="color:#586e75">// 2. Preprocess the options and context arg to decide the final the result for manager
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">22</span><span style="color:#586e75"></span>SDWebImageOptionsResult <span style="color:#719e07">*</span>result <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span> processedResultForURL:url options:options context:context];
</code></pre></div><p><strong>loadImage</strong> 方法本身不复杂，核心是生成 operation 然后转入缓存查询。</p>
<p>在 operation 初始化后会检查  failedURLs 是否包含当前 url：</p>
<ul>
<li>如果有且 options 为 SDWebImageRetryFailed，直接结束并返回 operation；</li>
<li>如果检查通过会将 operation 存入 <code>runningOperations</code> 中。并将 options 和 imageContext 封入 SDWebImageOptionsResult。</li>
</ul>
<p>同时，会更新一波 imageContext，主要先将 transformer、cacheKeyFilter、cacheSerializer 存入 imageContext 做为全局默认设置，再调用 <strong>optionsProcessor</strong> 来提供用户的自定义 options 再次加工 imageContext 。这个套路大家应该有印象吧，前面的 ImageLoader 中的 requestModifer 的优先级逻辑与此类似，不过实现方式有些差异。最后转入 CacheProcess。</p>
<p><strong>loadImage</strong> 过程是使用了 combineOperation，它是 combine 了 cache 和 loader 的操作任务，使其可以一步到位清理缓存查询和下载任务的作用。其声明如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#719e07">@interface</span> <span style="color:#268bd2">SDWebImageCombinedOperation</span> : <span style="color:#268bd2">NSObject</span> <span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75">/// imageCache queryImageForKey: 的 operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable, <span style="color:#719e07">readonly</span>) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span> cacheOperation;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75">/// imageLoader requestImageWithURL: 的 operation
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span><span style="color:#586e75"></span><span style="color:#719e07">@property</span> (<span style="color:#719e07">strong</span>, <span style="color:#719e07">nonatomic</span>, nullable, <span style="color:#719e07">readonly</span>) <span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageOperation<span style="color:#719e07">&gt;</span> loaderOperation;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75">/// Cancel the current operation, including cache and loader process
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">7</span><span style="color:#586e75"></span>- (<span style="color:#dc322f">void</span>)<span style="color:#268bd2">cancel</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">8</span><span style="color:#719e07">@end</span>
</code></pre></div><p>其提供的 cancel 方法会逐步检查两种类型 opration 然后逐一执行 cancel 操作。</p>
<p>####CallCacheProcessForOperation</p>
<p>先检查 <strong>SDWebImageFromLoaderOnly</strong> 值，判断是否为直接下载的任务，</p>
<p>是，则转到 downloadProcess。</p>
<p>否，则通过 imageCache 创建查询任务并将其保存到 combineOperation 的 cacheOperation ：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span>operation.cacheOperation <span style="color:#719e07">=</span> [<span style="color:#b58900">self</span>.imageCache queryImageForKey:key options:options context:context completion:<span style="color:#719e07">^</span>(UIImage <span style="color:#719e07">*</span> _Nullable cachedImage, NSData <span style="color:#719e07">*</span> _Nullable cachedData, SDImageCacheType cacheType) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>   <span style="color:#719e07">if</span> (<span style="color:#719e07">!</span>operation <span style="color:#719e07">||</span> operation.isCancelled) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    	<span style="color:#586e75">/// 1  
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#586e75"></span>   }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">5</span>  	<span style="color:#586e75">/// 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">6</span><span style="color:#586e75"></span>}];
</code></pre></div><p>对缓存查询的结果有两种情况需要处理：</p>
<ol>
<li>当队列执行到该任务时，如果 operaton 被标志为 canceled 状态则结束下载任务；</li>
<li>否则转到 downloadProcess 。</li>
</ol>
<p>####CallDownloadProcessForOperation</p>
<p>下载的实现比较复杂，首先需要决定是否需要新建下载任务，由三个变量控制：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">BOOL</span> shouldDownload <span style="color:#719e07">=</span> <span style="color:#719e07">!</span>SD_OPTIONS_CONTAINS(options, SDWebImageFromCacheOnly);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span>    shouldDownload <span style="color:#719e07">&amp;=</span> (<span style="color:#719e07">!</span>cachedImage <span style="color:#719e07">||</span> options <span style="color:#719e07">&amp;</span> SDWebImageRefreshCached);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span>    shouldDownload <span style="color:#719e07">&amp;=</span> (<span style="color:#719e07">!</span>[<span style="color:#b58900">self</span>.delegate respondsToSelector:<span style="color:#719e07">@selector</span>(imageManager:shouldDownloadImageForURL:)] <span style="color:#719e07">||</span> [<span style="color:#b58900">self</span>.delegate imageManager:<span style="color:#b58900">self</span> shouldDownloadImageForURL:url]);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span>    shouldDownload <span style="color:#719e07">&amp;=</span> [<span style="color:#b58900">self</span>.imageLoader canRequestImageForURL:url];
</code></pre></div><ul>
<li>检查 options 值是否为 SDWebImageFromCacheOnly 或 SDWebImageRefreshCached 的</li>
<li>由代理决定是否需要新建下载任务</li>
<li>通过 imageLoader 控制能否支持下载任务</li>
</ul>
<ol>
<li>
<p>如果 shouldDownload 为 NO，则结束下载并调用 <strong>callCompletionBlockForOperation</strong> 与 <strong>safelyRemoveOperationFromRunning</strong>。此时如果存在 cacheImage 则会随 completionBlock 一起返回。</p>
</li>
<li>
<p>如果 shouldDownload 为 YES，新建下载任务并将其保存在 combineOperation 的 loaderOperation。在新建任务前，如有取到 cacheImage 且 SDWebImageRefreshCached 为 YES，会将其存入 imageContext (没有则创建 imageContext)。</p>
</li>
<li>
<p>下载结束后回到 callBack，这里会先处理几种情况：</p>
<ul>
<li>operation 被 cancel 则抛弃下载的 image、data ，callCompletionBlock 结束下载；</li>
<li>reqeust 被 cancel 导致的 error，callCompletionBlock 结束下载；</li>
<li>imageRefresh 后请求结果仍旧命中了 NSURLCache 缓存，则不会调用 callCompletionBlock；</li>
<li>errro 出错，callCompletionBlockForOperation 并将 url 添加至 failedURLs；</li>
<li>均无以上情况，如果是通过 retry 成功的，会先将 url 从 failedURLs 中移除，调用 storeCacheProcess；</li>
</ul>
<p>最后会对标记为 finished 的执行 safelyRemoveOperation；</p>
</li>
</ol>
<p>####CallStoreCacheProcessForOperation</p>
<p>先从 imageContext 中取出 storeCacheType、originalStoreCacheType、transformer、cacheSerializer，判断是否需要存储转换后图像数据、原始数据、等待缓存存储结束：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">BOOL</span> shouldTransformImage <span style="color:#719e07">=</span> downloadedImage <span style="color:#719e07">&amp;&amp;</span> (<span style="color:#719e07">!</span>downloadedImage.sd_isAnimated <span style="color:#719e07">||</span> (options <span style="color:#719e07">&amp;</span> SDWebImageTransformAnimatedImage)) <span style="color:#719e07">&amp;&amp;</span> transformer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#dc322f">BOOL</span> shouldCacheOriginal <span style="color:#719e07">=</span> downloadedImage <span style="color:#719e07">&amp;&amp;</span> finished;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#dc322f">BOOL</span> waitStoreCache <span style="color:#719e07">=</span> SD_OPTIONS_CONTAINS(options, SDWebImageWaitStoreCache);
</code></pre></div><p>如果 shouldCacheOriginal 为 NO，直接转入 transformProcess。否则，先确认存储类型是否为原始数据：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#586e75">// normally use the store cache type, but if target image is transformed, use original store cache type instead
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#586e75"></span>SDImageCacheType targetStoreCacheType <span style="color:#719e07">=</span> shouldTransformImage <span style="color:#719e07">?</span> originalStoreCacheType : storeCacheType;
</code></pre></div><p>存储时如果 cacheSerializer 存在则会先转换数据格式，最终都调用 <code>[self stroageImage: ...]</code> 。</p>
<p>当存储结束时，转入最后一步，transformProcess。</p>
<p>####CallTransformProcessForOperation</p>
<p>转换开始前会例行判断是否需要转换，为 false 则 callCompletionBlock 结束下载，判断如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">1</span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDImageTransformer<span style="color:#719e07">&gt;</span> transformer <span style="color:#719e07">=</span> context[SDWebImageContextImageTransformer];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">2</span><span style="color:#dc322f">id</span><span style="color:#719e07">&lt;</span>SDWebImageCacheSerializer<span style="color:#719e07">&gt;</span> cacheSerializer <span style="color:#719e07">=</span> context[SDWebImageContextCacheSerializer];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">3</span><span style="color:#dc322f">BOOL</span> shouldTransformImage <span style="color:#719e07">=</span> originalImage <span style="color:#719e07">&amp;&amp;</span> (<span style="color:#719e07">!</span>originalImage.sd_isAnimated <span style="color:#719e07">||</span> (options <span style="color:#719e07">&amp;</span> SDWebImageTransformAnimatedImage)) <span style="color:#719e07">&amp;&amp;</span> transformer;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">4</span><span style="color:#dc322f">BOOL</span> waitStoreCache <span style="color:#719e07">=</span> SD_OPTIONS_CONTAINS(options, SDWebImageWaitStoreCache);
</code></pre></div><p>如果需要转换，会进入全局队列开始处理：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-objective-c" data-lang="objective-c"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 1</span>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span style="color:#2aa198">0</span>), <span style="color:#719e07">^</span>{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 2</span>    <span style="color:#719e07">@autoreleasepool</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 3</span>        UIImage <span style="color:#719e07">*</span>transformedImage <span style="color:#719e07">=</span> [transformer transformedImageWithImage:originalImage forKey:key];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 4</span>        <span style="color:#719e07">if</span> (transformedImage <span style="color:#719e07">&amp;&amp;</span> finished) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 5</span>				<span style="color:#586e75">/// 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 6</span><span style="color:#586e75"></span>        } <span style="color:#719e07">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 7</span>				callCompletionBlock
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 8</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050"> 9</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#495050">10</span>});        
</code></pre></div><p>转换成功后，会依据 <code>cacheData = [cacheSerializer cacheDataWithImage: originalData: imageURL:];</code>  进行 <code>[self storageImage: ...]</code>存储图片。存储结束后 callCompletionBlock。</p>
<h2 id="总结">总结</h2>
<p>如果你能看到这里，还是很有耐心的。希望大家看完能够大概了解 SD 的 work-flow，以及一些细节上的处理和思考。在 SD 5.x 中，个人感受最多的是其架构的设计值得借鉴。</p>
<ul>
<li>如何设计一个稳定可扩展的 API 又能安全地支持动态添加参数？</li>
<li>如果设计一个解耦又可动态插拔的架构？</li>
</ul>
<p>最后，这篇其实还少了 SDImageCoder，这个留到下一篇的 SDWebImage 插件及其扩展上来说。</p>
</section>

  
  
  <footer class="post-tags">
     
    <a href="https://looseyi.github.io/tags/source-code">Source Code</a>
     
    <a href="https://looseyi.github.io/tags/ios">iOS</a>
     
    <a href="https://looseyi.github.io/tags/cache">cache</a>
    
  </footer>
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://looseyi.github.io/post/sourcecode-ios/source-code-sdweb-2/"><span>←</span><span>浅析 SDWebImage 5.5.2 - WebP Plugin</span></a>
     
    <a class="next" href="https://looseyi.github.io/post/sourcecode-ios/cocoapods-binary-2/"><span>完善 Cocoapods-Binary 支持 Server 端缓存</span><span>→</span></a>
    
  </nav>
  

  
  
</article>


			

  

  
    <script src="https://utteranc.es/client.js"
            repo="looseyi/looseyi.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

		</main>

    <footer class="footer">
  <p>&copy; 2021 <a href="https://looseyi.github.io/">Aha Edmond</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.1</a>
  </p>
</footer>

		


  </body>
</html>
